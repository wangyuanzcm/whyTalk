const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      './index-jMCgefF-.js',
      './index-CP-MMhae.js',
      './index-BW6YxOm9.css',
      './index-CSbRCW7e.js',
      './index-BSjlmN_j.js',
      './index-DwAlBAzC.js',
      './index-CHqsOsLh.js',
      './index-CRoXZydy.js',
      './index-DK-86nzt.js',
      './index-l_kxj-Qp.js',
      './index-fP7_3oki.js',
      './index-BuwiCW2_.js',
      './index-ClD5AWZd.js',
      './index-Cc7Zf0nm.js',
      './index-DMAWZZQR.js',
      './index-C5rrPrtW.js',
      './dockerfile-DUNqykAP.js',
      './simple-mode-zrLq6ojR.js',
      './factor-BqI9_rff.js',
      './nsis-BbZeYEiA.js',
      './pug-By0kVCfm.js',
      './javascript-C3MnDRiU.js',
      './index-BG3EwtfT.js',
      './index-BZQmcA9k.js'
    ])
) => i.map((i) => d[i])
import {
  t as defineComponent,
  a4 as reactive,
  a1 as ref,
  ah as watch,
  a2 as onMounted,
  bd as onBeforeUnmount,
  bn as cloneVNode,
  H as createVNode,
  ba as inject,
  bk as provide,
  z as computed,
  F as Fragment,
  cY as useId,
  b7 as toRef,
  cZ as shallowRef,
  bC as nextTick,
  c_ as LRUCache,
  u as h,
  c$ as Teleport,
  d0 as __vitePreload,
  d1 as isVNode
} from './index-CP-MMhae.js'
const T = (e2) => {
    const n2 = typeof e2
    return (n2 !== 'function' && n2 !== 'object') || e2 === null
  },
  E = (e2) => {
    const n2 = e2.flags === '' ? void 0 : e2.flags
    return new RegExp(e2.source, n2)
  },
  u = (e2, n2 = /* @__PURE__ */ new WeakMap()) => {
    if (e2 === null || T(e2)) return e2
    if (n2.has(e2)) return n2.get(e2)
    if (e2 instanceof RegExp) return E(e2)
    if (e2 instanceof Date) return new Date(e2.getTime())
    if (e2 instanceof Function) return e2
    if (e2 instanceof Map) {
      const r2 = /* @__PURE__ */ new Map()
      return (
        n2.set(e2, r2),
        e2.forEach((o, s) => {
          r2.set(s, u(o, n2))
        }),
        r2
      )
    }
    if (e2 instanceof Set) {
      const r2 = /* @__PURE__ */ new Set()
      n2.set(e2, r2)
      for (const o of e2) r2.add(u(o, n2))
      return r2
    }
    if (Array.isArray(e2)) {
      const r2 = []
      return (
        n2.set(e2, r2),
        e2.forEach((o) => {
          r2.push(u(o, n2))
        }),
        r2
      )
    }
    const t2 = {}
    n2.set(e2, t2)
    for (const r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && (t2[r2] = u(e2[r2], n2))
    return t2
  },
  k = (e2, n2 = 200) => {
    let t2 = 0
    return (...r2) =>
      new Promise((o) => {
        ;(t2 && (clearTimeout(t2), o('cancel')),
          (t2 = window.setTimeout(() => {
            ;(e2.apply(void 0, r2), (t2 = 0), o('done'))
          }, n2)))
      })
  },
  C$1 = (
    e2,
    n2 = {
      _blank: true,
      nofollow: true
    }
  ) => {
    const t2 = document.createElement('a')
    ;((t2.href = e2),
      n2._blank && (t2.target = '_blank'),
      n2.nofollow && (t2.rel = 'noopener noreferrer'),
      t2.click())
  },
  x = () => {
    let e2 = -1
    return (t2, r2, o, s = 100) => {
      const c = () => {
        o && (typeof s == 'number' ? setTimeout(o, s) : o())
      }
      e2 !== -1 && (cancelAnimationFrame(e2), c())
      let i = t2.scrollTop
      const l = () => {
        e2 = -1
        const a = r2 - i
        ;((i = i + a / 5),
          Math.abs(a) < 1
            ? (t2.scrollTo(0, r2), c())
            : (t2.scrollTo(0, i), (e2 = requestAnimationFrame(l))))
      }
      e2 = requestAnimationFrame(l)
    }
  },
  $ = (e2, n2 = 200) => {
    let t2 = 0,
      r2 = null
    const o = (s) => {
      ;(t2 === 0 && (t2 = s),
        s - t2 >= n2
          ? (e2.apply(void 0, r2), (r2 = null), (t2 = 0))
          : window.requestAnimationFrame(o))
    }
    return (...s) => {
      ;(r2 === null && window.requestAnimationFrame(o), (r2 = s))
    }
  },
  I = (e2) => {
    const n2 = (t2) => {
      const {
          scrollHeight: r2,
          scrollWidth: o,
          offsetHeight: s,
          offsetWidth: c,
          scrollLeft: i,
          scrollTop: l
        } = e2,
        a = t2.x,
        h2 = t2.y,
        p = (g) => {
          const f = l + h2 - g.y,
            d = i + a - g.x,
            S2 = r2 - s,
            A = o - c,
            m = {}
          ;(d >= 0 && d <= A && (m.left = d), f >= 0 && f <= S2 && (m.top = f), e2.scroll(m))
        }
      document.addEventListener('mousemove', p)
      const w = () => {
        ;(document.removeEventListener('mousemove', p), document.removeEventListener('mouseup', w))
      }
      document.addEventListener('mouseup', w)
    }
    return (
      e2.addEventListener('mousedown', n2),
      () => {
        e2.removeEventListener('mousedown', n2)
      }
    )
  },
  U = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`,
  y = (e2) => e2 !== null && typeof e2 == 'object' && !Array.isArray(e2),
  M = (e2, n2, t2 = {}) => {
    const { excludeKeys: r2 } = t2
    for (const o in n2)
      r2 && r2(o)
        ? (e2[o] = n2[o])
        : y(n2[o]) && y(e2[o])
          ? (e2[o] = M(e2[o], n2[o], t2))
          : (e2[o] = n2[o])
    return e2
  }
const prefix = 'md-editor'
const cdnBase = 'https://unpkg.com'
const highlightUrl = `${cdnBase}/@highlightjs/cdn-assets@11.10.0/highlight.min.js`
const prettierUrl = {
  main: `${cdnBase}/prettier@3.3.3/standalone.js`,
  markdown: `${cdnBase}/prettier@3.3.3/plugins/markdown.js`
}
const cropperUrl = {
  css: `${cdnBase}/cropperjs@1.6.2/dist/cropper.min.css`,
  js: `${cdnBase}/cropperjs@1.6.2/dist/cropper.min.js`
}
const screenfullUrl = `${cdnBase}/screenfull@5.2.0/dist/screenfull.js`
const mermaidUrl = `${cdnBase}/mermaid@11.9.0/dist/mermaid.min.js`
const katexUrl = {
  js: `${cdnBase}/katex@0.16.22/dist/katex.min.js`,
  css: `${cdnBase}/katex@0.16.22/dist/katex.min.css`
}
const codeCss = {
  a11y: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/a11y-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/github.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/gradient-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-dark.min.css`
  }
}
const allToolbar = [
  'bold',
  'underline',
  'italic',
  'strikeThrough',
  '-',
  'title',
  'sub',
  'sup',
  'quote',
  'unorderedList',
  'orderedList',
  'task',
  '-',
  'codeRow',
  'code',
  'link',
  'image',
  'table',
  'mermaid',
  'katex',
  '-',
  'revoke',
  'next',
  'save',
  '=',
  'prettier',
  'pageFullscreen',
  'fullscreen',
  'preview',
  'previewOnly',
  'htmlPreview',
  'catalog',
  'github'
]
const allFooter = ['markdownTotal', '=', 'scrollSwitch']
const staticTextDefault = {
  'zh-CN': {
    toolbarTips: {
      bold: '加粗',
      underline: '下划线',
      italic: '斜体',
      strikeThrough: '删除线',
      title: '标题',
      sub: '下标',
      sup: '上标',
      quote: '引用',
      unorderedList: '无序列表',
      orderedList: '有序列表',
      task: '任务列表',
      codeRow: '行内代码',
      code: '块级代码',
      link: '链接',
      image: '图片',
      table: '表格',
      mermaid: 'mermaid图',
      katex: 'katex公式',
      revoke: '后退',
      next: '前进',
      save: '保存',
      prettier: '美化',
      pageFullscreen: '浏览器全屏',
      fullscreen: '屏幕全屏',
      preview: '预览',
      previewOnly: '仅预览',
      htmlPreview: 'html代码预览',
      catalog: '目录',
      github: '源码地址'
    },
    titleItem: {
      h1: '一级标题',
      h2: '二级标题',
      h3: '三级标题',
      h4: '四级标题',
      h5: '五级标题',
      h6: '六级标题'
    },
    imgTitleItem: {
      link: '添加链接',
      upload: '上传图片',
      clip2upload: '裁剪上传'
    },
    linkModalTips: {
      linkTitle: '添加链接',
      imageTitle: '添加图片',
      descLabel: '链接描述：',
      descLabelPlaceHolder: '请输入描述...',
      urlLabel: '链接地址：',
      urlLabelPlaceHolder: '请输入链接...',
      buttonOK: '确定'
    },
    clipModalTips: {
      title: '裁剪图片上传',
      buttonUpload: '上传'
    },
    copyCode: {
      text: '复制代码',
      successTips: '已复制！',
      failTips: '复制失败！'
    },
    mermaid: {
      flow: '流程图',
      sequence: '时序图',
      gantt: '甘特图',
      class: '类图',
      state: '状态图',
      pie: '饼图',
      relationship: '关系图',
      journey: '旅程图'
    },
    katex: {
      inline: '行内公式',
      block: '块级公式'
    },
    footer: {
      markdownTotal: '字数',
      scrollAuto: '同步滚动'
    }
  },
  'en-US': {
    toolbarTips: {
      bold: 'bold',
      underline: 'underline',
      italic: 'italic',
      strikeThrough: 'strikeThrough',
      title: 'title',
      sub: 'subscript',
      sup: 'superscript',
      quote: 'quote',
      unorderedList: 'unordered list',
      orderedList: 'ordered list',
      task: 'task list',
      codeRow: 'inline code',
      code: 'block-level code',
      link: 'link',
      image: 'image',
      table: 'table',
      mermaid: 'mermaid',
      katex: 'formula',
      revoke: 'revoke',
      next: 'undo revoke',
      save: 'save',
      prettier: 'prettier',
      pageFullscreen: 'fullscreen in page',
      fullscreen: 'fullscreen',
      preview: 'preview',
      previewOnly: 'preview only',
      htmlPreview: 'html preview',
      catalog: 'catalog',
      github: 'source code'
    },
    titleItem: {
      h1: 'Lv1 Heading',
      h2: 'Lv2 Heading',
      h3: 'Lv3 Heading',
      h4: 'Lv4 Heading',
      h5: 'Lv5 Heading',
      h6: 'Lv6 Heading'
    },
    imgTitleItem: {
      link: 'Add Image Link',
      upload: 'Upload Images',
      clip2upload: 'Crop And Upload'
    },
    linkModalTips: {
      linkTitle: 'Add Link',
      imageTitle: 'Add Image',
      descLabel: 'Desc:',
      descLabelPlaceHolder: 'Enter a description...',
      urlLabel: 'Link:',
      urlLabelPlaceHolder: 'Enter a link...',
      buttonOK: 'OK'
    },
    clipModalTips: {
      title: 'Crop Image',
      buttonUpload: 'Upload'
    },
    copyCode: {
      text: 'Copy',
      successTips: 'Copied!',
      failTips: 'Copy failed!'
    },
    mermaid: {
      flow: 'flow',
      sequence: 'sequence',
      gantt: 'gantt',
      class: 'class',
      state: 'state',
      pie: 'pie',
      relationship: 'relationship',
      journey: 'journey'
    },
    katex: {
      inline: 'inline',
      block: 'block'
    },
    footer: {
      markdownTotal: 'Character Count',
      scrollAuto: 'Scroll Auto'
    }
  }
}
const globalConfig = {
  editorExtensions: {
    highlight: {
      js: highlightUrl,
      css: codeCss
    },
    prettier: {
      standaloneJs: prettierUrl.main,
      parserMarkdownJs: prettierUrl.markdown
    },
    cropper: {
      ...cropperUrl
    },
    screenfull: {
      js: screenfullUrl
    },
    mermaid: {
      js: mermaidUrl,
      enableZoom: true
    },
    katex: {
      ...katexUrl
    }
  },
  editorExtensionsAttrs: {},
  editorConfig: {
    languageUserDefined: {},
    mermaidTemplate: {},
    renderDelay: 500,
    zIndex: 2e4
  },
  codeMirrorExtensions: (_theme, innerExtensions) => innerExtensions,
  markdownItConfig: () => {},
  markdownItPlugins: (s) => s,
  mermaidConfig: (c) => c,
  katexConfig: (c) => c
}
const MinInputBoxWidth = 0.1
const getSlot = ({ instance, ctx, props: props2 = {} }, name2 = 'default') => {
  const targetSlot =
    (instance == null ? void 0 : instance.$slots[name2]) ||
    (ctx == null ? void 0 : ctx.slots[name2])
  return (targetSlot ? targetSlot(instance) : '') || props2[name2]
}
const props$1$2 = {
  overlay: {
    type: [String, Object],
    default: ''
  },
  visible: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {}
  },
  // 相对滚动的元素选择器
  relative: {
    type: String,
    default: 'html'
  },
  disabled: {
    type: Boolean,
    default: void 0
  }
}
const Dropdown = /* @__PURE__ */ defineComponent({
  name: `${prefix}-dropdown`,
  props: props$1$2,
  setup(props2, ctx) {
    const HIDDEN_CLASS = `${prefix}-dropdown-hidden`
    const ctl = reactive({
      overlayClass: [HIDDEN_CLASS],
      overlayStyle: {},
      triggerHover: false,
      overlayHover: false
    })
    const triggerRef = ref()
    const overlayRef = ref()
    const triggerHandler = () => {
      var _a2, _b
      if (props2.disabled) {
        return false
      }
      ctl.triggerHover = true
      const triggerEle = triggerRef.value
      const overlayEle = overlayRef.value
      if (!triggerEle || !overlayEle) {
        return
      }
      const triggerInfo = triggerEle.getBoundingClientRect()
      const triggerTop = triggerEle.offsetTop
      const triggerLeft = triggerEle.offsetLeft
      const triggerHeight = triggerInfo.height
      const triggerWidth = triggerInfo.width
      const rootNode = triggerEle.getRootNode()
      const relativecrollLeft =
        ((_a2 = rootNode.querySelector(props2.relative)) == null ? void 0 : _a2.scrollLeft) || 0
      const relativeWidth =
        ((_b = rootNode.querySelector(props2.relative)) == null ? void 0 : _b.clientWidth) || 0
      let left = triggerLeft - overlayEle.offsetWidth / 2 + triggerWidth / 2 - relativecrollLeft
      if (left + overlayEle.offsetWidth > relativecrollLeft + relativeWidth) {
        left = relativecrollLeft + relativeWidth - overlayEle.offsetWidth
      }
      if (left < 0) {
        left = 0
      }
      ctl.overlayStyle = {
        ...ctl.overlayStyle,
        top: triggerTop + triggerHeight + 'px',
        left: left + 'px'
      }
      props2.onChange(true)
    }
    const overlayHandler = () => {
      if (props2.disabled) {
        return false
      }
      ctl.overlayHover = true
    }
    watch(
      () => props2.visible,
      (newV) => {
        if (newV) {
          ctl.overlayClass = ctl.overlayClass.filter((classItem) => classItem !== HIDDEN_CLASS)
        } else {
          ctl.overlayClass.push(HIDDEN_CLASS)
        }
      }
    )
    let hiddenTimer = -1
    const leaveHidden = (e2) => {
      if (triggerRef.value === e2.target) {
        ctl.triggerHover = false
      } else {
        ctl.overlayHover = false
      }
      clearTimeout(hiddenTimer)
      hiddenTimer = window.setTimeout(() => {
        if (!ctl.overlayHover && !ctl.triggerHover) {
          props2.onChange(false)
        }
      }, 10)
    }
    onMounted(() => {
      triggerRef.value.addEventListener('mouseenter', triggerHandler)
      triggerRef.value.addEventListener('mouseleave', leaveHidden)
      overlayRef.value.addEventListener('mouseenter', overlayHandler)
      overlayRef.value.addEventListener('mouseleave', leaveHidden)
    })
    onBeforeUnmount(() => {
      triggerRef.value.removeEventListener('mouseenter', triggerHandler)
      triggerRef.value.removeEventListener('mouseleave', leaveHidden)
      overlayRef.value.removeEventListener('mouseenter', overlayHandler)
      overlayRef.value.removeEventListener('mouseleave', leaveHidden)
    })
    return () => {
      const slotDefault = getSlot({
        ctx
      })
      const slotOverlay = getSlot(
        {
          props: props2,
          ctx
        },
        'overlay'
      )
      const trigger = cloneVNode(slotDefault instanceof Array ? slotDefault[0] : slotDefault, {
        ref: triggerRef,
        key: 'cloned-dropdown-trigger'
      })
      const overlay = createVNode(
        'div',
        {
          class: [`${prefix}-dropdown`, ctl.overlayClass],
          style: ctl.overlayStyle,
          ref: overlayRef
        },
        [
          createVNode(
            'div',
            {
              class: `${prefix}-dropdown-overlay`
            },
            [slotOverlay instanceof Array ? slotOverlay[0] : slotOverlay]
          )
        ]
      )
      return [trigger, overlay]
    }
  }
})
const props$c = {
  title: {
    type: String,
    default: ''
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  /**
   * 展示在工具栏的内容，通常是个图标
   *
   * @deprecated 使用默认插槽代替
   */
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onChange: {
    type: Function,
    default: void 0
  },
  // 下拉框中的内容
  overlay: {
    type: [String, Object],
    default: void 0
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  showToolbarName: {
    type: Boolean,
    default: void 0
  }
  /**
   * ==结束
   */
}
const DropdownToolbar = /* @__PURE__ */ defineComponent({
  name: 'DropdownToolbar',
  props: props$c,
  emits: ['onChange'],
  setup(props2, ctx) {
    const editorId = inject('editorId')
    return () => {
      const Trigger = getSlot(
        {
          props: props2,
          ctx
        },
        'trigger'
      )
      const Overlay = getSlot(
        {
          props: props2,
          ctx
        },
        'overlay'
      )
      const Default = getSlot({
        props: props2,
        ctx
      })
      return createVNode(
        Dropdown,
        {
          relative: `#${editorId}-toolbar-wrapper`,
          visible: props2.visible,
          onChange: (v) => {
            var _a2
            ;(_a2 = props2.onChange) == null ? void 0 : _a2.call(props2, v)
            ctx.emit('onChange', v)
          },
          overlay: Overlay,
          disabled: props2.disabled
        },
        {
          default: () => [
            createVNode(
              'div',
              {
                class: [`${prefix}-toolbar-item`, props2.disabled && `${prefix}-disabled`],
                title: props2.title || ''
              },
              [Default || Trigger]
            )
          ]
        }
      )
    }
  }
})
DropdownToolbar.install = (app) => {
  app.component(DropdownToolbar.name, DropdownToolbar)
  return app
}
var __defProp$1 = Object.defineProperty
var __defNormalProp$1 = (obj, key, value) =>
  key in obj
    ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value)
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, key + '', value)
class Bus {
  constructor() {
    __publicField$1(this, 'pools', {})
  }
  // 移除事件监听
  remove(race, name2, func) {
    const targetRace = this.pools[race]
    const events = targetRace && this.pools[race][name2]
    if (events) {
      this.pools[race][name2] = events.filter((item) => item !== func)
    }
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(race) {
    this.pools[race] = {}
  }
  // 注册事件监听
  on(race, event) {
    if (!this.pools[race]) {
      this.pools[race] = {}
    }
    if (!this.pools[race][event.name]) {
      this.pools[race][event.name] = []
    }
    this.pools[race][event.name].push(event.callback)
    return this.pools[race][event.name].includes(event.callback)
  }
  // 触发事件
  emit(race, name2, ...params) {
    if (!this.pools[race]) {
      this.pools[race] = {}
    }
    const targetRace = this.pools[race]
    const events = targetRace[name2]
    if (events) {
      events.forEach((item) => {
        try {
          item(...params)
        } catch (error2) {
          console.error(`${name2} monitor event exception！`, error2)
        }
      })
    }
  }
}
const bus = new Bus()
const ON_SAVE = 'onSave'
const CHANGE_CATALOG_VISIBLE = 'changeCatalogVisible'
const CHANGE_FULL_SCREEN = 'changeFullscreen'
const PAGE_FULL_SCREEN_CHANGED = 'pageFullscreenChanged'
const FULL_SCREEN_CHANGED = 'fullscreenChanged'
const PREVIEW_CHANGED = 'previewChanged'
const PREVIEW_ONLY_CHANGED = 'previewOnlyChanged'
const HTML_PREVIEW_CHANGED = 'htmlPreviewChanged'
const CATALOG_VISIBLE_CHANGED = 'catalogVisibleChanged'
const BUILD_FINISHED = 'buildFinished'
const ERROR_CATCHER = 'errorCatcher'
const REPLACE = 'replace'
const UPLOAD_IMAGE = 'uploadImage'
const OPEN_MODALS = 'openModals'
const CTRL_Z = 'ctrlZ'
const CTRL_SHIFT_Z = 'ctrlShiftZ'
const CATALOG_CHANGED = 'catalogChanged'
const PUSH_CATALOG = 'pushCatalog'
const RERENDER = 'rerender'
const EVENT_LISTENER = 'eventListener'
const TASK_STATE_CHANGED = 'taskStateChanged'
const SEND_EDITOR_VIEW = 'sendEditorView'
const GET_EDITOR_VIEW = 'getEditorView'
const iconMaps$1 = {
  copy: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy ${prefix}-icon"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,
  'collapse-tips': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-chevron-left ${prefix}-icon"><circle cx="12" cy="12" r="10"/><path d="m14 16-4-4 4-4"/></svg>`,
  pin: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pin"><path d="M12 17v5"/><path d="M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z"/></svg>`,
  'pin-off': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pin-off"><path d="M12 17v5"/><path d="M15 9.34V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H7.89"/><path d="m2 2 20 20"/><path d="M9 9v1.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h11"/></svg>`
}
const StrIcon = (name2, customIcon) => {
  if (typeof customIcon[name2] === 'string') {
    return customIcon[name2]
  }
  return iconMaps$1[name2]
}
const keyMove = (trigger, moveHandler) => {
  const triggerMouseDown = (mdown) => {
    const parent = trigger.parentElement || document.body
    const width = parent.offsetWidth
    const height = parent.offsetHeight
    const { clientWidth, clientHeight } = document.documentElement
    const x2 = mdown.offsetX
    const y2 = mdown.offsetY
    const mouseMoveHandler = (e2) => {
      let tx = e2.x + document.body.scrollLeft - document.body.clientLeft - x2
      let ty = e2.y + document.body.scrollTop - document.body.clientTop - y2
      tx = tx < 1 ? 1 : tx < clientWidth - width - 1 ? tx : clientWidth - width - 1
      ty = ty < 1 ? 1 : ty < clientHeight - height - 1 ? ty : clientHeight - height - 1
      if (moveHandler) {
        moveHandler(tx, ty)
      } else {
        parent.style.left = `${tx}px`
        parent.style.top = `${ty}px`
      }
    }
    document.addEventListener('mousemove', mouseMoveHandler)
    const mouseUpHandler = () => {
      document.removeEventListener('mousemove', mouseMoveHandler)
      document.removeEventListener('mouseup', mouseUpHandler)
    }
    document.addEventListener('mouseup', mouseUpHandler)
  }
  trigger.addEventListener('mousedown', triggerMouseDown)
  return () => {
    trigger.removeEventListener('mousedown', triggerMouseDown)
  }
}
const appendHandler = (tagName, attributes, checkKey = '') => {
  var _a2
  const insertedEle = document.getElementById(attributes.id)
  if (!insertedEle) {
    const attrsCopy = { ...attributes }
    attrsCopy.onload = null
    const ele = createHTMLElement(tagName, attrsCopy)
    if (attributes.onload) {
      ele.addEventListener('load', attributes.onload)
    }
    document.head.appendChild(ele)
  } else if (checkKey !== '') {
    if (Reflect.get(window, checkKey)) {
      ;(_a2 = attributes.onload) == null ? void 0 : _a2.call(insertedEle, new Event('load'))
    } else {
      if (attributes.onload) {
        insertedEle.addEventListener('load', attributes.onload)
      }
    }
  }
}
const updateHandler = (tagName, attributes) => {
  const insertedEle = document.getElementById(attributes.id)
  insertedEle == null ? void 0 : insertedEle.remove()
  appendHandler(tagName, attributes)
}
const createHTMLElement = (tagName, attributes) => {
  const element = document.createElement(tagName)
  Object.keys(attributes).forEach((key) => {
    if (attributes[key] !== void 0) {
      element[key] = attributes[key]
    }
  })
  return element
}
const zoomMermaid = /* @__PURE__ */ (() => {
  const addEvent = (container) => {
    if (!container) {
      return () => {}
    }
    const content2 = container.firstChild
    let scale = 1
    let posX = 0
    let posY = 0
    let isDragging = false
    let startX, startY
    let initialDistance
    let initialScale = 1
    const updateTransform = () => {
      content2.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`
    }
    const onTouchStart = (event) => {
      if (event.touches.length === 1) {
        isDragging = true
        startX = event.touches[0].clientX - posX
        startY = event.touches[0].clientY - posY
      } else if (event.touches.length === 2) {
        initialDistance = Math.hypot(
          event.touches[0].clientX - event.touches[1].clientX,
          event.touches[0].clientY - event.touches[1].clientY
        )
        initialScale = scale
      }
    }
    const onTouchMove = (event) => {
      event.preventDefault()
      if (isDragging && event.touches.length === 1) {
        posX = event.touches[0].clientX - startX
        posY = event.touches[0].clientY - startY
        updateTransform()
      } else if (event.touches.length === 2) {
        const newDistance = Math.hypot(
          event.touches[0].clientX - event.touches[1].clientX,
          event.touches[0].clientY - event.touches[1].clientY
        )
        const scaleChange = newDistance / initialDistance
        const previousScale = scale
        scale = initialScale * (1 + (scaleChange - 1))
        const centerX = (event.touches[0].clientX + event.touches[1].clientX) / 2
        const centerY = (event.touches[0].clientY + event.touches[1].clientY) / 2
        const rect = content2.getBoundingClientRect()
        const relativeX = (centerX - rect.left) / previousScale
        const relativeY = (centerY - rect.top) / previousScale
        posX -= relativeX * (scale - previousScale)
        posY -= relativeY * (scale - previousScale)
        updateTransform()
      }
    }
    const onTouchEnd = () => {
      isDragging = false
    }
    const onWheel = (event) => {
      event.preventDefault()
      const scaleAmount = 0.02
      const previousScale = scale
      if (event.deltaY < 0) {
        scale += scaleAmount
      } else {
        scale = Math.max(0.1, scale - scaleAmount)
      }
      const rect = content2.getBoundingClientRect()
      const mouseX = event.clientX - rect.left
      const mouseY = event.clientY - rect.top
      posX -= (mouseX / previousScale) * (scale - previousScale)
      posY -= (mouseY / previousScale) * (scale - previousScale)
      updateTransform()
    }
    const onMouseDown = (event) => {
      isDragging = true
      startX = event.clientX - posX
      startY = event.clientY - posY
    }
    const onMouseMove = (event) => {
      if (isDragging) {
        posX = event.clientX - startX
        posY = event.clientY - startY
        updateTransform()
      }
    }
    const onMouseUp = () => {
      isDragging = false
    }
    const onMouseLeave = () => {
      isDragging = false
    }
    container.addEventListener('touchstart', onTouchStart, { passive: false })
    container.addEventListener('touchmove', onTouchMove, { passive: false })
    container.addEventListener('touchend', onTouchEnd)
    container.addEventListener('wheel', onWheel, { passive: false })
    container.addEventListener('mousedown', onMouseDown)
    container.addEventListener('mousemove', onMouseMove)
    container.addEventListener('mouseup', onMouseUp)
    container.addEventListener('mouseleave', onMouseLeave)
    return () => {
      container.removeEventListener('touchstart', onTouchStart)
      container.removeEventListener('touchmove', onTouchMove)
      container.removeEventListener('touchend', onTouchEnd)
      container.removeEventListener('wheel', onWheel)
      container.removeEventListener('mousedown', onMouseDown)
      container.removeEventListener('mousemove', onMouseMove)
      container.removeEventListener('mouseup', onMouseUp)
      container.removeEventListener('mouseleave', onMouseLeave)
    }
  }
  const handler = (containers, options) => {
    const removeEventsMap = /* @__PURE__ */ new Map()
    containers == null
      ? void 0
      : containers.forEach((mm) => {
          let actionDiv = mm.querySelector(`.${prefix}-mermaid-action`)
          if (!actionDiv) {
            mm.insertAdjacentHTML(
              'beforeend',
              `<div class="${prefix}-mermaid-action">${StrIcon('pin-off', options.customIcon)}</div>`
            )
            actionDiv = mm.querySelector(`.${prefix}-mermaid-action`)
          }
          const onClick = () => {
            const current = removeEventsMap.get(mm)
            if (current == null ? void 0 : current.removeEvent) {
              current.removeEvent()
              mm.removeAttribute('data-grab')
              removeEventsMap.set(mm, { removeClick: current.removeClick })
              actionDiv.innerHTML = StrIcon('pin-off', options.customIcon)
            } else {
              const removeEvent = addEvent(mm)
              mm.setAttribute('data-grab', '')
              removeEventsMap.set(mm, {
                removeEvent,
                removeClick: current == null ? void 0 : current.removeClick
              })
              actionDiv.innerHTML = StrIcon('pin', options.customIcon)
            }
          }
          actionDiv.addEventListener('click', onClick)
          removeEventsMap.set(mm, {
            removeClick: () => actionDiv.removeEventListener('click', onClick)
          })
        })
    return () => {
      removeEventsMap.forEach(({ removeEvent, removeClick }) => {
        removeEvent == null ? void 0 : removeEvent()
        removeClick == null ? void 0 : removeClick()
      })
      removeEventsMap.clear()
    }
  }
  return handler
})()
/*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom */
var _extends =
  Object.assign ||
  function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i]
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key]
        }
      }
    }
    return target
  }
var isSupported = function isSupported2(node) {
  return node.tagName === 'IMG'
}
var isNodeList = function isNodeList2(selector) {
  return NodeList.prototype.isPrototypeOf(selector)
}
var isNode = function isNode2(selector) {
  return selector && selector.nodeType === 1
}
var isSvg = function isSvg2(image2) {
  var source = image2.currentSrc || image2.src
  return source.substr(-4).toLowerCase() === '.svg'
}
var getImagesFromSelector = function getImagesFromSelector2(selector) {
  try {
    if (Array.isArray(selector)) {
      return selector.filter(isSupported)
    }
    if (isNodeList(selector)) {
      return [].slice.call(selector).filter(isSupported)
    }
    if (isNode(selector)) {
      return [selector].filter(isSupported)
    }
    if (typeof selector === 'string') {
      return [].slice.call(document.querySelectorAll(selector)).filter(isSupported)
    }
    return []
  } catch (err) {
    throw new TypeError(
      'The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom'
    )
  }
}
var createOverlay = function createOverlay2(background2) {
  var overlay = document.createElement('div')
  overlay.classList.add('medium-zoom-overlay')
  overlay.style.background = background2
  return overlay
}
var cloneTarget = function cloneTarget2(template2) {
  var _template$getBounding = template2.getBoundingClientRect(),
    top2 = _template$getBounding.top,
    left = _template$getBounding.left,
    width = _template$getBounding.width,
    height = _template$getBounding.height
  var clone = template2.cloneNode()
  var scrollTop =
    window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
  var scrollLeft =
    window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0
  clone.removeAttribute('id')
  clone.style.position = 'absolute'
  clone.style.top = top2 + scrollTop + 'px'
  clone.style.left = left + scrollLeft + 'px'
  clone.style.width = width + 'px'
  clone.style.height = height + 'px'
  clone.style.transform = ''
  return clone
}
var createCustomEvent = function createCustomEvent2(type, params) {
  var eventParams = _extends(
    {
      bubbles: false,
      cancelable: false,
      detail: void 0
    },
    params
  )
  if (typeof window.CustomEvent === 'function') {
    return new CustomEvent(type, eventParams)
  }
  var customEvent = document.createEvent('CustomEvent')
  customEvent.initCustomEvent(type, eventParams.bubbles, eventParams.cancelable, eventParams.detail)
  return customEvent
}
var mediumZoom = function mediumZoom2(selector) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  var Promise2 =
    window.Promise ||
    function Promise3(fn) {
      function noop() {}
      fn(noop, noop)
    }
  var _handleClick = function _handleClick2(event) {
    var target = event.target
    if (target === overlay) {
      close()
      return
    }
    if (images.indexOf(target) === -1) {
      return
    }
    toggle({ target })
  }
  var _handleScroll = function _handleScroll2() {
    if (isAnimating || !active.original) {
      return
    }
    var currentScroll =
      window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    if (Math.abs(scrollTop - currentScroll) > zoomOptions.scrollOffset) {
      setTimeout(close, 150)
    }
  }
  var _handleKeyUp = function _handleKeyUp2(event) {
    var key = event.key || event.keyCode
    if (key === 'Escape' || key === 'Esc' || key === 27) {
      close()
    }
  }
  var update = function update2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
    var newOptions = options2
    if (options2.background) {
      overlay.style.background = options2.background
    }
    if (options2.container && options2.container instanceof Object) {
      newOptions.container = _extends({}, zoomOptions.container, options2.container)
    }
    if (options2.template) {
      var template2 = isNode(options2.template)
        ? options2.template
        : document.querySelector(options2.template)
      newOptions.template = template2
    }
    zoomOptions = _extends({}, zoomOptions, newOptions)
    images.forEach(function (image2) {
      image2.dispatchEvent(
        createCustomEvent('medium-zoom:update', {
          detail: { zoom }
        })
      )
    })
    return zoom
  }
  var clone = function clone2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
    return mediumZoom2(_extends({}, zoomOptions, options2))
  }
  var attach = function attach2() {
    for (var _len = arguments.length, selectors = Array(_len), _key = 0; _key < _len; _key++) {
      selectors[_key] = arguments[_key]
    }
    var newImages = selectors.reduce(function (imagesAccumulator, currentSelector) {
      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector))
    }, [])
    newImages
      .filter(function (newImage) {
        return images.indexOf(newImage) === -1
      })
      .forEach(function (newImage) {
        images.push(newImage)
        newImage.classList.add('medium-zoom-image')
      })
    eventListeners.forEach(function (_ref) {
      var type = _ref.type,
        listener = _ref.listener,
        options2 = _ref.options
      newImages.forEach(function (image2) {
        image2.addEventListener(type, listener, options2)
      })
    })
    return zoom
  }
  var detach = function detach2() {
    for (
      var _len2 = arguments.length, selectors = Array(_len2), _key2 = 0;
      _key2 < _len2;
      _key2++
    ) {
      selectors[_key2] = arguments[_key2]
    }
    if (active.zoomed) {
      close()
    }
    var imagesToDetach =
      selectors.length > 0
        ? selectors.reduce(function (imagesAccumulator, currentSelector) {
            return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector))
          }, [])
        : images
    imagesToDetach.forEach(function (image2) {
      image2.classList.remove('medium-zoom-image')
      image2.dispatchEvent(
        createCustomEvent('medium-zoom:detach', {
          detail: { zoom }
        })
      )
    })
    images = images.filter(function (image2) {
      return imagesToDetach.indexOf(image2) === -1
    })
    return zoom
  }
  var on = function on2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
    images.forEach(function (image2) {
      image2.addEventListener('medium-zoom:' + type, listener, options2)
    })
    eventListeners.push({ type: 'medium-zoom:' + type, listener, options: options2 })
    return zoom
  }
  var off = function off2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
    images.forEach(function (image2) {
      image2.removeEventListener('medium-zoom:' + type, listener, options2)
    })
    eventListeners = eventListeners.filter(function (eventListener) {
      return !(
        eventListener.type === 'medium-zoom:' + type &&
        eventListener.listener.toString() === listener.toString()
      )
    })
    return zoom
  }
  var open = function open2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      target = _ref2.target
    var _animate = function _animate2() {
      var container = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }
      var viewportWidth = void 0
      var viewportHeight = void 0
      if (zoomOptions.container) {
        if (zoomOptions.container instanceof Object) {
          container = _extends({}, container, zoomOptions.container)
          viewportWidth =
            container.width - container.left - container.right - zoomOptions.margin * 2
          viewportHeight =
            container.height - container.top - container.bottom - zoomOptions.margin * 2
        } else {
          var zoomContainer = isNode(zoomOptions.container)
            ? zoomOptions.container
            : document.querySelector(zoomOptions.container)
          var _zoomContainer$getBou = zoomContainer.getBoundingClientRect(),
            _width = _zoomContainer$getBou.width,
            _height = _zoomContainer$getBou.height,
            _left = _zoomContainer$getBou.left,
            _top = _zoomContainer$getBou.top
          container = _extends({}, container, {
            width: _width,
            height: _height,
            left: _left,
            top: _top
          })
        }
      }
      viewportWidth = viewportWidth || container.width - zoomOptions.margin * 2
      viewportHeight = viewportHeight || container.height - zoomOptions.margin * 2
      var zoomTarget = active.zoomedHd || active.original
      var naturalWidth = isSvg(zoomTarget)
        ? viewportWidth
        : zoomTarget.naturalWidth || viewportWidth
      var naturalHeight = isSvg(zoomTarget)
        ? viewportHeight
        : zoomTarget.naturalHeight || viewportHeight
      var _zoomTarget$getBoundi = zoomTarget.getBoundingClientRect(),
        top2 = _zoomTarget$getBoundi.top,
        left = _zoomTarget$getBoundi.left,
        width = _zoomTarget$getBoundi.width,
        height = _zoomTarget$getBoundi.height
      var scaleX = Math.min(Math.max(width, naturalWidth), viewportWidth) / width
      var scaleY = Math.min(Math.max(height, naturalHeight), viewportHeight) / height
      var scale = Math.min(scaleX, scaleY)
      var translateX =
        (-left + (viewportWidth - width) / 2 + zoomOptions.margin + container.left) / scale
      var translateY =
        (-top2 + (viewportHeight - height) / 2 + zoomOptions.margin + container.top) / scale
      var transform =
        'scale(' + scale + ') translate3d(' + translateX + 'px, ' + translateY + 'px, 0)'
      active.zoomed.style.transform = transform
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = transform
      }
    }
    return new Promise2(function (resolve) {
      if (target && images.indexOf(target) === -1) {
        resolve(zoom)
        return
      }
      var _handleOpenEnd = function _handleOpenEnd2() {
        isAnimating = false
        active.zoomed.removeEventListener('transitionend', _handleOpenEnd2)
        active.original.dispatchEvent(
          createCustomEvent('medium-zoom:opened', {
            detail: { zoom }
          })
        )
        resolve(zoom)
      }
      if (active.zoomed) {
        resolve(zoom)
        return
      }
      if (target) {
        active.original = target
      } else if (images.length > 0) {
        var _images = images
        active.original = _images[0]
      } else {
        resolve(zoom)
        return
      }
      active.original.dispatchEvent(
        createCustomEvent('medium-zoom:open', {
          detail: { zoom }
        })
      )
      scrollTop =
        window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
      isAnimating = true
      active.zoomed = cloneTarget(active.original)
      document.body.appendChild(overlay)
      if (zoomOptions.template) {
        var template2 = isNode(zoomOptions.template)
          ? zoomOptions.template
          : document.querySelector(zoomOptions.template)
        active.template = document.createElement('div')
        active.template.appendChild(template2.content.cloneNode(true))
        document.body.appendChild(active.template)
      }
      if (
        active.original.parentElement &&
        active.original.parentElement.tagName === 'PICTURE' &&
        active.original.currentSrc
      ) {
        active.zoomed.src = active.original.currentSrc
      }
      document.body.appendChild(active.zoomed)
      window.requestAnimationFrame(function () {
        document.body.classList.add('medium-zoom--opened')
      })
      active.original.classList.add('medium-zoom-image--hidden')
      active.zoomed.classList.add('medium-zoom-image--opened')
      active.zoomed.addEventListener('click', close)
      active.zoomed.addEventListener('transitionend', _handleOpenEnd)
      if (active.original.getAttribute('data-zoom-src')) {
        active.zoomedHd = active.zoomed.cloneNode()
        active.zoomedHd.removeAttribute('srcset')
        active.zoomedHd.removeAttribute('sizes')
        active.zoomedHd.removeAttribute('loading')
        active.zoomedHd.src = active.zoomed.getAttribute('data-zoom-src')
        active.zoomedHd.onerror = function () {
          clearInterval(getZoomTargetSize)
          console.warn('Unable to reach the zoom image target ' + active.zoomedHd.src)
          active.zoomedHd = null
          _animate()
        }
        var getZoomTargetSize = setInterval(function () {
          if (active.zoomedHd.complete) {
            clearInterval(getZoomTargetSize)
            active.zoomedHd.classList.add('medium-zoom-image--opened')
            active.zoomedHd.addEventListener('click', close)
            document.body.appendChild(active.zoomedHd)
            _animate()
          }
        }, 10)
      } else if (active.original.hasAttribute('srcset')) {
        active.zoomedHd = active.zoomed.cloneNode()
        active.zoomedHd.removeAttribute('sizes')
        active.zoomedHd.removeAttribute('loading')
        var loadEventListener = active.zoomedHd.addEventListener('load', function () {
          active.zoomedHd.removeEventListener('load', loadEventListener)
          active.zoomedHd.classList.add('medium-zoom-image--opened')
          active.zoomedHd.addEventListener('click', close)
          document.body.appendChild(active.zoomedHd)
          _animate()
        })
      } else {
        _animate()
      }
    })
  }
  var close = function close2() {
    return new Promise2(function (resolve) {
      if (isAnimating || !active.original) {
        resolve(zoom)
        return
      }
      var _handleCloseEnd = function _handleCloseEnd2() {
        active.original.classList.remove('medium-zoom-image--hidden')
        document.body.removeChild(active.zoomed)
        if (active.zoomedHd) {
          document.body.removeChild(active.zoomedHd)
        }
        document.body.removeChild(overlay)
        active.zoomed.classList.remove('medium-zoom-image--opened')
        if (active.template) {
          document.body.removeChild(active.template)
        }
        isAnimating = false
        active.zoomed.removeEventListener('transitionend', _handleCloseEnd2)
        active.original.dispatchEvent(
          createCustomEvent('medium-zoom:closed', {
            detail: { zoom }
          })
        )
        active.original = null
        active.zoomed = null
        active.zoomedHd = null
        active.template = null
        resolve(zoom)
      }
      isAnimating = true
      document.body.classList.remove('medium-zoom--opened')
      active.zoomed.style.transform = ''
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = ''
      }
      if (active.template) {
        active.template.style.transition = 'opacity 150ms'
        active.template.style.opacity = 0
      }
      active.original.dispatchEvent(
        createCustomEvent('medium-zoom:close', {
          detail: { zoom }
        })
      )
      active.zoomed.addEventListener('transitionend', _handleCloseEnd)
    })
  }
  var toggle = function toggle2() {
    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      target = _ref3.target
    if (active.original) {
      return close()
    }
    return open({ target })
  }
  var getOptions = function getOptions2() {
    return zoomOptions
  }
  var getImages = function getImages2() {
    return images
  }
  var getZoomedImage = function getZoomedImage2() {
    return active.original
  }
  var images = []
  var eventListeners = []
  var isAnimating = false
  var scrollTop = 0
  var zoomOptions = options
  var active = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  }
  if (Object.prototype.toString.call(selector) === '[object Object]') {
    zoomOptions = selector
  } else if (selector || typeof selector === 'string') {
    attach(selector)
  }
  zoomOptions = _extends(
    {
      margin: 0,
      background: '#fff',
      scrollOffset: 40,
      container: null,
      template: null
    },
    zoomOptions
  )
  var overlay = createOverlay(zoomOptions.background)
  document.addEventListener('click', _handleClick)
  document.addEventListener('keyup', _handleKeyUp)
  document.addEventListener('scroll', _handleScroll)
  window.addEventListener('resize', close)
  var zoom = {
    open,
    close,
    toggle,
    update,
    clone,
    attach,
    detach,
    on,
    off,
    getOptions,
    getImages,
    getZoomedImage
  }
  return zoom
}
function styleInject(css2, ref2) {
  if (ref2 === void 0) ref2 = {}
  var insertAt = ref2.insertAt
  if (typeof document === 'undefined') {
    return
  }
  var head = document.head || document.getElementsByTagName('head')[0]
  var style = document.createElement('style')
  style.type = 'text/css'
  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild)
    } else {
      head.appendChild(style)
    }
  } else {
    head.appendChild(style)
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2
  } else {
    style.appendChild(document.createTextNode(css2))
  }
}
var css$2 =
  '.medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}'
styleInject(css$2)
async function copy2Clipboard(text2) {
  if (typeof text2 !== 'string') return
  if (window.isSecureContext && navigator.clipboard) {
    return await navigator.clipboard.writeText(text2)
  } else {
    const textarea = document.createElement('textarea')
    let successed = false
    textarea.value = text2
    textarea.style.position = 'fixed'
    textarea.style.opacity = 0
    textarea.style.zIndex = '-10000'
    textarea.style.top = '-10000'
    document.body.appendChild(textarea)
    textarea.select()
    successed = document.execCommand('copy')
    document.body.removeChild(textarea)
    if (successed) {
      return
    }
    throw new Error('Failed to copy content via "execCommand"!')
  }
}
const decodeCache = {}
function getDecodeCache(exclude) {
  let cache2 = decodeCache[exclude]
  if (cache2) {
    return cache2
  }
  cache2 = decodeCache[exclude] = []
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i)
    cache2.push(ch)
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i)
    cache2[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2)
  }
  return cache2
}
function decode$1(string2, exclude) {
  if (typeof exclude !== 'string') {
    exclude = decode$1.defaultChars
  }
  const cache2 = getDecodeCache(exclude)
  return string2.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    let result = ''
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16)
      if (b1 < 128) {
        result += cache2[b1]
        continue
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)
        if ((b2 & 192) === 128) {
          const chr = ((b1 << 6) & 1984) | (b2 & 63)
          if (chr < 128) {
            result += '��'
          } else {
            result += String.fromCharCode(chr)
          }
          i += 3
          continue
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16)
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = ((b1 << 12) & 61440) | ((b2 << 6) & 4032) | (b3 & 63)
          if (chr < 2048 || (chr >= 55296 && chr <= 57343)) {
            result += '���'
          } else {
            result += String.fromCharCode(chr)
          }
          i += 6
          continue
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16)
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16)
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = ((b1 << 18) & 1835008) | ((b2 << 12) & 258048) | ((b3 << 6) & 4032) | (b4 & 63)
          if (chr < 65536 || chr > 1114111) {
            result += '����'
          } else {
            chr -= 65536
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023))
          }
          i += 9
          continue
        }
      }
      result += '�'
    }
    return result
  })
}
decode$1.defaultChars = ';/?:@&=+$,#'
decode$1.componentChars = ''
const encodeCache = {}
function getEncodeCache(exclude) {
  let cache2 = encodeCache[exclude]
  if (cache2) {
    return cache2
  }
  cache2 = encodeCache[exclude] = []
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i)
    if (/^[0-9a-z]$/i.test(ch)) {
      cache2.push(ch)
    } else {
      cache2.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2))
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache2[exclude.charCodeAt(i)] = exclude[i]
  }
  return cache2
}
function encode$1(string2, exclude, keepEscaped) {
  if (typeof exclude !== 'string') {
    keepEscaped = exclude
    exclude = encode$1.defaultChars
  }
  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true
  }
  const cache2 = getEncodeCache(exclude)
  let result = ''
  for (let i = 0, l = string2.length; i < l; i++) {
    const code = string2.charCodeAt(i)
    if (keepEscaped && code === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3)
        i += 2
        continue
      }
    }
    if (code < 128) {
      result += cache2[code]
      continue
    }
    if (code >= 55296 && code <= 57343) {
      if (code >= 55296 && code <= 56319 && i + 1 < l) {
        const nextCode = string2.charCodeAt(i + 1)
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1])
          i++
          continue
        }
      }
      result += '%EF%BF%BD'
      continue
    }
    result += encodeURIComponent(string2[i])
  }
  return result
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#"
encode$1.componentChars = "-_.!~*'()"
function format(url) {
  let result = ''
  result += url.protocol || ''
  result += url.slashes ? '//' : ''
  result += url.auth ? url.auth + '@' : ''
  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    result += '[' + url.hostname + ']'
  } else {
    result += url.hostname || ''
  }
  result += url.port ? ':' + url.port : ''
  result += url.pathname || ''
  result += url.search || ''
  result += url.hash || ''
  return result
}
function Url() {
  this.protocol = null
  this.slashes = null
  this.auth = null
  this.port = null
  this.hostname = null
  this.hash = null
  this.search = null
  this.pathname = null
}
const protocolPattern = /^([a-z0-9.+-]+:)/i
const portPattern = /:[0-9]*$/
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
const delims = ['<', '>', '"', '`', ' ', '\r', '\n', '	']
const unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims)
const autoEscape = ["'"].concat(unwise)
const nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape)
const hostEndingChars = ['/', '?', '#']
const hostnameMaxLen = 255
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
const hostlessProtocol = {
  javascript: true,
  'javascript:': true
}
const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
}
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) return url
  const u2 = new Url()
  u2.parse(url, slashesDenoteHost)
  return u2
}
Url.prototype.parse = function (url, slashesDenoteHost) {
  let lowerProto, hec, slashes
  let rest = url
  rest = rest.trim()
  if (!slashesDenoteHost && url.split('#').length === 1) {
    const simplePath = simplePathPattern.exec(rest)
    if (simplePath) {
      this.pathname = simplePath[1]
      if (simplePath[2]) {
        this.search = simplePath[2]
      }
      return this
    }
  }
  let proto = protocolPattern.exec(rest)
  if (proto) {
    proto = proto[0]
    lowerProto = proto.toLowerCase()
    this.protocol = proto
    rest = rest.substr(proto.length)
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//'
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2)
      this.slashes = true
    }
  }
  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
    let hostEnd = -1
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i])
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec
      }
    }
    let auth, atSign
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf('@')
    } else {
      atSign = rest.lastIndexOf('@', hostEnd)
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign)
      rest = rest.slice(atSign + 1)
      this.auth = auth
    }
    hostEnd = -1
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i])
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length
    }
    if (rest[hostEnd - 1] === ':') {
      hostEnd--
    }
    const host = rest.slice(0, hostEnd)
    rest = rest.slice(hostEnd)
    this.parseHost(host)
    this.hostname = this.hostname || ''
    const ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./)
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i]
        if (!part) {
          continue
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = ''
          for (let j = 0, k2 = part.length; j < k2; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += 'x'
            } else {
              newpart += part[j]
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i)
            const notHost = hostparts.slice(i + 1)
            const bit = part.match(hostnamePartStart)
            if (bit) {
              validParts.push(bit[1])
              notHost.unshift(bit[2])
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest
            }
            this.hostname = validParts.join('.')
            break
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = ''
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2)
    }
  }
  const hash2 = rest.indexOf('#')
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2)
    rest = rest.slice(0, hash2)
  }
  const qm = rest.indexOf('?')
  if (qm !== -1) {
    this.search = rest.substr(qm)
    rest = rest.slice(0, qm)
  }
  if (rest) {
    this.pathname = rest
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = ''
  }
  return this
}
Url.prototype.parseHost = function (host) {
  let port = portPattern.exec(host)
  if (port) {
    port = port[0]
    if (port !== ':') {
      this.port = port.substr(1)
    }
    host = host.substr(0, host.length - port.length)
  }
  if (host) {
    this.hostname = host
  }
}
const mdurl = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      decode: decode$1,
      encode: encode$1,
      format,
      parse: urlParse
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const Any =
  /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
const Cc = /[\0-\x1F\x7F-\x9F]/
const regex$1 =
  /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
const P =
  /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
const regex =
  /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/
const Z = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
const ucmicro = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      Any,
      Cc,
      Cf: regex$1,
      P,
      S: regex,
      Z
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c) => c.charCodeAt(0))
)
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c) => c.charCodeAt(0))
)
var _a$1
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
])
const fromCodePoint$2 =
  // eslint-disable-next-line node/no-unsupported-features/es-builtins
  (_a$1 = String.fromCodePoint) !== null && _a$1 !== void 0
    ? _a$1
    : function (codePoint) {
        let output = ''
        if (codePoint > 65535) {
          codePoint -= 65536
          output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296)
          codePoint = 56320 | (codePoint & 1023)
        }
        output += String.fromCharCode(codePoint)
        return output
      }
function replaceCodePoint(codePoint) {
  var _a2
  if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
    return 65533
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint
}
var CharCodes
;(function (CharCodes2) {
  CharCodes2[(CharCodes2['NUM'] = 35)] = 'NUM'
  CharCodes2[(CharCodes2['SEMI'] = 59)] = 'SEMI'
  CharCodes2[(CharCodes2['EQUALS'] = 61)] = 'EQUALS'
  CharCodes2[(CharCodes2['ZERO'] = 48)] = 'ZERO'
  CharCodes2[(CharCodes2['NINE'] = 57)] = 'NINE'
  CharCodes2[(CharCodes2['LOWER_A'] = 97)] = 'LOWER_A'
  CharCodes2[(CharCodes2['LOWER_F'] = 102)] = 'LOWER_F'
  CharCodes2[(CharCodes2['LOWER_X'] = 120)] = 'LOWER_X'
  CharCodes2[(CharCodes2['LOWER_Z'] = 122)] = 'LOWER_Z'
  CharCodes2[(CharCodes2['UPPER_A'] = 65)] = 'UPPER_A'
  CharCodes2[(CharCodes2['UPPER_F'] = 70)] = 'UPPER_F'
  CharCodes2[(CharCodes2['UPPER_Z'] = 90)] = 'UPPER_Z'
})(CharCodes || (CharCodes = {}))
const TO_LOWER_BIT = 32
var BinTrieFlags
;(function (BinTrieFlags2) {
  BinTrieFlags2[(BinTrieFlags2['VALUE_LENGTH'] = 49152)] = 'VALUE_LENGTH'
  BinTrieFlags2[(BinTrieFlags2['BRANCH_LENGTH'] = 16256)] = 'BRANCH_LENGTH'
  BinTrieFlags2[(BinTrieFlags2['JUMP_TABLE'] = 127)] = 'JUMP_TABLE'
})(BinTrieFlags || (BinTrieFlags = {}))
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE
}
function isHexadecimalCharacter(code) {
  return (
    (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
    (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
  )
}
function isAsciiAlphaNumeric(code) {
  return (
    (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
    (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
    isNumber(code)
  )
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code)
}
var EntityDecoderState
;(function (EntityDecoderState2) {
  EntityDecoderState2[(EntityDecoderState2['EntityStart'] = 0)] = 'EntityStart'
  EntityDecoderState2[(EntityDecoderState2['NumericStart'] = 1)] = 'NumericStart'
  EntityDecoderState2[(EntityDecoderState2['NumericDecimal'] = 2)] = 'NumericDecimal'
  EntityDecoderState2[(EntityDecoderState2['NumericHex'] = 3)] = 'NumericHex'
  EntityDecoderState2[(EntityDecoderState2['NamedEntity'] = 4)] = 'NamedEntity'
})(EntityDecoderState || (EntityDecoderState = {}))
var DecodingMode
;(function (DecodingMode2) {
  DecodingMode2[(DecodingMode2['Legacy'] = 0)] = 'Legacy'
  DecodingMode2[(DecodingMode2['Strict'] = 1)] = 'Strict'
  DecodingMode2[(DecodingMode2['Attribute'] = 2)] = 'Attribute'
})(DecodingMode || (DecodingMode = {}))
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree
    this.emitCodePoint = emitCodePoint
    this.errors = errors2
    this.state = EntityDecoderState.EntityStart
    this.consumed = 1
    this.result = 0
    this.treeIndex = 0
    this.excess = 1
    this.decodeMode = DecodingMode.Strict
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode
    this.state = EntityDecoderState.EntityStart
    this.result = 0
    this.treeIndex = 0
    this.excess = 1
    this.consumed = 1
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart
          this.consumed += 1
          return this.stateNumericStart(str, offset + 1)
        }
        this.state = EntityDecoderState.NamedEntity
        return this.stateNamedEntity(str, offset)
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset)
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset)
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset)
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset)
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex
      this.consumed += 1
      return this.stateNumericHex(str, offset + 1)
    }
    this.state = EntityDecoderState.NumericDecimal
    return this.stateNumericDecimal(str, offset)
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start
      this.result =
        this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2)
      this.consumed += digitCount
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset
    while (offset < str.length) {
      const char = str.charCodeAt(offset)
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1
      } else {
        this.addToNumericResult(str, startIdx, offset, 16)
        return this.emitNumericEntity(char, 3)
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16)
    return -1
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset
    while (offset < str.length) {
      const char = str.charCodeAt(offset)
      if (isNumber(char)) {
        offset += 1
      } else {
        this.addToNumericResult(str, startIdx, offset, 10)
        return this.emitNumericEntity(char, 2)
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10)
    return -1
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2
    if (this.consumed <= expectedLength) {
      ;(_a2 = this.errors) === null || _a2 === void 0
        ? void 0
        : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed)
      return 0
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed)
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference()
      }
      this.errors.validateNumericCharacterReference(this.result)
    }
    return this.consumed
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this
    let current = decodeTree[this.treeIndex]
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset)
      this.treeIndex = determineBranch(
        decodeTree,
        current,
        this.treeIndex + Math.max(1, valueLength),
        char
      )
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
          (this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
            (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)))
          ? 0
          : this.emitNotTerminatedNamedEntity()
      }
      current = decodeTree[this.treeIndex]
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess)
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex
          this.consumed += this.excess
          this.excess = 0
        }
      }
    }
    return -1
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2
    const { result, decodeTree } = this
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14
    this.emitNamedEntityData(result, valueLength, this.consumed)
    ;(_a2 = this.errors) === null || _a2 === void 0
      ? void 0
      : _a2.missingSemicolonAfterCharacterReference()
    return this.consumed
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this
    this.emitCodePoint(
      valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1],
      consumed
    )
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed)
    }
    return consumed
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 &&
          (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex)
          ? this.emitNotTerminatedNamedEntity()
          : 0
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2)
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3)
      }
      case EntityDecoderState.NumericStart: {
        ;(_a2 = this.errors) === null || _a2 === void 0
          ? void 0
          : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed)
        return 0
      }
      case EntityDecoderState.EntityStart: {
        return 0
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = ''
  const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint$2(str)))
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0
    let offset = 0
    while ((offset = str.indexOf('&', offset)) >= 0) {
      ret += str.slice(lastIndex, offset)
      decoder.startEntity(decodeMode)
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      )
      if (len < 0) {
        lastIndex = offset + decoder.end()
        break
      }
      lastIndex = offset + len
      offset = len === 0 ? lastIndex + 1 : lastIndex
    }
    const result = ret + str.slice(lastIndex)
    ret = ''
    return result
  }
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1
  }
  if (jumpOffset) {
    const value = char - jumpOffset
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1
  }
  let lo = nodeIdx
  let hi = lo + branchCount - 1
  while (lo <= hi) {
    const mid = (lo + hi) >>> 1
    const midVal = decodeTree[mid]
    if (midVal < char) {
      lo = mid + 1
    } else if (midVal > char) {
      hi = mid - 1
    } else {
      return decodeTree[mid + branchCount]
    }
  }
  return -1
}
const htmlDecoder = getDecoder(htmlDecodeTree)
getDecoder(xmlDecodeTree)
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode)
}
function _class$1(obj) {
  return Object.prototype.toString.call(obj)
}
function isString$1(obj) {
  return _class$1(obj) === '[object String]'
}
const _hasOwnProperty = Object.prototype.hasOwnProperty
function has(object, key) {
  return _hasOwnProperty.call(object, key)
}
function assign$1(obj) {
  const sources = Array.prototype.slice.call(arguments, 1)
  sources.forEach(function (source) {
    if (!source) {
      return
    }
    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object')
    }
    Object.keys(source).forEach(function (key) {
      obj[key] = source[key]
    })
  })
  return obj
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false
  }
  if (c >= 64976 && c <= 65007) {
    return false
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false
  }
  if (c >= 0 && c <= 8) {
    return false
  }
  if (c === 11) {
    return false
  }
  if (c >= 14 && c <= 31) {
    return false
  }
  if (c >= 127 && c <= 159) {
    return false
  }
  if (c > 1114111) {
    return false
  }
  return true
}
function fromCodePoint$1(c) {
  if (c > 65535) {
    c -= 65536
    const surrogate1 = 55296 + (c >> 10)
    const surrogate2 = 56320 + (c & 1023)
    return String.fromCharCode(surrogate1, surrogate2)
  }
  return String.fromCharCode(c)
}
const UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g
const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi
const UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')
const DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i
function replaceEntityPattern(match2, name2) {
  if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    const code =
      name2[1].toLowerCase() === 'x' ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10)
    if (isValidEntityCode(code)) {
      return fromCodePoint$1(code)
    }
    return match2
  }
  const decoded = decodeHTML(match2)
  if (decoded !== match2) {
    return decoded
  }
  return match2
}
function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str
  }
  return str.replace(UNESCAPE_MD_RE, '$1')
}
function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str
  }
  return str.replace(UNESCAPE_ALL_RE, function (match2, escaped, entity2) {
    if (escaped) {
      return escaped
    }
    return replaceEntityPattern(match2, entity2)
  })
}
const HTML_ESCAPE_TEST_RE = /[&<>"]/
const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g
const HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
}
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch]
}
function escapeHtml$1(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)
  }
  return str
}
const REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g
function escapeRE$1(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&')
}
function isSpace$1(code) {
  switch (code) {
    case 9:
    case 32:
      return true
  }
  return false
}
function isWhiteSpace(code) {
  if (code >= 8192 && code <= 8202) {
    return true
  }
  switch (code) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true
  }
  return false
}
function isPunctChar(ch) {
  return P.test(ch) || regex.test(ch)
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true
    default:
      return false
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, ' ')
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß')
  }
  return str.toLowerCase().toUpperCase()
}
const lib$2 = { mdurl, ucmicro }
const utils = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      arrayReplaceAt,
      assign: assign$1,
      escapeHtml: escapeHtml$1,
      escapeRE: escapeRE$1,
      fromCodePoint: fromCodePoint$1,
      has,
      isMdAsciiPunct,
      isPunctChar,
      isSpace: isSpace$1,
      isString: isString$1,
      isValidEntityCode,
      isWhiteSpace,
      lib: lib$2,
      normalizeReference,
      unescapeAll,
      unescapeMd
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function parseLinkLabel$1(state, start, disableNested) {
  let level, found, marker, prevPos
  const max = state.posMax
  const oldPos = state.pos
  state.pos = start + 1
  level = 1
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos)
    if (marker === 93) {
      level--
      if (level === 0) {
        found = true
        break
      }
    }
    prevPos = state.pos
    state.md.inline.skipToken(state)
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++
      } else if (disableNested) {
        state.pos = oldPos
        return -1
      }
    }
  }
  let labelEnd = -1
  if (found) {
    labelEnd = state.pos
  }
  state.pos = oldPos
  return labelEnd
}
function parseLinkDestination(str, start, max) {
  let code
  let pos = start
  const result = {
    ok: false,
    pos: 0,
    str: ''
  }
  if (str.charCodeAt(pos) === 60) {
    pos++
    while (pos < max) {
      code = str.charCodeAt(pos)
      if (code === 10) {
        return result
      }
      if (code === 60) {
        return result
      }
      if (code === 62) {
        result.pos = pos + 1
        result.str = unescapeAll(str.slice(start + 1, pos))
        result.ok = true
        return result
      }
      if (code === 92 && pos + 1 < max) {
        pos += 2
        continue
      }
      pos++
    }
    return result
  }
  let level = 0
  while (pos < max) {
    code = str.charCodeAt(pos)
    if (code === 32) {
      break
    }
    if (code < 32 || code === 127) {
      break
    }
    if (code === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break
      }
      pos += 2
      continue
    }
    if (code === 40) {
      level++
      if (level > 32) {
        return result
      }
    }
    if (code === 41) {
      if (level === 0) {
        break
      }
      level--
    }
    pos++
  }
  if (start === pos) {
    return result
  }
  if (level !== 0) {
    return result
  }
  result.str = unescapeAll(str.slice(start, pos))
  result.pos = pos
  result.ok = true
  return result
}
function parseLinkTitle$1(str, start, max, prev_state) {
  let code
  let pos = start
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: '',
    // expected closing marker character code
    marker: 0
  }
  if (prev_state) {
    state.str = prev_state.str
    state.marker = prev_state.marker
  } else {
    if (pos >= max) {
      return state
    }
    let marker = str.charCodeAt(pos)
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state
    }
    start++
    pos++
    if (marker === 40) {
      marker = 41
    }
    state.marker = marker
  }
  while (pos < max) {
    code = str.charCodeAt(pos)
    if (code === state.marker) {
      state.pos = pos + 1
      state.str += unescapeAll(str.slice(start, pos))
      state.ok = true
      return state
    } else if (code === 40 && state.marker === 41) {
      return state
    } else if (code === 92 && pos + 1 < max) {
      pos++
    }
    pos++
  }
  state.can_continue = true
  state.str += unescapeAll(str.slice(start, pos))
  return state
}
const helpers = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      parseLinkDestination,
      parseLinkLabel: parseLinkLabel$1,
      parseLinkTitle: parseLinkTitle$1
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const default_rules = {}
default_rules.code_inline = function (tokens, idx, options, env, slf) {
  const token = tokens[idx]
  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml$1(token.content) + '</code>'
}
default_rules.code_block = function (tokens, idx, options, env, slf) {
  const token = tokens[idx]
  return (
    '<pre' +
    slf.renderAttrs(token) +
    '><code>' +
    escapeHtml$1(tokens[idx].content) +
    '</code></pre>\n'
  )
}
default_rules.fence = function (tokens, idx, options, env, slf) {
  const token = tokens[idx]
  const info = token.info ? unescapeAll(token.info).trim() : ''
  let langName = ''
  let langAttrs = ''
  if (info) {
    const arr = info.split(/(\s+)/g)
    langName = arr[0]
    langAttrs = arr.slice(2).join('')
  }
  let highlighted
  if (options.highlight) {
    highlighted =
      options.highlight(token.content, langName, langAttrs) || escapeHtml$1(token.content)
  } else {
    highlighted = escapeHtml$1(token.content)
  }
  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n'
  }
  if (info) {
    const i = token.attrIndex('class')
    const tmpAttrs = token.attrs ? token.attrs.slice() : []
    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName])
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice()
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName
    }
    const tmpToken = {
      attrs: tmpAttrs
    }
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`
}
default_rules.image = function (tokens, idx, options, env, slf) {
  const token = tokens[idx]
  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env)
  return slf.renderToken(tokens, idx, options)
}
default_rules.hardbreak = function (tokens, idx, options) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n'
}
default_rules.softbreak = function (tokens, idx, options) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n'
}
default_rules.text = function (tokens, idx) {
  return escapeHtml$1(tokens[idx].content)
}
default_rules.html_block = function (tokens, idx) {
  return tokens[idx].content
}
default_rules.html_inline = function (tokens, idx) {
  return tokens[idx].content
}
function Renderer() {
  this.rules = assign$1({}, default_rules)
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result
  if (!token.attrs) {
    return ''
  }
  result = ''
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml$1(token.attrs[i][0]) + '="' + escapeHtml$1(token.attrs[i][1]) + '"'
  }
  return result
}
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx]
  let result = ''
  if (token.hidden) {
    return ''
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n'
  }
  result += (token.nesting === -1 ? '</' : '<') + token.tag
  result += this.renderAttrs(token)
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /'
  }
  let needLf = false
  if (token.block) {
    needLf = true
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1]
        if (nextToken.type === 'inline' || nextToken.hidden) {
          needLf = false
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false
        }
      }
    }
  }
  result += needLf ? '>\n' : '>'
  return result
}
Renderer.prototype.renderInline = function (tokens, options, env) {
  let result = ''
  const rules = this.rules
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type
    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this)
    } else {
      result += this.renderToken(tokens, i, options)
    }
  }
  return result
}
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  let result = ''
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case 'text':
        result += tokens[i].content
        break
      case 'image':
        result += this.renderInlineAsText(tokens[i].children, options, env)
        break
      case 'html_inline':
      case 'html_block':
        result += tokens[i].content
        break
      case 'softbreak':
      case 'hardbreak':
        result += '\n'
        break
    }
  }
  return result
}
Renderer.prototype.render = function (tokens, options, env) {
  let result = ''
  const rules = this.rules
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type
    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env)
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this)
    } else {
      result += this.renderToken(tokens, i, options, env)
    }
  }
  return result
}
function Ruler() {
  this.__rules__ = []
  this.__cache__ = null
}
Ruler.prototype.__find__ = function (name2) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i
    }
  }
  return -1
}
Ruler.prototype.__compile__ = function () {
  const self2 = this
  const chains = ['']
  self2.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return
    }
    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName)
      }
    })
  })
  self2.__cache__ = {}
  chains.forEach(function (chain) {
    self2.__cache__[chain] = []
    self2.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return
      }
      self2.__cache__[chain].push(rule.fn)
    })
  })
}
Ruler.prototype.at = function (name2, fn, options) {
  const index2 = this.__find__(name2)
  const opt = options || {}
  if (index2 === -1) {
    throw new Error('Parser rule not found: ' + name2)
  }
  this.__rules__[index2].fn = fn
  this.__rules__[index2].alt = opt.alt || []
  this.__cache__ = null
}
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  const index2 = this.__find__(beforeName)
  const opt = options || {}
  if (index2 === -1) {
    throw new Error('Parser rule not found: ' + beforeName)
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  })
  this.__cache__ = null
}
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  const index2 = this.__find__(afterName)
  const opt = options || {}
  if (index2 === -1) {
    throw new Error('Parser rule not found: ' + afterName)
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  })
  this.__cache__ = null
}
Ruler.prototype.push = function (ruleName, fn, options) {
  const opt = options || {}
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  })
  this.__cache__ = null
}
Ruler.prototype.enable = function (list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2]
  }
  const result = []
  list2.forEach(function (name2) {
    const idx = this.__find__(name2)
    if (idx < 0) {
      if (ignoreInvalid) {
        return
      }
      throw new Error('Rules manager: invalid rule name ' + name2)
    }
    this.__rules__[idx].enabled = true
    result.push(name2)
  }, this)
  this.__cache__ = null
  return result
}
Ruler.prototype.enableOnly = function (list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2]
  }
  this.__rules__.forEach(function (rule) {
    rule.enabled = false
  })
  this.enable(list2, ignoreInvalid)
}
Ruler.prototype.disable = function (list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2]
  }
  const result = []
  list2.forEach(function (name2) {
    const idx = this.__find__(name2)
    if (idx < 0) {
      if (ignoreInvalid) {
        return
      }
      throw new Error('Rules manager: invalid rule name ' + name2)
    }
    this.__rules__[idx].enabled = false
    result.push(name2)
  }, this)
  this.__cache__ = null
  return result
}
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__()
  }
  return this.__cache__[chainName] || []
}
function Token(type, tag, nesting) {
  this.type = type
  this.tag = tag
  this.attrs = null
  this.map = null
  this.nesting = nesting
  this.level = 0
  this.children = null
  this.content = ''
  this.markup = ''
  this.info = ''
  this.meta = null
  this.block = false
  this.hidden = false
}
Token.prototype.attrIndex = function attrIndex(name2) {
  if (!this.attrs) {
    return -1
  }
  const attrs = this.attrs
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i
    }
  }
  return -1
}
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData)
  } else {
    this.attrs = [attrData]
  }
}
Token.prototype.attrSet = function attrSet(name2, value) {
  const idx = this.attrIndex(name2)
  const attrData = [name2, value]
  if (idx < 0) {
    this.attrPush(attrData)
  } else {
    this.attrs[idx] = attrData
  }
}
Token.prototype.attrGet = function attrGet(name2) {
  const idx = this.attrIndex(name2)
  let value = null
  if (idx >= 0) {
    value = this.attrs[idx][1]
  }
  return value
}
Token.prototype.attrJoin = function attrJoin(name2, value) {
  const idx = this.attrIndex(name2)
  if (idx < 0) {
    this.attrPush([name2, value])
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value
  }
}
function StateCore(src, md, env) {
  this.src = src
  this.env = env
  this.tokens = []
  this.inlineMode = false
  this.md = md
}
StateCore.prototype.Token = Token
const NEWLINES_RE = /\r\n?|\n/g
const NULL_RE = /\0/g
function normalize(state) {
  let str
  str = state.src.replace(NEWLINES_RE, '\n')
  str = str.replace(NULL_RE, '�')
  state.src = str
}
function block(state) {
  let token
  if (state.inlineMode) {
    token = new state.Token('inline', '', 0)
    token.content = state.src
    token.map = [0, 1]
    token.children = []
    state.tokens.push(token)
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens)
  }
}
function inline(state) {
  const tokens = state.tokens
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i]
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children)
    }
  }
}
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str)
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str)
}
function linkify$1(state) {
  const blockTokens = state.tokens
  if (!state.md.options.linkify) {
    return
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue
    }
    let tokens = blockTokens[j].children
    let htmlLinkLevel = 0
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i]
      if (currentToken.type === 'link_close') {
        i--
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--
        }
        continue
      }
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++
        }
      }
      if (htmlLinkLevel > 0) {
        continue
      }
      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content
        let links = state.md.linkify.match(text2)
        const nodes = []
        let level = currentToken.level
        let lastPos = 0
        if (
          links.length > 0 &&
          links[0].index === 0 &&
          i > 0 &&
          tokens[i - 1].type === 'text_special'
        ) {
          links = links.slice(1)
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url
          const fullUrl = state.md.normalizeLink(url)
          if (!state.md.validateLink(fullUrl)) {
            continue
          }
          let urlText = links[ln].text
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '')
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '')
          } else {
            urlText = state.md.normalizeLinkText(urlText)
          }
          const pos = links[ln].index
          if (pos > lastPos) {
            const token = new state.Token('text', '', 0)
            token.content = text2.slice(lastPos, pos)
            token.level = level
            nodes.push(token)
          }
          const token_o = new state.Token('link_open', 'a', 1)
          token_o.attrs = [['href', fullUrl]]
          token_o.level = level++
          token_o.markup = 'linkify'
          token_o.info = 'auto'
          nodes.push(token_o)
          const token_t = new state.Token('text', '', 0)
          token_t.content = urlText
          token_t.level = level
          nodes.push(token_t)
          const token_c = new state.Token('link_close', 'a', -1)
          token_c.level = --level
          token_c.markup = 'linkify'
          token_c.info = 'auto'
          nodes.push(token_c)
          lastPos = links[ln].lastIndex
        }
        if (lastPos < text2.length) {
          const token = new state.Token('text', '', 0)
          token.content = text2.slice(lastPos)
          token.level = level
          nodes.push(token)
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes)
      }
    }
  }
}
const RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/
const SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i
const SCOPED_ABBR_RE = /\((c|tm|r)\)/gi
const SCOPED_ABBR = {
  c: '©',
  r: '®',
  tm: '™'
}
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()]
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i]
    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn)
    }
    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--
    }
    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i]
    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content
          .replace(/\+-/g, '±')
          .replace(/\.{2,}/g, '…')
          .replace(/([?!])…/g, '$1..')
          .replace(/([?!]){4,}/g, '$1$1$1')
          .replace(/,{2,}/g, ',')
          .replace(/(^|[^-])---(?=[^-]|$)/gm, '$1—')
          .replace(/(^|\s)--(?=\s|$)/gm, '$1–')
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/gm, '$1–')
      }
    }
    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--
    }
    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++
    }
  }
}
function replace$1(state) {
  let blkIdx
  if (!state.md.options.typographer) {
    return
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline') {
      continue
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children)
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children)
    }
  }
}
const QUOTE_TEST_RE = /['"]/
const QUOTE_RE = /['"]/g
const APOSTROPHE = '’'
function replaceAt(str, index2, ch) {
  return str.slice(0, index2) + ch + str.slice(index2 + 1)
}
function process_inlines(tokens, state) {
  let j
  const stack = []
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]
    const thisLevel = tokens[i].level
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break
      }
    }
    stack.length = j + 1
    if (token.type !== 'text') {
      continue
    }
    let text2 = token.content
    let pos = 0
    let max = text2.length
    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos
      const t2 = QUOTE_RE.exec(text2)
      if (!t2) {
        break
      }
      let canOpen = true
      let canClose = true
      pos = t2.index + 1
      const isSingle = t2[0] === "'"
      let lastChar = 32
      if (t2.index - 1 >= 0) {
        lastChar = text2.charCodeAt(t2.index - 1)
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break
          if (!tokens[j].content) continue
          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1)
          break
        }
      }
      let nextChar = 32
      if (pos < max) {
        nextChar = text2.charCodeAt(pos)
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break
          if (!tokens[j].content) continue
          nextChar = tokens[j].content.charCodeAt(0)
          break
        }
      }
      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))
      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))
      const isLastWhiteSpace = isWhiteSpace(lastChar)
      const isNextWhiteSpace = isWhiteSpace(nextChar)
      if (isNextWhiteSpace) {
        canOpen = false
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false
        }
      }
      if (isLastWhiteSpace) {
        canClose = false
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false
        }
      }
      if (nextChar === 34 && t2[0] === '"') {
        if (lastChar >= 48 && lastChar <= 57) {
          canClose = canOpen = false
        }
      }
      if (canOpen && canClose) {
        canOpen = isLastPunctChar
        canClose = isNextPunctChar
      }
      if (!canOpen && !canClose) {
        if (isSingle) {
          token.content = replaceAt(token.content, t2.index, APOSTROPHE)
        }
        continue
      }
      if (canClose) {
        for (j = stack.length - 1; j >= 0; j--) {
          let item = stack[j]
          if (stack[j].level < thisLevel) {
            break
          }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j]
            let openQuote
            let closeQuote
            if (isSingle) {
              openQuote = state.md.options.quotes[2]
              closeQuote = state.md.options.quotes[3]
            } else {
              openQuote = state.md.options.quotes[0]
              closeQuote = state.md.options.quotes[1]
            }
            token.content = replaceAt(token.content, t2.index, closeQuote)
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote)
            pos += closeQuote.length - 1
            if (item.token === i) {
              pos += openQuote.length - 1
            }
            text2 = token.content
            max = text2.length
            stack.length = j
            continue OUTER
          }
        }
      }
      if (canOpen) {
        stack.push({
          token: i,
          pos: t2.index,
          single: isSingle,
          level: thisLevel
        })
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t2.index, APOSTROPHE)
      }
    }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (
      state.tokens[blkIdx].type !== 'inline' ||
      !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)
    ) {
      continue
    }
    process_inlines(state.tokens[blkIdx].children, state)
  }
}
function text_join(state) {
  let curr, last
  const blockTokens = state.tokens
  const l = blockTokens.length
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== 'inline') continue
    const tokens = blockTokens[j].children
    const max = tokens.length
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === 'text_special') {
        tokens[curr].type = 'text'
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr]
        }
        last++
      }
    }
    if (curr !== last) {
      tokens.length = last
    }
  }
}
const _rules$2 = [
  ['normalize', normalize],
  ['block', block],
  ['inline', inline],
  ['linkify', linkify$1],
  ['replacements', replace$1],
  ['smartquotes', smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ['text_join', text_join]
]
function Core() {
  this.ruler = new Ruler()
  for (let i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1])
  }
}
Core.prototype.process = function (state) {
  const rules = this.ruler.getRules('')
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state)
  }
}
Core.prototype.State = StateCore
function StateBlock(src, md, env, tokens) {
  this.src = src
  this.md = md
  this.env = env
  this.tokens = tokens
  this.bMarks = []
  this.eMarks = []
  this.tShift = []
  this.sCount = []
  this.bsCount = []
  this.blkIndent = 0
  this.line = 0
  this.lineMax = 0
  this.tight = false
  this.ddIndent = -1
  this.listIndent = -1
  this.parentType = 'root'
  this.level = 0
  const s = this.src
  for (
    let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false;
    pos < len;
    pos++
  ) {
    const ch = s.charCodeAt(pos)
    if (!indent_found) {
      if (isSpace$1(ch)) {
        indent++
        if (ch === 9) {
          offset += 4 - (offset % 4)
        } else {
          offset++
        }
        continue
      } else {
        indent_found = true
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++
      }
      this.bMarks.push(start)
      this.eMarks.push(pos)
      this.tShift.push(indent)
      this.sCount.push(offset)
      this.bsCount.push(0)
      indent_found = false
      indent = 0
      offset = 0
      start = pos + 1
    }
  }
  this.bMarks.push(s.length)
  this.eMarks.push(s.length)
  this.tShift.push(0)
  this.sCount.push(0)
  this.bsCount.push(0)
  this.lineMax = this.bMarks.length - 1
}
StateBlock.prototype.push = function (type, tag, nesting) {
  const token = new Token(type, tag, nesting)
  token.block = true
  if (nesting < 0) this.level--
  token.level = this.level
  if (nesting > 0) this.level++
  this.tokens.push(token)
  return token
}
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]
}
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break
    }
  }
  return from
}
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos)
    if (!isSpace$1(ch)) {
      break
    }
  }
  return pos
}
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos
  }
  while (pos > min) {
    if (!isSpace$1(this.src.charCodeAt(--pos))) {
      return pos + 1
    }
  }
  return pos
}
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break
    }
  }
  return pos
}
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos
  }
  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1
    }
  }
  return pos
}
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return ''
  }
  const queue = new Array(end - begin)
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0
    const lineStart = this.bMarks[line]
    let first = lineStart
    let last
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1
    } else {
      last = this.eMarks[line]
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first)
      if (isSpace$1(ch)) {
        if (ch === 9) {
          lineIndent += 4 - ((lineIndent + this.bsCount[line]) % 4)
        } else {
          lineIndent++
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++
      } else {
        break
      }
      first++
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)
    } else {
      queue[i] = this.src.slice(first, last)
    }
  }
  return queue.join('')
}
StateBlock.prototype.Token = Token
const MAX_AUTOCOMPLETED_CELLS = 65536
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line]
  const max = state.eMarks[line]
  return state.src.slice(pos, max)
}
function escapedSplit(str) {
  const result = []
  const max = str.length
  let pos = 0
  let ch = str.charCodeAt(pos)
  let isEscaped = false
  let lastPos = 0
  let current = ''
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos))
        current = ''
        lastPos = pos + 1
      } else {
        current += str.substring(lastPos, pos - 1)
        lastPos = pos
      }
    }
    isEscaped = ch === 92
    pos++
    ch = str.charCodeAt(pos)
  }
  result.push(current + str.substring(lastPos))
  return result
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false
  }
  let nextLine = startLine + 1
  if (state.sCount[nextLine] < state.blkIndent) {
    return false
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine]
  if (pos >= state.eMarks[nextLine]) {
    return false
  }
  const firstCh = state.src.charCodeAt(pos++)
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false
  }
  if (pos >= state.eMarks[nextLine]) {
    return false
  }
  const secondCh = state.src.charCodeAt(pos++)
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$1(secondCh)) {
    return false
  }
  if (firstCh === 45 && isSpace$1(secondCh)) {
    return false
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos)
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$1(ch)) {
      return false
    }
    pos++
  }
  let lineText = getLine(state, startLine + 1)
  let columns = lineText.split('|')
  const aligns = []
  for (let i = 0; i < columns.length; i++) {
    const t2 = columns[i].trim()
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue
      } else {
        return false
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? 'center' : 'right')
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push('left')
    } else {
      aligns.push('')
    }
  }
  lineText = getLine(state, startLine).trim()
  if (lineText.indexOf('|') === -1) {
    return false
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  columns = escapedSplit(lineText)
  if (columns.length && columns[0] === '') columns.shift()
  if (columns.length && columns[columns.length - 1] === '') columns.pop()
  const columnCount = columns.length
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false
  }
  if (silent) {
    return true
  }
  const oldParentType = state.parentType
  state.parentType = 'table'
  const terminatorRules = state.md.block.ruler.getRules('blockquote')
  const token_to = state.push('table_open', 'table', 1)
  const tableLines = [startLine, 0]
  token_to.map = tableLines
  const token_tho = state.push('thead_open', 'thead', 1)
  token_tho.map = [startLine, startLine + 1]
  const token_htro = state.push('tr_open', 'tr', 1)
  token_htro.map = [startLine, startLine + 1]
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push('th_open', 'th', 1)
    if (aligns[i]) {
      token_ho.attrs = [['style', 'text-align:' + aligns[i]]]
    }
    const token_il = state.push('inline', '', 0)
    token_il.content = columns[i].trim()
    token_il.children = []
    state.push('th_close', 'th', -1)
  }
  state.push('tr_close', 'tr', -1)
  state.push('thead_close', 'thead', -1)
  let tbodyLines
  let autocompletedCells = 0
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break
    }
    let terminate = false
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true
        break
      }
    }
    if (terminate) {
      break
    }
    lineText = getLine(state, nextLine).trim()
    if (!lineText) {
      break
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break
    }
    columns = escapedSplit(lineText)
    if (columns.length && columns[0] === '') columns.shift()
    if (columns.length && columns[columns.length - 1] === '') columns.pop()
    autocompletedCells += columnCount - columns.length
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push('tbody_open', 'tbody', 1)
      token_tbo.map = tbodyLines = [startLine + 2, 0]
    }
    const token_tro = state.push('tr_open', 'tr', 1)
    token_tro.map = [nextLine, nextLine + 1]
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push('td_open', 'td', 1)
      if (aligns[i]) {
        token_tdo.attrs = [['style', 'text-align:' + aligns[i]]]
      }
      const token_il = state.push('inline', '', 0)
      token_il.content = columns[i] ? columns[i].trim() : ''
      token_il.children = []
      state.push('td_close', 'td', -1)
    }
    state.push('tr_close', 'tr', -1)
  }
  if (tbodyLines) {
    state.push('tbody_close', 'tbody', -1)
    tbodyLines[1] = nextLine
  }
  state.push('table_close', 'table', -1)
  tableLines[1] = nextLine
  state.parentType = oldParentType
  state.line = nextLine
  return true
}
function code$1(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false
  }
  let nextLine = startLine + 1
  let last = nextLine
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++
      continue
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++
      last = nextLine
      continue
    }
    break
  }
  state.line = last
  const token = state.push('code_block', 'code', 0)
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n'
  token.map = [startLine, state.line]
  return true
}
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  let max = state.eMarks[startLine]
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  if (pos + 3 > max) {
    return false
  }
  const marker = state.src.charCodeAt(pos)
  if (marker !== 126 && marker !== 96) {
    return false
  }
  let mem = pos
  pos = state.skipChars(pos, marker)
  let len = pos - mem
  if (len < 3) {
    return false
  }
  const markup = state.src.slice(mem, pos)
  const params = state.src.slice(pos, max)
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false
    }
  }
  if (silent) {
    return true
  }
  let nextLine = startLine
  let haveEndMarker = false
  for (;;) {
    nextLine++
    if (nextLine >= endLine) {
      break
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]
    max = state.eMarks[nextLine]
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue
    }
    pos = state.skipChars(pos, marker)
    if (pos - mem < len) {
      continue
    }
    pos = state.skipSpaces(pos)
    if (pos < max) {
      continue
    }
    haveEndMarker = true
    break
  }
  len = state.sCount[startLine]
  state.line = nextLine + (haveEndMarker ? 1 : 0)
  const token = state.push('fence', 'code', 0)
  token.info = params
  token.content = state.getLines(startLine + 1, nextLine, len, true)
  token.markup = markup
  token.map = [startLine, state.line]
  return true
}
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  let max = state.eMarks[startLine]
  const oldLineMax = state.lineMax
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false
  }
  if (silent) {
    return true
  }
  const oldBMarks = []
  const oldBSCount = []
  const oldSCount = []
  const oldTShift = []
  const terminatorRules = state.md.block.ruler.getRules('blockquote')
  const oldParentType = state.parentType
  state.parentType = 'blockquote'
  let lastLineEmpty = false
  let nextLine
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent
    pos = state.bMarks[nextLine] + state.tShift[nextLine]
    max = state.eMarks[nextLine]
    if (pos >= max) {
      break
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1
      let spaceAfterMarker
      let adjustTab
      if (state.src.charCodeAt(pos) === 32) {
        pos++
        initial++
        adjustTab = false
        spaceAfterMarker = true
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++
          initial++
          adjustTab = false
        } else {
          adjustTab = true
        }
      } else {
        spaceAfterMarker = false
      }
      let offset = initial
      oldBMarks.push(state.bMarks[nextLine])
      state.bMarks[nextLine] = pos
      while (pos < max) {
        const ch = state.src.charCodeAt(pos)
        if (isSpace$1(ch)) {
          if (ch === 9) {
            offset += 4 - ((offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4)
          } else {
            offset++
          }
        } else {
          break
        }
        pos++
      }
      lastLineEmpty = pos >= max
      oldBSCount.push(state.bsCount[nextLine])
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)
      oldSCount.push(state.sCount[nextLine])
      state.sCount[nextLine] = offset - initial
      oldTShift.push(state.tShift[nextLine])
      state.tShift[nextLine] = pos - state.bMarks[nextLine]
      continue
    }
    if (lastLineEmpty) {
      break
    }
    let terminate = false
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true
        break
      }
    }
    if (terminate) {
      state.lineMax = nextLine
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine])
        oldBSCount.push(state.bsCount[nextLine])
        oldTShift.push(state.tShift[nextLine])
        oldSCount.push(state.sCount[nextLine])
        state.sCount[nextLine] -= state.blkIndent
      }
      break
    }
    oldBMarks.push(state.bMarks[nextLine])
    oldBSCount.push(state.bsCount[nextLine])
    oldTShift.push(state.tShift[nextLine])
    oldSCount.push(state.sCount[nextLine])
    state.sCount[nextLine] = -1
  }
  const oldIndent = state.blkIndent
  state.blkIndent = 0
  const token_o = state.push('blockquote_open', 'blockquote', 1)
  token_o.markup = '>'
  const lines = [startLine, 0]
  token_o.map = lines
  state.md.block.tokenize(state, startLine, nextLine)
  const token_c = state.push('blockquote_close', 'blockquote', -1)
  token_c.markup = '>'
  state.lineMax = oldLineMax
  state.parentType = oldParentType
  lines[1] = state.line
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i]
    state.tShift[i + startLine] = oldTShift[i]
    state.sCount[i + startLine] = oldSCount[i]
    state.bsCount[i + startLine] = oldBSCount[i]
  }
  state.blkIndent = oldIndent
  return true
}
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine]
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  const marker = state.src.charCodeAt(pos++)
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false
  }
  let cnt = 1
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++)
    if (ch !== marker && !isSpace$1(ch)) {
      return false
    }
    if (ch === marker) {
      cnt++
    }
  }
  if (cnt < 3) {
    return false
  }
  if (silent) {
    return true
  }
  state.line = startLine + 1
  const token = state.push('hr', 'hr', 0)
  token.map = [startLine, state.line]
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker))
  return true
}
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine]
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  const marker = state.src.charCodeAt(pos++)
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos)
    if (!isSpace$1(ch)) {
      return -1
    }
  }
  return pos
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine]
  const max = state.eMarks[startLine]
  let pos = start
  if (pos + 1 >= max) {
    return -1
  }
  let ch = state.src.charCodeAt(pos++)
  if (ch < 48 || ch > 57) {
    return -1
  }
  for (;;) {
    if (pos >= max) {
      return -1
    }
    ch = state.src.charCodeAt(pos++)
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1
      }
      continue
    }
    if (ch === 41 || ch === 46) {
      break
    }
    return -1
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos)
    if (!isSpace$1(ch)) {
      return -1
    }
  }
  return pos
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true
      state.tokens[i].hidden = true
      i += 2
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token
  let nextLine = startLine
  let tight = true
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false
  }
  if (
    state.listIndent >= 0 &&
    state.sCount[nextLine] - state.listIndent >= 4 &&
    state.sCount[nextLine] < state.blkIndent
  ) {
    return false
  }
  let isTerminatingParagraph = false
  if (silent && state.parentType === 'paragraph') {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true
    }
  }
  let isOrdered
  let markerValue
  let posAfterMarker
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true
    start = state.bMarks[nextLine] + state.tShift[nextLine]
    markerValue = Number(state.src.slice(start, posAfterMarker - 1))
    if (isTerminatingParagraph && markerValue !== 1) return false
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false
  } else {
    return false
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false
  }
  if (silent) {
    return true
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1)
  const listTokIdx = state.tokens.length
  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1)
    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]]
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1)
  }
  const listLines = [nextLine, 0]
  token.map = listLines
  token.markup = String.fromCharCode(markerCharCode)
  let prevEmptyEnd = false
  const terminatorRules = state.md.block.ruler.getRules('list')
  const oldParentType = state.parentType
  state.parentType = 'list'
  while (nextLine < endLine) {
    pos = posAfterMarker
    max = state.eMarks[nextLine]
    const initial =
      state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine])
    let offset = initial
    while (pos < max) {
      const ch = state.src.charCodeAt(pos)
      if (ch === 9) {
        offset += 4 - ((offset + state.bsCount[nextLine]) % 4)
      } else if (ch === 32) {
        offset++
      } else {
        break
      }
      pos++
    }
    const contentStart = pos
    let indentAfterMarker
    if (contentStart >= max) {
      indentAfterMarker = 1
    } else {
      indentAfterMarker = offset - initial
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1
    }
    const indent = initial + indentAfterMarker
    token = state.push('list_item_open', 'li', 1)
    token.markup = String.fromCharCode(markerCharCode)
    const itemLines = [nextLine, 0]
    token.map = itemLines
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1)
    }
    const oldTight = state.tight
    const oldTShift = state.tShift[nextLine]
    const oldSCount = state.sCount[nextLine]
    const oldListIndent = state.listIndent
    state.listIndent = state.blkIndent
    state.blkIndent = indent
    state.tight = true
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine]
    state.sCount[nextLine] = offset
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine)
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true)
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1)
    state.blkIndent = state.listIndent
    state.listIndent = oldListIndent
    state.tShift[nextLine] = oldTShift
    state.sCount[nextLine] = oldSCount
    state.tight = oldTight
    token = state.push('list_item_close', 'li', -1)
    token.markup = String.fromCharCode(markerCharCode)
    nextLine = state.line
    itemLines[1] = nextLine
    if (nextLine >= endLine) {
      break
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break
    }
    let terminate = false
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true
        break
      }
    }
    if (terminate) {
      break
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine)
      if (posAfterMarker < 0) {
        break
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine]
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine)
      if (posAfterMarker < 0) {
        break
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break
    }
  }
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1)
  } else {
    token = state.push('bullet_list_close', 'ul', -1)
  }
  token.markup = String.fromCharCode(markerCharCode)
  listLines[1] = nextLine
  state.line = nextLine
  state.parentType = oldParentType
  if (tight) {
    markTightParagraphs(state, listTokIdx)
  }
  return true
}
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  let max = state.eMarks[startLine]
  let nextLine = startLine + 1
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null
    }
    let isContinuation = false
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules('reference')
      const oldParentType = state.parentType
      state.parentType = 'reference'
      let terminate = false
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true
          break
        }
      }
      state.parentType = oldParentType
      if (terminate) {
        return null
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2]
    const max2 = state.eMarks[nextLine2]
    return state.src.slice(pos2, max2 + 1)
  }
  let str = state.src.slice(pos, max + 1)
  max = str.length
  let labelEnd = -1
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos)
    if (ch === 91) {
      return false
    } else if (ch === 93) {
      labelEnd = pos
      break
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine)
      if (lineContent !== null) {
        str += lineContent
        max = str.length
        nextLine++
      }
    } else if (ch === 92) {
      pos++
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine)
        if (lineContent !== null) {
          str += lineContent
          max = str.length
          nextLine++
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos)
    if (ch === 10) {
      const lineContent = getNextLine(nextLine)
      if (lineContent !== null) {
        str += lineContent
        max = str.length
        nextLine++
      }
    } else if (isSpace$1(ch));
    else {
      break
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)
  if (!destRes.ok) {
    return false
  }
  const href = state.md.normalizeLink(destRes.str)
  if (!state.md.validateLink(href)) {
    return false
  }
  pos = destRes.pos
  const destEndPos = pos
  const destEndLineNo = nextLine
  const start = pos
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos)
    if (ch === 10) {
      const lineContent = getNextLine(nextLine)
      if (lineContent !== null) {
        str += lineContent
        max = str.length
        nextLine++
      }
    } else if (isSpace$1(ch));
    else {
      break
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine)
    if (lineContent === null) break
    str += lineContent
    pos = max
    max = str.length
    nextLine++
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)
  }
  let title
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str
    pos = titleRes.pos
  } else {
    title = ''
    pos = destEndPos
    nextLine = destEndLineNo
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos)
    if (!isSpace$1(ch)) {
      break
    }
    pos++
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = ''
      pos = destEndPos
      nextLine = destEndLineNo
      while (pos < max) {
        const ch = str.charCodeAt(pos)
        if (!isSpace$1(ch)) {
          break
        }
        pos++
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false
  }
  const label = normalizeReference(str.slice(1, labelEnd))
  if (!label) {
    return false
  }
  if (silent) {
    return true
  }
  if (typeof state.env.references === 'undefined') {
    state.env.references = {}
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title, href }
  }
  state.line = nextLine
  return true
}
const block_names = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'search',
  'section',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
]
const attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*'
const unquoted = '[^"\'=<>`\\x00-\\x20]+'
const single_quoted = "'[^']*'"
const double_quoted = '"[^"]*"'
const attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')'
const attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)'
const open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>'
const close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>'
const comment$1 = '<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->'
const processing = '<[?][\\s\\S]*?[?]>'
const declaration = '<![A-Za-z][^>]*>'
const cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'
const HTML_TAG_RE = new RegExp(
  '^(?:' +
    open_tag +
    '|' +
    close_tag +
    '|' +
    comment$1 +
    '|' +
    processing +
    '|' +
    declaration +
    '|' +
    cdata +
    ')'
)
const HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')')
const HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]
]
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  let max = state.eMarks[startLine]
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  if (!state.md.options.html) {
    return false
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false
  }
  let lineText = state.src.slice(pos, max)
  let i = 0
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false
  }
  if (silent) {
    return HTML_SEQUENCES[i][2]
  }
  let nextLine = startLine + 1
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine]
      max = state.eMarks[nextLine]
      lineText = state.src.slice(pos, max)
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++
        }
        break
      }
    }
  }
  state.line = nextLine
  const token = state.push('html_block', '', 0)
  token.map = [startLine, nextLine]
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true)
  return true
}
function heading$1(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine]
  let max = state.eMarks[startLine]
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  let ch = state.src.charCodeAt(pos)
  if (ch !== 35 || pos >= max) {
    return false
  }
  let level = 1
  ch = state.src.charCodeAt(++pos)
  while (ch === 35 && pos < max && level <= 6) {
    level++
    ch = state.src.charCodeAt(++pos)
  }
  if (level > 6 || (pos < max && !isSpace$1(ch))) {
    return false
  }
  if (silent) {
    return true
  }
  max = state.skipSpacesBack(max, pos)
  const tmp = state.skipCharsBack(max, 35, pos)
  if (tmp > pos && isSpace$1(state.src.charCodeAt(tmp - 1))) {
    max = tmp
  }
  state.line = startLine + 1
  const token_o = state.push('heading_open', 'h' + String(level), 1)
  token_o.markup = '########'.slice(0, level)
  token_o.map = [startLine, state.line]
  const token_i = state.push('inline', '', 0)
  token_i.content = state.src.slice(pos, max).trim()
  token_i.map = [startLine, state.line]
  token_i.children = []
  const token_c = state.push('heading_close', 'h' + String(level), -1)
  token_c.markup = '########'.slice(0, level)
  return true
}
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules('paragraph')
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false
  }
  const oldParentType = state.parentType
  state.parentType = 'paragraph'
  let level = 0
  let marker
  let nextLine = startLine + 1
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine]
      const max = state.eMarks[nextLine]
      if (pos < max) {
        marker = state.src.charCodeAt(pos)
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker)
          pos = state.skipSpaces(pos)
          if (pos >= max) {
            level = marker === 61 ? 1 : 2
            break
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue
    }
    let terminate = false
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true
        break
      }
    }
    if (terminate) {
      break
    }
  }
  if (!level) {
    return false
  }
  const content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim()
  state.line = nextLine + 1
  const token_o = state.push('heading_open', 'h' + String(level), 1)
  token_o.markup = String.fromCharCode(marker)
  token_o.map = [startLine, state.line]
  const token_i = state.push('inline', '', 0)
  token_i.content = content2
  token_i.map = [startLine, state.line - 1]
  token_i.children = []
  const token_c = state.push('heading_close', 'h' + String(level), -1)
  token_c.markup = String.fromCharCode(marker)
  state.parentType = oldParentType
  return true
}
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules('paragraph')
  const oldParentType = state.parentType
  let nextLine = startLine + 1
  state.parentType = 'paragraph'
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue
    }
    if (state.sCount[nextLine] < 0) {
      continue
    }
    let terminate = false
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true
        break
      }
    }
    if (terminate) {
      break
    }
  }
  const content2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim()
  state.line = nextLine
  const token_o = state.push('paragraph_open', 'p', 1)
  token_o.map = [startLine, state.line]
  const token_i = state.push('inline', '', 0)
  token_i.content = content2
  token_i.map = [startLine, state.line]
  token_i.children = []
  state.push('paragraph_close', 'p', -1)
  state.parentType = oldParentType
  return true
}
const _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ['table', table, ['paragraph', 'reference']],
  ['code', code$1],
  ['fence', fence, ['paragraph', 'reference', 'blockquote', 'list']],
  ['blockquote', blockquote, ['paragraph', 'reference', 'blockquote', 'list']],
  ['hr', hr, ['paragraph', 'reference', 'blockquote', 'list']],
  ['list', list, ['paragraph', 'reference', 'blockquote']],
  ['reference', reference],
  ['html_block', html_block, ['paragraph', 'reference', 'blockquote']],
  ['heading', heading$1, ['paragraph', 'reference', 'blockquote']],
  ['lheading', lheading],
  ['paragraph', paragraph]
]
function ParserBlock() {
  this.ruler = new Ruler()
  for (let i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() })
  }
}
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  const rules = this.ruler.getRules('')
  const len = rules.length
  const maxNesting = state.md.options.maxNesting
  let line = startLine
  let hasEmptyLines = false
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line)
    if (line >= endLine) {
      break
    }
    if (state.sCount[line] < state.blkIndent) {
      break
    }
    if (state.level >= maxNesting) {
      state.line = endLine
      break
    }
    const prevLine = state.line
    let ok = false
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false)
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line")
        }
        break
      }
    }
    if (!ok) throw new Error('none of the block rules matched')
    state.tight = !hasEmptyLines
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true
    }
    line = state.line
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true
      line++
      state.line = line
    }
  }
}
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  if (!src) {
    return
  }
  const state = new this.State(src, md, env, outTokens)
  this.tokenize(state, state.line, state.lineMax)
}
ParserBlock.prototype.State = StateBlock
function StateInline(src, md, env, outTokens) {
  this.src = src
  this.env = env
  this.md = md
  this.tokens = outTokens
  this.tokens_meta = Array(outTokens.length)
  this.pos = 0
  this.posMax = this.src.length
  this.level = 0
  this.pending = ''
  this.pendingLevel = 0
  this.cache = {}
  this.delimiters = []
  this._prev_delimiters = []
  this.backticks = {}
  this.backticksScanned = false
  this.linkLevel = 0
}
StateInline.prototype.pushPending = function () {
  const token = new Token('text', '', 0)
  token.content = this.pending
  token.level = this.pendingLevel
  this.tokens.push(token)
  this.pending = ''
  return token
}
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending()
  }
  const token = new Token(type, tag, nesting)
  let token_meta = null
  if (nesting < 0) {
    this.level--
    this.delimiters = this._prev_delimiters.pop()
  }
  token.level = this.level
  if (nesting > 0) {
    this.level++
    this._prev_delimiters.push(this.delimiters)
    this.delimiters = []
    token_meta = { delimiters: this.delimiters }
  }
  this.pendingLevel = this.level
  this.tokens.push(token)
  this.tokens_meta.push(token_meta)
  return token
}
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  const max = this.posMax
  const marker = this.src.charCodeAt(start)
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32
  let pos = start
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++
  }
  const count2 = pos - start
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))
  const isLastWhiteSpace = isWhiteSpace(lastChar)
  const isNextWhiteSpace = isWhiteSpace(nextChar)
  const left_flanking =
    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)
  const right_flanking =
    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar)
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar)
  return { can_open, can_close, length: count2 }
}
StateInline.prototype.Token = Token
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true
    default:
      return false
  }
}
function text(state, silent) {
  let pos = state.pos
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++
  }
  if (pos === state.pos) {
    return false
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos)
  }
  state.pos = pos
  return true
}
const SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i
function linkify(state, silent) {
  if (!state.md.options.linkify) return false
  if (state.linkLevel > 0) return false
  const pos = state.pos
  const max = state.posMax
  if (pos + 3 > max) return false
  if (state.src.charCodeAt(pos) !== 58) return false
  if (state.src.charCodeAt(pos + 1) !== 47) return false
  if (state.src.charCodeAt(pos + 2) !== 47) return false
  const match2 = state.pending.match(SCHEME_RE)
  if (!match2) return false
  const proto = match2[1]
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length))
  if (!link2) return false
  let url = link2.url
  if (url.length <= proto.length) return false
  url = url.replace(/\*+$/, '')
  const fullUrl = state.md.normalizeLink(url)
  if (!state.md.validateLink(fullUrl)) return false
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length)
    const token_o = state.push('link_open', 'a', 1)
    token_o.attrs = [['href', fullUrl]]
    token_o.markup = 'linkify'
    token_o.info = 'auto'
    const token_t = state.push('text', '', 0)
    token_t.content = state.md.normalizeLinkText(url)
    const token_c = state.push('link_close', 'a', -1)
    token_c.markup = 'linkify'
    token_c.info = 'auto'
  }
  state.pos += url.length - proto.length
  return true
}
function newline$2(state, silent) {
  let pos = state.pos
  if (state.src.charCodeAt(pos) !== 10) {
    return false
  }
  const pmax = state.pending.length - 1
  const max = state.posMax
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--
        state.pending = state.pending.slice(0, ws)
        state.push('hardbreak', 'br', 0)
      } else {
        state.pending = state.pending.slice(0, -1)
        state.push('softbreak', 'br', 0)
      }
    } else {
      state.push('softbreak', 'br', 0)
    }
  }
  pos++
  while (pos < max && isSpace$1(state.src.charCodeAt(pos))) {
    pos++
  }
  state.pos = pos
  return true
}
const ESCAPED = []
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0)
}
'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1
})
function escape(state, silent) {
  let pos = state.pos
  const max = state.posMax
  if (state.src.charCodeAt(pos) !== 92) return false
  pos++
  if (pos >= max) return false
  let ch1 = state.src.charCodeAt(pos)
  if (ch1 === 10) {
    if (!silent) {
      state.push('hardbreak', 'br', 0)
    }
    pos++
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos)
      if (!isSpace$1(ch1)) break
      pos++
    }
    state.pos = pos
    return true
  }
  let escapedStr = state.src[pos]
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1)
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1]
      pos++
    }
  }
  const origStr = '\\' + escapedStr
  if (!silent) {
    const token = state.push('text_special', '', 0)
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr
    } else {
      token.content = origStr
    }
    token.markup = origStr
    token.info = 'escape'
  }
  state.pos = pos + 1
  return true
}
function backtick(state, silent) {
  let pos = state.pos
  const ch = state.src.charCodeAt(pos)
  if (ch !== 96) {
    return false
  }
  const start = pos
  pos++
  const max = state.posMax
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++
  }
  const marker = state.src.slice(start, pos)
  const openerLength = marker.length
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker
    state.pos += openerLength
    return true
  }
  let matchEnd = pos
  let matchStart
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++
    }
    const closerLength = matchEnd - matchStart
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push('code_inline', 'code', 0)
        token.markup = marker
        token.content = state.src
          .slice(pos, matchStart)
          .replace(/\n/g, ' ')
          .replace(/^ (.+) $/, '$1')
      }
      state.pos = matchEnd
      return true
    }
    state.backticks[closerLength] = matchStart
  }
  state.backticksScanned = true
  if (!silent) state.pending += marker
  state.pos += openerLength
  return true
}
function strikethrough_tokenize(state, silent) {
  const start = state.pos
  const marker = state.src.charCodeAt(start)
  if (silent) {
    return false
  }
  if (marker !== 126) {
    return false
  }
  const scanned = state.scanDelims(state.pos, true)
  let len = scanned.length
  const ch = String.fromCharCode(marker)
  if (len < 2) {
    return false
  }
  let token
  if (len % 2) {
    token = state.push('text', '', 0)
    token.content = ch
    len--
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push('text', '', 0)
    token.content = ch + ch
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    })
  }
  state.pos += scanned.length
  return true
}
function postProcess$1(state, delimiters2) {
  let token
  const loneMarkers = []
  const max = delimiters2.length
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters2[i]
    if (startDelim.marker !== 126) {
      continue
    }
    if (startDelim.end === -1) {
      continue
    }
    const endDelim = delimiters2[startDelim.end]
    token = state.tokens[startDelim.token]
    token.type = 's_open'
    token.tag = 's'
    token.nesting = 1
    token.markup = '~~'
    token.content = ''
    token = state.tokens[endDelim.token]
    token.type = 's_close'
    token.tag = 's'
    token.nesting = -1
    token.markup = '~~'
    token.content = ''
    if (
      state.tokens[endDelim.token - 1].type === 'text' &&
      state.tokens[endDelim.token - 1].content === '~'
    ) {
      loneMarkers.push(endDelim.token - 1)
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop()
    let j = i + 1
    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++
    }
    j--
    if (i !== j) {
      token = state.tokens[j]
      state.tokens[j] = state.tokens[i]
      state.tokens[i] = token
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta
  const max = state.tokens_meta.length
  postProcess$1(state, state.delimiters)
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters)
    }
  }
}
const r_strikethrough = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
}
function emphasis_tokenize(state, silent) {
  const start = state.pos
  const marker = state.src.charCodeAt(start)
  if (silent) {
    return false
  }
  if (marker !== 95 && marker !== 42) {
    return false
  }
  const scanned = state.scanDelims(state.pos, marker === 42)
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push('text', '', 0)
    token.content = String.fromCharCode(marker)
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    })
  }
  state.pos += scanned.length
  return true
}
function postProcess(state, delimiters2) {
  const max = delimiters2.length
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters2[i]
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue
    }
    if (startDelim.end === -1) {
      continue
    }
    const endDelim = delimiters2[startDelim.end]
    const isStrong =
      i > 0 &&
      delimiters2[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
      delimiters2[i - 1].marker === startDelim.marker &&
      delimiters2[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
      delimiters2[startDelim.end + 1].token === endDelim.token + 1
    const ch = String.fromCharCode(startDelim.marker)
    const token_o = state.tokens[startDelim.token]
    token_o.type = isStrong ? 'strong_open' : 'em_open'
    token_o.tag = isStrong ? 'strong' : 'em'
    token_o.nesting = 1
    token_o.markup = isStrong ? ch + ch : ch
    token_o.content = ''
    const token_c = state.tokens[endDelim.token]
    token_c.type = isStrong ? 'strong_close' : 'em_close'
    token_c.tag = isStrong ? 'strong' : 'em'
    token_c.nesting = -1
    token_c.markup = isStrong ? ch + ch : ch
    token_c.content = ''
    if (isStrong) {
      state.tokens[delimiters2[i - 1].token].content = ''
      state.tokens[delimiters2[startDelim.end + 1].token].content = ''
      i--
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta
  const max = state.tokens_meta.length
  postProcess(state, state.delimiters)
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters)
    }
  }
}
const r_emphasis = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
}
function link(state, silent) {
  let code, label, res, ref2
  let href = ''
  let title = ''
  let start = state.pos
  let parseReference = true
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false
  }
  const oldPos = state.pos
  const max = state.posMax
  const labelStart = state.pos + 1
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true)
  if (labelEnd < 0) {
    return false
  }
  let pos = labelEnd + 1
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false
    pos++
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos)
      if (!isSpace$1(code) && code !== 10) {
        break
      }
    }
    if (pos >= max) {
      return false
    }
    start = pos
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)
    if (res.ok) {
      href = state.md.normalizeLink(res.str)
      if (state.md.validateLink(href)) {
        pos = res.pos
      } else {
        href = ''
      }
      start = pos
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos)
        if (!isSpace$1(code) && code !== 10) {
          break
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)
      if (pos < max && start !== pos && res.ok) {
        title = res.str
        pos = res.pos
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos)
          if (!isSpace$1(code) && code !== 10) {
            break
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true
    }
    pos++
  }
  if (parseReference) {
    if (typeof state.env.references === 'undefined') {
      return false
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1
      pos = state.md.helpers.parseLinkLabel(state, pos)
      if (pos >= 0) {
        label = state.src.slice(start, pos++)
      } else {
        pos = labelEnd + 1
      }
    } else {
      pos = labelEnd + 1
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd)
    }
    ref2 = state.env.references[normalizeReference(label)]
    if (!ref2) {
      state.pos = oldPos
      return false
    }
    href = ref2.href
    title = ref2.title
  }
  if (!silent) {
    state.pos = labelStart
    state.posMax = labelEnd
    const token_o = state.push('link_open', 'a', 1)
    const attrs = [['href', href]]
    token_o.attrs = attrs
    if (title) {
      attrs.push(['title', title])
    }
    state.linkLevel++
    state.md.inline.tokenize(state)
    state.linkLevel--
    state.push('link_close', 'a', -1)
  }
  state.pos = pos
  state.posMax = max
  return true
}
function image(state, silent) {
  let code, content2, label, pos, ref2, res, title, start
  let href = ''
  const oldPos = state.pos
  const max = state.posMax
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false
  }
  const labelStart = state.pos + 2
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)
  if (labelEnd < 0) {
    return false
  }
  pos = labelEnd + 1
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos)
      if (!isSpace$1(code) && code !== 10) {
        break
      }
    }
    if (pos >= max) {
      return false
    }
    start = pos
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)
    if (res.ok) {
      href = state.md.normalizeLink(res.str)
      if (state.md.validateLink(href)) {
        pos = res.pos
      } else {
        href = ''
      }
    }
    start = pos
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos)
      if (!isSpace$1(code) && code !== 10) {
        break
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)
    if (pos < max && start !== pos && res.ok) {
      title = res.str
      pos = res.pos
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos)
        if (!isSpace$1(code) && code !== 10) {
          break
        }
      }
    } else {
      title = ''
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos
      return false
    }
    pos++
  } else {
    if (typeof state.env.references === 'undefined') {
      return false
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1
      pos = state.md.helpers.parseLinkLabel(state, pos)
      if (pos >= 0) {
        label = state.src.slice(start, pos++)
      } else {
        pos = labelEnd + 1
      }
    } else {
      pos = labelEnd + 1
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd)
    }
    ref2 = state.env.references[normalizeReference(label)]
    if (!ref2) {
      state.pos = oldPos
      return false
    }
    href = ref2.href
    title = ref2.title
  }
  if (!silent) {
    content2 = state.src.slice(labelStart, labelEnd)
    const tokens = []
    state.md.inline.parse(content2, state.md, state.env, tokens)
    const token = state.push('image', 'img', 0)
    const attrs = [
      ['src', href],
      ['alt', '']
    ]
    token.attrs = attrs
    token.children = tokens
    token.content = content2
    if (title) {
      attrs.push(['title', title])
    }
  }
  state.pos = pos
  state.posMax = max
  return true
}
const EMAIL_RE =
  /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/
const AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/
function autolink(state, silent) {
  let pos = state.pos
  if (state.src.charCodeAt(pos) !== 60) {
    return false
  }
  const start = state.pos
  const max = state.posMax
  for (;;) {
    if (++pos >= max) return false
    const ch = state.src.charCodeAt(pos)
    if (ch === 60) return false
    if (ch === 62) break
  }
  const url = state.src.slice(start + 1, pos)
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url)
    if (!state.md.validateLink(fullUrl)) {
      return false
    }
    if (!silent) {
      const token_o = state.push('link_open', 'a', 1)
      token_o.attrs = [['href', fullUrl]]
      token_o.markup = 'autolink'
      token_o.info = 'auto'
      const token_t = state.push('text', '', 0)
      token_t.content = state.md.normalizeLinkText(url)
      const token_c = state.push('link_close', 'a', -1)
      token_c.markup = 'autolink'
      token_c.info = 'auto'
    }
    state.pos += url.length + 2
    return true
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink('mailto:' + url)
    if (!state.md.validateLink(fullUrl)) {
      return false
    }
    if (!silent) {
      const token_o = state.push('link_open', 'a', 1)
      token_o.attrs = [['href', fullUrl]]
      token_o.markup = 'autolink'
      token_o.info = 'auto'
      const token_t = state.push('text', '', 0)
      token_t.content = state.md.normalizeLinkText(url)
      const token_c = state.push('link_close', 'a', -1)
      token_c.markup = 'autolink'
      token_c.info = 'auto'
    }
    state.pos += url.length + 2
    return true
  }
  return false
}
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str)
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str)
}
function isLetter(ch) {
  const lc = ch | 32
  return lc >= 97 && lc <= 122
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false
  }
  const max = state.posMax
  const pos = state.pos
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false
  }
  const ch = state.src.charCodeAt(pos + 1)
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE)
  if (!match2) {
    return false
  }
  if (!silent) {
    const token = state.push('html_inline', '', 0)
    token.content = match2[0]
    if (isLinkOpen(token.content)) state.linkLevel++
    if (isLinkClose(token.content)) state.linkLevel--
  }
  state.pos += match2[0].length
  return true
}
const DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i
const NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i
function entity(state, silent) {
  const pos = state.pos
  const max = state.posMax
  if (state.src.charCodeAt(pos) !== 38) return false
  if (pos + 1 >= max) return false
  const ch = state.src.charCodeAt(pos + 1)
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE)
    if (match2) {
      if (!silent) {
        const code =
          match2[1][0].toLowerCase() === 'x'
            ? parseInt(match2[1].slice(1), 16)
            : parseInt(match2[1], 10)
        const token = state.push('text_special', '', 0)
        token.content = isValidEntityCode(code) ? fromCodePoint$1(code) : fromCodePoint$1(65533)
        token.markup = match2[0]
        token.info = 'entity'
      }
      state.pos += match2[0].length
      return true
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE)
    if (match2) {
      const decoded = decodeHTML(match2[0])
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push('text_special', '', 0)
          token.content = decoded
          token.markup = match2[0]
          token.info = 'entity'
        }
        state.pos += match2[0].length
        return true
      }
    }
  }
  return false
}
function processDelimiters(delimiters2) {
  const openersBottom = {}
  const max = delimiters2.length
  if (!max) return
  let headerIdx = 0
  let lastTokenIdx = -2
  const jumps = []
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters2[closerIdx]
    jumps.push(0)
    if (delimiters2[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx
    }
    lastTokenIdx = closer.token
    closer.length = closer.length || 0
    if (!closer.close) continue
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1]
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)]
    let openerIdx = headerIdx - jumps[headerIdx] - 1
    let newMinOpenerIdx = openerIdx
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters2[openerIdx]
      if (opener.marker !== closer.marker) continue
      if (opener.open && opener.end < 0) {
        let isOddMatch = false
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true
            }
          }
        }
        if (!isOddMatch) {
          const lastJump =
            openerIdx > 0 && !delimiters2[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0
          jumps[closerIdx] = closerIdx - openerIdx + lastJump
          jumps[openerIdx] = lastJump
          closer.open = false
          opener.end = closerIdx
          opener.close = false
          newMinOpenerIdx = -1
          lastTokenIdx = -2
          break
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] =
        newMinOpenerIdx
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta
  const max = state.tokens_meta.length
  processDelimiters(state.delimiters)
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters)
    }
  }
}
function fragments_join(state) {
  let curr, last
  let level = 0
  const tokens = state.tokens
  const max = state.tokens.length
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--
    tokens[curr].level = level
    if (tokens[curr].nesting > 0) level++
    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr]
      }
      last++
    }
  }
  if (curr !== last) {
    tokens.length = last
  }
}
const _rules = [
  ['text', text],
  ['linkify', linkify],
  ['newline', newline$2],
  ['escape', escape],
  ['backticks', backtick],
  ['strikethrough', r_strikethrough.tokenize],
  ['emphasis', r_emphasis.tokenize],
  ['link', link],
  ['image', image],
  ['autolink', autolink],
  ['html_inline', html_inline],
  ['entity', entity]
]
const _rules2 = [
  ['balance_pairs', link_pairs],
  ['strikethrough', r_strikethrough.postProcess],
  ['emphasis', r_emphasis.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ['fragments_join', fragments_join]
]
function ParserInline() {
  this.ruler = new Ruler()
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1])
  }
  this.ruler2 = new Ruler()
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1])
  }
}
ParserInline.prototype.skipToken = function (state) {
  const pos = state.pos
  const rules = this.ruler.getRules('')
  const len = rules.length
  const maxNesting = state.md.options.maxNesting
  const cache2 = state.cache
  if (typeof cache2[pos] !== 'undefined') {
    state.pos = cache2[pos]
    return
  }
  let ok = false
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++
      ok = rules[i](state, true)
      state.level--
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos")
        }
        break
      }
    }
  } else {
    state.pos = state.posMax
  }
  if (!ok) {
    state.pos++
  }
  cache2[pos] = state.pos
}
ParserInline.prototype.tokenize = function (state) {
  const rules = this.ruler.getRules('')
  const len = rules.length
  const end = state.posMax
  const maxNesting = state.md.options.maxNesting
  while (state.pos < end) {
    const prevPos = state.pos
    let ok = false
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false)
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos")
          }
          break
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break
      }
      continue
    }
    state.pending += state.src[state.pos++]
  }
  if (state.pending) {
    state.pushPending()
  }
}
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens)
  this.tokenize(state)
  const rules = this.ruler2.getRules('')
  const len = rules.length
  for (let i = 0; i < len; i++) {
    rules[i](state)
  }
}
ParserInline.prototype.State = StateInline
function reFactory(opts) {
  const re = {}
  opts = opts || {}
  re.src_Any = Any.source
  re.src_Cc = Cc.source
  re.src_Z = Z.source
  re.src_P = P.source
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|')
  re.src_ZCc = [re.src_Z, re.src_Cc].join('|')
  const text_separators = '[><｜]'
  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')'
  re.src_ip4 =
    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'
  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?'
  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?'
  re.src_host_terminator =
    '(?=$|' +
    text_separators +
    '|' +
    re.src_ZPCc +
    ')(?!' +
    (opts['---'] ? '-(?!--)|' : '-|') +
    '_|:\\d|\\.-|\\.(?!$|' +
    re.src_ZPCc +
    '))'
  re.src_path =
    '(?:[/?#](?:(?!' +
    re.src_ZCc +
    '|' +
    text_separators +
    `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` +
    re.src_ZCc +
    '|\\]).)*\\]|\\((?:(?!' +
    re.src_ZCc +
    '|[)]).)*\\)|\\{(?:(?!' +
    re.src_ZCc +
    '|[}]).)*\\}|\\"(?:(?!' +
    re.src_ZCc +
    `|["]).)+\\"|\\'(?:(?!` +
    re.src_ZCc +
    "|[']).)+\\'|\\'(?=" +
    re.src_pseudo_letter +
    '|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!' +
    re.src_ZCc +
    '|[.]|$)|' +
    (opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' : '\\-+|') + // allow `,,,` in paths
    ',(?!' +
    re.src_ZCc +
    '|$)|;(?!' +
    re.src_ZCc +
    '|$)|\\!+(?!' +
    re.src_ZCc +
    '|[!]|$)|\\?(?!' +
    re.src_ZCc +
    '|[?]|$))+|\\/)?'
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*'
  re.src_xn = 'xn--[a-z0-9\\-]{1,59}'
  re.src_domain_root = '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63})' // Allow letters & digits (http://test1)
  re.src_domain =
    '(?:' +
    re.src_xn +
    '|(?:' +
    re.src_pseudo_letter +
    ')|(?:' +
    re.src_pseudo_letter +
    '(?:-|' +
    re.src_pseudo_letter +
    '){0,61}' +
    re.src_pseudo_letter +
    '))'
  re.src_host = '(?:(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain + '))'
  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%)))'
  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))'
  re.src_host_strict = re.src_host + re.src_host_terminator
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator
  re.tpl_host_port_no_ip_fuzzy_strict =
    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator
  re.tpl_host_fuzzy_test =
    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))'
  re.tpl_email_fuzzy =
    '(^|' +
    text_separators +
    '|"|\\(|' +
    re.src_ZCc +
    ')(' +
    re.src_email_name +
    '@' +
    re.tpl_host_fuzzy_strict +
    ')'
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    '(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|' +
    re.src_ZPCc +
    '))((?![$+<=>^`|｜])' +
    re.tpl_host_port_fuzzy_strict +
    re.src_path +
    ')'
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    '(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|' +
    re.src_ZPCc +
    '))((?![$+<=>^`|｜])' +
    re.tpl_host_port_no_ip_fuzzy_strict +
    re.src_path +
    ')'
  return re
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1)
  sources.forEach(function (source) {
    if (!source) {
      return
    }
    Object.keys(source).forEach(function (key) {
      obj[key] = source[key]
    })
  })
  return obj
}
function _class(obj) {
  return Object.prototype.toString.call(obj)
}
function isString(obj) {
  return _class(obj) === '[object String]'
}
function isObject(obj) {
  return _class(obj) === '[object Object]'
}
function isRegExp(obj) {
  return _class(obj) === '[object RegExp]'
}
function isFunction(obj) {
  return _class(obj) === '[object Function]'
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}
const defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
}
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k2) {
    return acc || defaultOptions.hasOwnProperty(k2)
  }, false)
}
const defaultSchemas = {
  'http:': {
    validate: function (text2, pos, self2) {
      const tail = text2.slice(pos)
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          '^\\/\\/' + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          'i'
        )
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length
      }
      return 0
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function (text2, pos, self2) {
      const tail = text2.slice(pos)
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          '^' +
            self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            '(?:localhost|(?:(?:' +
            self2.re.src_domain +
            ')\\.)+' +
            self2.re.src_domain_root +
            ')' +
            self2.re.src_port +
            self2.re.src_host_terminator +
            self2.re.src_path,
          'i'
        )
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ':') {
          return 0
        }
        if (pos >= 3 && text2[pos - 3] === '/') {
          return 0
        }
        return tail.match(self2.re.no_http)[0].length
      }
      return 0
    }
  },
  'mailto:': {
    validate: function (text2, pos, self2) {
      const tail = text2.slice(pos)
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          '^' + self2.re.src_email_name + '@' + self2.re.src_host_strict,
          'i'
        )
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length
      }
      return 0
    }
  }
}
const tlds_2ch_src_re =
  'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]'
const tlds_default =
  'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|')
function resetScanCache(self2) {
  self2.__index__ = -1
  self2.__text_cache__ = ''
}
function createValidator(re) {
  return function (text2, pos) {
    const tail = text2.slice(pos)
    if (re.test(tail)) {
      return tail.match(re)[0].length
    }
    return 0
  }
}
function createNormalizer() {
  return function (match2, self2) {
    self2.normalize(match2)
  }
}
function compile(self2) {
  const re = (self2.re = reFactory(self2.__opts__))
  const tlds2 = self2.__tlds__.slice()
  self2.onCompile()
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re)
  }
  tlds2.push(re.src_xn)
  re.src_tlds = tlds2.join('|')
  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds)
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i')
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i')
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i')
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i')
  const aliases = []
  self2.__compiled__ = {}
  function schemaError(name2, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val)
  }
  Object.keys(self2.__schemas__).forEach(function (name2) {
    const val = self2.__schemas__[name2]
    if (val === null) {
      return
    }
    const compiled = { validate: null, link: null }
    self2.__compiled__[name2] = compiled
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate)
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate
      } else {
        schemaError(name2, val)
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer()
      } else {
        schemaError(name2, val)
      }
      return
    }
    if (isString(val)) {
      aliases.push(name2)
      return
    }
    schemaError(name2, val)
  })
  aliases.forEach(function (alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize
  })
  self2.__compiled__[''] = { validate: null, normalize: createNormalizer() }
  const slist = Object.keys(self2.__compiled__)
    .filter(function (name2) {
      return name2.length > 0 && self2.__compiled__[name2]
    })
    .map(escapeRE)
    .join('|')
  self2.re.schema_test = RegExp('(^|(?!_)(?:[><｜]|' + re.src_ZPCc + '))(' + slist + ')', 'i')
  self2.re.schema_search = RegExp('(^|(?!_)(?:[><｜]|' + re.src_ZPCc + '))(' + slist + ')', 'ig')
  self2.re.schema_at_start = RegExp('^' + self2.re.schema_search.source, 'i')
  self2.re.pretest = RegExp(
    '(' + self2.re.schema_test.source + ')|(' + self2.re.host_fuzzy_test.source + ')|@',
    'i'
  )
  resetScanCache(self2)
}
function Match(self2, shift2) {
  const start = self2.__index__
  const end = self2.__last_index__
  const text2 = self2.__text_cache__.slice(start, end)
  this.schema = self2.__schema__.toLowerCase()
  this.index = start + shift2
  this.lastIndex = end + shift2
  this.raw = text2
  this.text = text2
  this.url = text2
}
function createMatch(self2, shift2) {
  const match2 = new Match(self2, shift2)
  self2.__compiled__[match2.schema].normalize(match2, self2)
  return match2
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options)
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas
      schemas = {}
    }
  }
  this.__opts__ = assign({}, defaultOptions, options)
  this.__index__ = -1
  this.__last_index__ = -1
  this.__schema__ = ''
  this.__text_cache__ = ''
  this.__schemas__ = assign({}, defaultSchemas, schemas)
  this.__compiled__ = {}
  this.__tlds__ = tlds_default
  this.__tlds_replaced__ = false
  this.re = {}
  compile(this)
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition
  compile(this)
  return this
}
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options)
  return this
}
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2
  this.__index__ = -1
  if (!text2.length) {
    return false
  }
  let m, ml, me, len, shift2, next, re, tld_pos, at_pos
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search
    re.lastIndex = 0
    while ((m = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re.lastIndex)
      if (len) {
        this.__schema__ = m[2]
        this.__index__ = m.index + m[1].length
        this.__last_index__ = m.index + m[0].length + len
        break
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    tld_pos = text2.search(this.re.host_fuzzy_test)
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if (
          (ml = text2.match(
            this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy
          )) !== null
        ) {
          shift2 = ml.index + ml[1].length
          if (this.__index__ < 0 || shift2 < this.__index__) {
            this.__schema__ = ''
            this.__index__ = shift2
            this.__last_index__ = ml.index + ml[0].length
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    at_pos = text2.indexOf('@')
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift2 = me.index + me[1].length
        next = me.index + me[0].length
        if (
          this.__index__ < 0 ||
          shift2 < this.__index__ ||
          (shift2 === this.__index__ && next > this.__last_index__)
        ) {
          this.__schema__ = 'mailto:'
          this.__index__ = shift2
          this.__last_index__ = next
        }
      }
    }
  }
  return this.__index__ >= 0
}
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2)
}
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this)
}
LinkifyIt.prototype.match = function match(text2) {
  const result = []
  let shift2 = 0
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift2))
    shift2 = this.__last_index__
  }
  let tail = shift2 ? text2.slice(shift2) : text2
  while (this.test(tail)) {
    result.push(createMatch(this, shift2))
    tail = tail.slice(this.__last_index__)
    shift2 += this.__last_index__
  }
  if (result.length) {
    return result
  }
  return null
}
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2
  this.__index__ = -1
  if (!text2.length) return null
  const m = this.re.schema_at_start.exec(text2)
  if (!m) return null
  const len = this.testSchemaAt(text2, m[2], m[0].length)
  if (!len) return null
  this.__schema__ = m[2]
  this.__index__ = m.index + m[1].length
  this.__last_index__ = m.index + m[0].length + len
  return createMatch(this, 0)
}
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2]
  if (!keepOld) {
    this.__tlds__ = list2.slice()
    this.__tlds_replaced__ = true
    compile(this)
    return this
  }
  this.__tlds__ = this.__tlds__
    .concat(list2)
    .sort()
    .filter(function (el, idx, arr) {
      return el !== arr[idx - 1]
    })
    .reverse()
  compile(this)
  return this
}
LinkifyIt.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = 'http://' + match2.url
  }
  if (match2.schema === 'mailto:' && !/^mailto:/i.test(match2.url)) {
    match2.url = 'mailto:' + match2.url
  }
}
LinkifyIt.prototype.onCompile = function onCompile() {}
const maxInt = 2147483647
const base$1 = 36
const tMin = 1
const tMax = 26
const skew = 38
const damp = 700
const initialBias = 72
const initialN = 128
const delimiter = '-'
const regexPunycode = /^xn--/
const regexNonASCII = /[^\0-\x7F]/
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g
const errors = {
  overflow: 'Overflow: input needs wider integers to process',
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  'invalid-input': 'Invalid input'
}
const baseMinusTMin = base$1 - tMin
const floor = Math.floor
const stringFromCharCode = String.fromCharCode
function error(type) {
  throw new RangeError(errors[type])
}
function map(array, callback) {
  const result = []
  let length = array.length
  while (length--) {
    result[length] = callback(array[length])
  }
  return result
}
function mapDomain(domain, callback) {
  const parts = domain.split('@')
  let result = ''
  if (parts.length > 1) {
    result = parts[0] + '@'
    domain = parts[1]
  }
  domain = domain.replace(regexSeparators, '.')
  const labels = domain.split('.')
  const encoded = map(labels, callback).join('.')
  return result + encoded
}
function ucs2decode(string2) {
  const output = []
  let counter = 0
  const length = string2.length
  while (counter < length) {
    const value = string2.charCodeAt(counter++)
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string2.charCodeAt(counter++)
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536)
      } else {
        output.push(value)
        counter--
      }
    } else {
      output.push(value)
    }
  }
  return output
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints)
const basicToDigit = function (codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48)
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97
  }
  return base$1
}
const digitToBasic = function (digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
}
const adapt = function (delta, numPoints, firstTime) {
  let k2 = 0
  delta = firstTime ? floor(delta / damp) : delta >> 1
  delta += floor(delta / numPoints)
  for (; delta > (baseMinusTMin * tMax) >> 1; k2 += base$1) {
    delta = floor(delta / baseMinusTMin)
  }
  return floor(k2 + ((baseMinusTMin + 1) * delta) / (delta + skew))
}
const decode = function (input) {
  const output = []
  const inputLength = input.length
  let i = 0
  let n2 = initialN
  let bias = initialBias
  let basic = input.lastIndexOf(delimiter)
  if (basic < 0) {
    basic = 0
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error('not-basic')
    }
    output.push(input.charCodeAt(j))
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    const oldi = i
    for (let w = 1, k2 = base$1; ; k2 += base$1) {
      if (index2 >= inputLength) {
        error('invalid-input')
      }
      const digit = basicToDigit(input.charCodeAt(index2++))
      if (digit >= base$1) {
        error('invalid-input')
      }
      if (digit > floor((maxInt - i) / w)) {
        error('overflow')
      }
      i += digit * w
      const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias
      if (digit < t2) {
        break
      }
      const baseMinusT = base$1 - t2
      if (w > floor(maxInt / baseMinusT)) {
        error('overflow')
      }
      w *= baseMinusT
    }
    const out = output.length + 1
    bias = adapt(i - oldi, out, oldi == 0)
    if (floor(i / out) > maxInt - n2) {
      error('overflow')
    }
    n2 += floor(i / out)
    i %= out
    output.splice(i++, 0, n2)
  }
  return String.fromCodePoint(...output)
}
const encode = function (input) {
  const output = []
  input = ucs2decode(input)
  const inputLength = input.length
  let n2 = initialN
  let delta = 0
  let bias = initialBias
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue))
    }
  }
  const basicLength = output.length
  let handledCPCount = basicLength
  if (basicLength) {
    output.push(delimiter)
  }
  while (handledCPCount < inputLength) {
    let m = maxInt
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m) {
        m = currentValue
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1
    if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow')
    }
    delta += (m - n2) * handledCPCountPlusOne
    n2 = m
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta > maxInt) {
        error('overflow')
      }
      if (currentValue === n2) {
        let q = delta
        for (let k2 = base$1; ; k2 += base$1) {
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias
          if (q < t2) {
            break
          }
          const qMinusT = q - t2
          const baseMinusT = base$1 - t2
          output.push(stringFromCharCode(digitToBasic(t2 + (qMinusT % baseMinusT), 0)))
          q = floor(qMinusT / baseMinusT)
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)))
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength)
        delta = 0
        ++handledCPCount
      }
    }
    ++delta
    ++n2
  }
  return output.join('')
}
const toUnicode = function (input) {
  return mapDomain(input, function (string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2
  })
}
const toASCII = function (input) {
  return mapDomain(input, function (string2) {
    return regexNonASCII.test(string2) ? 'xn--' + encode(string2) : string2
  })
}
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: '2.3.1',
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ucs2decode,
    encode: ucs2encode
  },
  decode: decode,
  encode: encode,
  toASCII: toASCII,
  toUnicode: toUnicode
}
const cfg_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: 'language-',
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '“”‘’',
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}
const cfg_zero = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: 'language-',
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '“”‘’',
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: ['normalize', 'block', 'inline', 'text_join']
    },
    block: {
      rules: ['paragraph']
    },
    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'fragments_join']
    }
  }
}
const cfg_commonmark = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: 'language-',
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '“”‘’',
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: ['normalize', 'block', 'inline', 'text_join']
    },
    block: {
      rules: [
        'blockquote',
        'code',
        'fence',
        'heading',
        'hr',
        'html_block',
        'lheading',
        'list',
        'reference',
        'paragraph'
      ]
    },
    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'html_inline',
        'image',
        'link',
        'newline',
        'text'
      ],
      rules2: ['balance_pairs', 'emphasis', 'fragments_join']
    }
  }
}
const config = {
  default: cfg_default,
  zero: cfg_zero,
  commonmark: cfg_commonmark
}
const BAD_PROTO_RE = /^(vbscript|javascript|file|data):/
const GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/
function validateLink(url) {
  const str = url.trim().toLowerCase()
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true
}
const RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:']
function normalizeLink(url) {
  const parsed = urlParse(url, true)
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname)
      } catch (er) {}
    }
  }
  return encode$1(format(parsed))
}
function normalizeLinkText(url) {
  const parsed = urlParse(url, true)
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname)
      } catch (er) {}
    }
  }
  return decode$1(format(parsed), decode$1.defaultChars + '%')
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options)
  }
  if (!options) {
    if (!isString$1(presetName)) {
      options = presetName || {}
      presetName = 'default'
    }
  }
  this.inline = new ParserInline()
  this.block = new ParserBlock()
  this.core = new Core()
  this.renderer = new Renderer()
  this.linkify = new LinkifyIt()
  this.validateLink = validateLink
  this.normalizeLink = normalizeLink
  this.normalizeLinkText = normalizeLinkText
  this.utils = utils
  this.helpers = assign$1({}, helpers)
  this.options = {}
  this.configure(presetName)
  if (options) {
    this.set(options)
  }
}
MarkdownIt.prototype.set = function (options) {
  assign$1(this.options, options)
  return this
}
MarkdownIt.prototype.configure = function (presets) {
  const self2 = this
  if (isString$1(presets)) {
    const presetName = presets
    presets = config[presetName]
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name')
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty")
  }
  if (presets.options) {
    self2.set(presets.options)
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules)
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2)
      }
    })
  }
  return this
}
MarkdownIt.prototype.enable = function (list2, ignoreInvalid) {
  let result = []
  if (!Array.isArray(list2)) {
    list2 = [list2]
  }
  ;['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list2, true))
  }, this)
  result = result.concat(this.inline.ruler2.enable(list2, true))
  const missed = list2.filter(function (name2) {
    return result.indexOf(name2) < 0
  })
  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed)
  }
  return this
}
MarkdownIt.prototype.disable = function (list2, ignoreInvalid) {
  let result = []
  if (!Array.isArray(list2)) {
    list2 = [list2]
  }
  ;['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list2, true))
  }, this)
  result = result.concat(this.inline.ruler2.disable(list2, true))
  const missed = list2.filter(function (name2) {
    return result.indexOf(name2) < 0
  })
  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed)
  }
  return this
}
MarkdownIt.prototype.use = function (plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1))
  plugin.apply(plugin, args)
  return this
}
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String')
  }
  const state = new this.core.State(src, this, env)
  this.core.process(state)
  return state.tokens
}
MarkdownIt.prototype.render = function (src, env) {
  env = env || {}
  return this.renderer.render(this.parse(src, env), this.options, env)
}
MarkdownIt.prototype.parseInline = function (src, env) {
  const state = new this.core.State(src, this, env)
  state.inlineMode = true
  this.core.process(state)
  return state.tokens
}
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {}
  return this.renderer.render(this.parseInline(src, env), this.options, env)
}
const t$1 = /* @__PURE__ */ new Set([true, false, 'alt', 'title'])
function e(t2, e2) {
  return (Array.isArray(t2) ? t2 : []).filter(([t3]) => t3 !== e2)
}
function n(t2, n2) {
  t2 && t2.attrs && (t2.attrs = e(t2.attrs, n2))
}
function i$1(e2, i) {
  if (!t$1.has(e2)) throw new TypeError(`figcaption must be one of: ${[...t$1]}.`)
  if ('alt' === e2) return i.content
  const r2 = i.attrs.find(([t2]) => 'title' === t2)
  return Array.isArray(r2) && r2[1] ? (n(i, 'title'), r2[1]) : void 0
}
function r(t2, r2) {
  ;((r2 = r2 || {}),
    t2.core.ruler.before('linkify', 'image_figures', function (s) {
      let a = 1
      for (let o = 1, c = s.tokens.length; o < c - 1; ++o) {
        const l = s.tokens[o]
        if ('inline' !== l.type) continue
        if (!l.children || (1 !== l.children.length && 3 !== l.children.length)) continue
        if (1 === l.children.length && 'image' !== l.children[0].type) continue
        if (3 === l.children.length) {
          const [t3, e2, n2] = l.children
          if ('link_open' !== t3.type || 'image' !== e2.type || 'link_close' !== n2.type) continue
        }
        if (0 !== o && 'paragraph_open' !== s.tokens[o - 1].type) continue
        if (o !== c - 1 && 'paragraph_close' !== s.tokens[o + 1].type) continue
        const f = s.tokens[o - 1]
        let h2
        if (
          ((f.type = 'figure_open'),
          (f.tag = 'figure'),
          (s.tokens[o + 1].type = 'figure_close'),
          (s.tokens[o + 1].tag = 'figure'),
          r2.dataType && s.tokens[o - 1].attrPush(['data-type', 'image']),
          r2.link && 1 === l.children.length)
        ) {
          ;[h2] = l.children
          const t3 = new s.Token('link_open', 'a', 1)
          ;(t3.attrPush(['href', h2.attrGet('src')]),
            l.children.unshift(t3),
            l.children.push(new s.Token('link_close', 'a', -1)))
        }
        if (((h2 = 1 === l.children.length ? l.children[0] : l.children[1]), r2.figcaption)) {
          const n2 = i$1(r2.figcaption, h2)
          if (n2) {
            const [i] = t2.parseInline(n2, s.env)
            ;(l.children.push(new s.Token('figcaption_open', 'figcaption', 1)),
              l.children.push(...i.children),
              l.children.push(new s.Token('figcaption_close', 'figcaption', -1)),
              h2.attrs && (h2.attrs = e(h2.attrs, 'title')))
          }
        }
        if (r2.copyAttrs && h2.attrs) {
          const t3 = true === r2.copyAttrs ? '' : r2.copyAttrs
          f.attrs = h2.attrs.filter(([e2]) => e2.match(t3)).map((t4) => Array.from(t4))
        }
        if (
          (r2.tabindex && (s.tokens[o - 1].attrPush(['tabindex', a]), a++),
          r2.lazy &&
            (h2.attrs.some(([t3]) => 'loading' === t3) || h2.attrs.push(['loading', 'lazy'])),
          r2.async &&
            (h2.attrs.some(([t3]) => 'decoding' === t3) || h2.attrs.push(['decoding', 'async'])),
          r2.classes && 'string' == typeof r2.classes)
        ) {
          let t3 = false
          for (let e2 = 0, n2 = h2.attrs.length; e2 < n2 && !t3; e2++) {
            const n3 = h2.attrs[e2]
            'class' === n3[0] && ((n3[1] = `${n3[1]} ${r2.classes}`), (t3 = true))
          }
          t3 || h2.attrs.push(['class', r2.classes])
        }
        if (r2.removeSrc) {
          const t3 = h2.attrs.find(([t4]) => 'src' === t4)
          ;(h2.attrs.push(['data-src', t3[1]]), n(h2, 'src'))
        }
      }
    }))
}
const UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g
function subscript(state, silent) {
  const max = state.posMax
  const start = state.pos
  if (state.src.charCodeAt(start) !== 126) {
    return false
  }
  if (silent) {
    return false
  }
  if (start + 2 >= max) {
    return false
  }
  state.pos = start + 1
  let found = false
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 126) {
      found = true
      break
    }
    state.md.inline.skipToken(state)
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start
    return false
  }
  const content2 = state.src.slice(start + 1, state.pos)
  if (content2.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start
    return false
  }
  state.posMax = state.pos
  state.pos = start + 1
  const token_so = state.push('sub_open', 'sub', 1)
  token_so.markup = '~'
  const token_t = state.push('text', '', 0)
  token_t.content = content2.replace(UNESCAPE_RE$1, '$1')
  const token_sc = state.push('sub_close', 'sub', -1)
  token_sc.markup = '~'
  state.pos = state.posMax + 1
  state.posMax = max
  return true
}
function sub_plugin(md) {
  md.inline.ruler.after('emphasis', 'sub', subscript)
}
const UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g
function superscript(state, silent) {
  const max = state.posMax
  const start = state.pos
  if (state.src.charCodeAt(start) !== 94) {
    return false
  }
  if (silent) {
    return false
  }
  if (start + 2 >= max) {
    return false
  }
  state.pos = start + 1
  let found = false
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 94) {
      found = true
      break
    }
    state.md.inline.skipToken(state)
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start
    return false
  }
  const content2 = state.src.slice(start + 1, state.pos)
  if (content2.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start
    return false
  }
  state.posMax = state.pos
  state.pos = start + 1
  const token_so = state.push('sup_open', 'sup', 1)
  token_so.markup = '^'
  const token_t = state.push('text', '', 0)
  token_t.content = content2.replace(UNESCAPE_RE, '$1')
  const token_sc = state.push('sup_close', 'sup', -1)
  token_sc.markup = '^'
  state.pos = state.posMax + 1
  state.posMax = max
  return true
}
function sup_plugin(md) {
  md.inline.ruler.after('emphasis', 'sup', superscript)
}
const base642File = (base64, fileName = 'image.png') => {
  const arr = base64.split(',')
  const regResult = arr[0].match(/:(.*?);/)
  if (regResult) {
    const mime = regResult[1]
    const bstr = atob(arr[1])
    let n2 = bstr.length
    const u8arr = new Uint8Array(n2)
    while (n2--) {
      u8arr[n2] = bstr.charCodeAt(n2)
    }
    return new File([u8arr], fileName, { type: mime })
  }
  return null
}
const generateCodeRowNumber = (code, source) => {
  if (!code) {
    return code
  }
  const list2 = source.split('\n')
  const rowNumberList = ['<span rn-wrapper aria-hidden="true">']
  list2.forEach(() => {
    rowNumberList.push('<span></span>')
  })
  rowNumberList.push('</span>')
  return `<span class="${prefix}-code-block">${code}</span>${rowNumberList.join('')}`
}
const getRelativeTop = (element, container) => {
  if (!element || !container) {
    return 0
  }
  const eleRect = element == null ? void 0 : element.getBoundingClientRect()
  if (container === document.documentElement) {
    return eleRect.top - container.clientTop
  }
  const conRect = container == null ? void 0 : container.getBoundingClientRect()
  return eleRect.top - conRect.top
}
const getZIndexIncrement = /* @__PURE__ */ (() => {
  let startIndex = 0
  return () => {
    return ++startIndex
  }
})()
const CDN_IDS = {
  hljs: `${prefix}-hljs`,
  hlcss: `${prefix}-hlCss`,
  prettier: `${prefix}-prettier`,
  prettierMD: `${prefix}-prettierMD`,
  cropperjs: `${prefix}-cropper`,
  croppercss: `${prefix}-cropperCss`,
  screenfull: `${prefix}-screenfull`,
  mermaidM: `${prefix}-mermaid-m`,
  mermaid: `${prefix}-mermaid`,
  katexjs: `${prefix}-katex`,
  katexcss: `${prefix}-katexCss`
}
const userZoom = (props2, html2) => {
  const editorId = inject('editorId')
  const { noImgZoomIn } = props2
  const zoomHander = k(() => {
    const imgs = document.querySelectorAll(
      `#${editorId}-preview img:not(.not-zoom):not(.medium-zoom-image)`
    )
    if (imgs.length === 0) {
      return
    }
    mediumZoom(imgs, {
      background: '#00000073'
    })
  })
  onMounted(() => {
    if (!noImgZoomIn && props2.setting.preview) {
      zoomHander()
    }
  })
  watch([html2, toRef(props2.setting, 'preview')], () => {
    if (!noImgZoomIn && props2.setting.preview) {
      zoomHander()
    }
  })
}
const useCopyCode = (props2, html2, key) => {
  const editorId = inject('editorId')
  const rootRef = inject('rootRef')
  const ult = inject('usedLanguageText')
  const initCopyEntry = () => {
    rootRef.value
      .querySelectorAll(`#${editorId} .${prefix}-preview .${prefix}-code`)
      .forEach((codeBlock) => {
        let clearTimer = -1
        const copyButton = codeBlock.querySelector(`.${prefix}-copy-button`)
        if (copyButton)
          copyButton.onclick = (e2) => {
            e2.preventDefault()
            clearTimeout(clearTimer)
            const activeCode =
              codeBlock.querySelector('input:checked + pre code') ||
              codeBlock.querySelector('pre code')
            const codeText = activeCode.textContent
            const { text: text2, successTips, failTips } = ult.value.copyCode
            let msg = successTips
            copy2Clipboard(props2.formatCopiedText(codeText))
              .catch(() => {
                msg = failTips
              })
              .finally(() => {
                if (copyButton.dataset.isIcon) {
                  copyButton.dataset.tips = msg
                } else {
                  copyButton.innerHTML = msg
                }
                clearTimer = window.setTimeout(() => {
                  if (copyButton.dataset.isIcon) {
                    copyButton.dataset.tips = text2
                  } else {
                    copyButton.innerHTML = text2
                  }
                }, 1500)
              })
          }
      })
  }
  const htmlChanged = () => {
    nextTick(initCopyEntry)
  }
  const settingPreviewChanged = (nVal) => {
    if (nVal) {
      nextTick(initCopyEntry)
    }
  }
  watch([html2, key], htmlChanged)
  watch(() => props2.setting.preview, settingPreviewChanged)
  watch(() => props2.setting.htmlPreview, settingPreviewChanged)
  onMounted(initCopyEntry)
}
const useHighlight = (props2) => {
  const highlight = inject('highlight')
  const hljsRef = shallowRef(globalConfig.editorExtensions.highlight.instance)
  onMounted(() => {
    if (props2.noHighlight || hljsRef.value) {
      return
    }
    appendHandler('link', {
      ...highlight.value.css,
      rel: 'stylesheet',
      id: CDN_IDS.hlcss
    })
    appendHandler(
      'script',
      {
        ...highlight.value.js,
        id: CDN_IDS.hljs,
        onload() {
          hljsRef.value = window.hljs
        }
      },
      'hljs'
    )
  })
  watch(
    () => highlight.value.css,
    () => {
      if (props2.noHighlight || globalConfig.editorExtensions.highlight.instance) {
        return
      }
      updateHandler('link', {
        ...highlight.value.css,
        rel: 'stylesheet',
        id: CDN_IDS.hlcss
      })
    }
  )
  return hljsRef
}
const mermaidCache = new LRUCache({
  max: 1e3,
  // 缓存10分钟
  ttl: 6e5
})
const useMermaid = (props2) => {
  const editorId = inject('editorId')
  const theme2 = inject('theme')
  const rootRef = inject('rootRef')
  const { editorExtensions, editorExtensionsAttrs, mermaidConfig } = globalConfig
  let mermaid = editorExtensions.mermaid.instance
  const reRenderRef = shallowRef(-1)
  const configMermaid = () => {
    if (!props2.noMermaid && mermaid) {
      mermaid.initialize(
        mermaidConfig({
          startOnLoad: false,
          theme: theme2.value === 'dark' ? 'dark' : 'default'
        })
      )
      reRenderRef.value = reRenderRef.value + 1
    }
  }
  watch(
    () => theme2.value,
    () => {
      mermaidCache.clear()
      configMermaid()
    }
  )
  onMounted(() => {
    var _a2, _b
    if (props2.noMermaid || mermaid) {
      return
    }
    const jsSrc = editorExtensions.mermaid.js
    if (/\.mjs/.test(jsSrc)) {
      appendHandler('link', {
        ...((_a2 = editorExtensionsAttrs.mermaid) == null ? void 0 : _a2.js),
        rel: 'modulepreload',
        href: jsSrc,
        id: CDN_IDS.mermaidM
      })
      import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        jsSrc
      ).then((module) => {
        mermaid = module.default
        configMermaid()
      })
    } else {
      appendHandler(
        'script',
        {
          ...((_b = editorExtensionsAttrs.mermaid) == null ? void 0 : _b.js),
          src: jsSrc,
          id: CDN_IDS.mermaid,
          onload() {
            mermaid = window.mermaid
            configMermaid()
          }
        },
        'mermaid'
      )
    }
  })
  const replaceMermaid = async () => {
    if (!props2.noMermaid && mermaid) {
      const mermaidSourceEles = rootRef.value.querySelectorAll(`div.${prefix}-mermaid`)
      const svgContainingElement = document.createElement('div')
      const sceWidth = document.body.offsetWidth > 1366 ? document.body.offsetWidth : 1366
      const sceHeight = document.body.offsetHeight > 768 ? document.body.offsetHeight : 768
      svgContainingElement.style.width = sceWidth + 'px'
      svgContainingElement.style.height = sceHeight + 'px'
      svgContainingElement.style.position = 'fixed'
      svgContainingElement.style.zIndex = '-10000'
      svgContainingElement.style.top = '-10000'
      let count2 = mermaidSourceEles.length
      if (count2 > 0) {
        document.body.appendChild(svgContainingElement)
      }
      await Promise.allSettled(
        Array.from(mermaidSourceEles).map((ele) => {
          const handler = async (item) => {
            var _a2
            if (item.dataset.closed === 'false') {
              return false
            }
            const code = item.innerText
            let mermaidHtml = mermaidCache.get(code)
            if (!mermaidHtml) {
              const idRand = U()
              let result = { svg: '' }
              try {
                result = await mermaid.render(idRand, code, svgContainingElement)
                mermaidHtml = await props2.sanitizeMermaid(result.svg)
                const p = document.createElement('p')
                p.className = `${prefix}-mermaid`
                p.setAttribute('data-processed', '')
                p.innerHTML = mermaidHtml
                ;(_a2 = p.children[0]) == null ? void 0 : _a2.removeAttribute('height')
                mermaidCache.set(code, p.innerHTML)
                if (item.dataset.line !== void 0) {
                  p.dataset.line = item.dataset.line
                }
                item.replaceWith(p)
              } catch (error2) {
                bus.emit(editorId, ERROR_CATCHER, {
                  name: 'mermaid',
                  message: error2.message,
                  error: error2
                })
              }
              if (--count2 === 0) {
                svgContainingElement.remove()
              }
            }
          }
          return handler(ele)
        })
      )
    }
  }
  return { reRenderRef, replaceMermaid }
}
const useKatex = (props2) => {
  const katex = shallowRef(globalConfig.editorExtensions.katex.instance)
  onMounted(() => {
    var _a2, _b
    if (props2.noKatex || katex.value) {
      return
    }
    const { editorExtensions, editorExtensionsAttrs } = globalConfig
    appendHandler(
      'script',
      {
        ...((_a2 = editorExtensionsAttrs.katex) == null ? void 0 : _a2.js),
        src: editorExtensions.katex.js,
        id: CDN_IDS.katexjs,
        onload() {
          katex.value = window.katex
        }
      },
      'katex'
    )
    appendHandler('link', {
      ...((_b = editorExtensionsAttrs.katex) == null ? void 0 : _b.css),
      rel: 'stylesheet',
      href: editorExtensions.katex.css,
      id: CDN_IDS.katexcss
    })
  })
  return katex
}
const MermaidPlugin = (md, options) => {
  const temp = md.renderer.rules.fence.bind(md.renderer.rules)
  md.renderer.rules.fence = (tokens, idx, ops, env, slf) => {
    var _a2
    const token = tokens[idx]
    const code = token.content.trim()
    if (token.info === 'mermaid') {
      token.attrSet('class', `${prefix}-mermaid`)
      token.attrSet('data-mermaid-theme', options.themeRef.value)
      if (token.map && token.level === 0) {
        const closeLine = token.map[1] - 1
        const closeLineText = (_a2 = env.srcLines[closeLine]) == null ? void 0 : _a2.trim()
        const isClosingFence = closeLineText == null ? void 0 : closeLineText.startsWith('```')
        token.attrSet('data-closed', isClosingFence)
        token.attrSet('data-line', String(token.map[0]))
      }
      const mermaidHtml = mermaidCache.get(code)
      if (mermaidHtml) {
        token.attrSet('data-processed', '')
        return `<p ${slf.renderAttrs(token)}>${mermaidHtml}</p>`
      }
      return `<div ${slf.renderAttrs(token)}>${md.utils.escapeHtml(code)}</div>`
    }
    return temp(tokens, idx, ops, env, slf)
  }
}
const mergeAttrs = (token, addAttrs) => {
  const tmpAttrs = token.attrs ? token.attrs.slice() : []
  addAttrs.forEach((addAttr) => {
    const i = token.attrIndex(addAttr[0])
    if (i < 0) {
      tmpAttrs.push(addAttr)
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice()
      tmpAttrs[i][1] += ` ${addAttr[1]}`
    }
  })
  return tmpAttrs
}
const delimiters = {
  block: [
    { open: '$$', close: '$$' },
    { open: '\\[', close: '\\]' }
  ],
  inline: [
    { open: '$$', close: '$$' },
    { open: '$', close: '$' },
    { open: '\\[', close: '\\]' },
    { open: '\\(', close: '\\)' }
  ]
}
const create_math_inline = (options) => (state, silent) => {
  const delimiters2 = options.delimiters
  let match2, token, pos
  for (const delim of delimiters2) {
    if (state.src.startsWith(delim.open, state.pos)) {
      const start = state.pos + delim.open.length
      match2 = start
      while ((match2 = state.src.indexOf(delim.close, match2)) !== -1) {
        pos = match2 - 1
        while (state.src[pos] === '\\') {
          pos -= 1
        }
        if ((match2 - pos) % 2 === 1) {
          break
        }
        match2 += delim.close.length
      }
      if (match2 === -1) {
        if (!silent) {
          state.pending += delim.open
        }
        state.pos = start
        return true
      }
      if (match2 - start === 0) {
        if (!silent) {
          state.pending += delim.open + delim.close
        }
        state.pos = start + delim.close.length
        return true
      }
      if (!silent) {
        const inlineContent = state.src.slice(start, match2)
        token = state.push('math_inline', 'math', 0)
        token.markup = delim.open
        token.content = inlineContent
      }
      state.pos = match2 + delim.close.length
      return true
    }
  }
  return false
}
const create_math_block = (options) => (state, start, end, silent) => {
  const delimiters2 = options.delimiters
  let firstLine,
    lastLine,
    next,
    lastPos,
    found = false
  let pos = state.bMarks[start] + state.tShift[start]
  let max = state.eMarks[start]
  for (const delim of delimiters2) {
    if (
      state.src.slice(pos, pos + delim.open.length) === delim.open &&
      state.src.slice(max - delim.close.length, max) === delim.close
    ) {
      pos += delim.open.length
      firstLine = state.src.slice(pos, max)
      if (silent) {
        return true
      }
      if (firstLine.trim().slice(-delim.close.length) === delim.close) {
        firstLine = firstLine.trim().slice(0, -delim.close.length)
        found = true
      }
      for (next = start; !found; ) {
        next++
        if (next >= end) {
          break
        }
        pos = state.bMarks[next] + state.tShift[next]
        max = state.eMarks[next]
        if (pos < max && state.tShift[next] < state.blkIndent) {
          break
        }
        if (state.src.slice(pos, max).trim().slice(-delim.close.length) === delim.close) {
          lastPos = state.src.slice(0, max).lastIndexOf(delim.close)
          lastLine = state.src.slice(pos, lastPos)
          found = true
        }
      }
      state.line = next + 1
      const token = state.push('math_block', 'math', 0)
      token.block = true
      token.content =
        (firstLine && firstLine.trim() ? firstLine + '\n' : '') +
        state.getLines(start + 1, next, state.tShift[start], true) +
        (lastLine && lastLine.trim() ? lastLine : '')
      token.map = [start, state.line]
      token.markup = delim.open
      return true
    }
  }
  return false
}
const KatexPlugin = (md, { katexRef, inlineDelimiters, blockDelimiters }) => {
  const katexInline = (tokens, idx, options, env, slf) => {
    const token = tokens[idx]
    const tmpToken = {
      attrs: mergeAttrs(token, [['class', `${prefix}-katex-inline`]])
    }
    if (katexRef.value) {
      const html2 = katexRef.value.renderToString(
        token.content,
        globalConfig.katexConfig({
          throwOnError: false
        })
      )
      return `<span ${slf.renderAttrs(tmpToken)} data-processed>${html2}</span>`
    } else {
      return `<span ${slf.renderAttrs(tmpToken)}>${token.content}</span>`
    }
  }
  const katexBlock = (tokens, idx, options, env, slf) => {
    const token = tokens[idx]
    const tmpToken = {
      attrs: mergeAttrs(token, [['class', `${prefix}-katex-block`]])
    }
    if (katexRef.value) {
      const html2 = katexRef.value.renderToString(
        token.content,
        globalConfig.katexConfig({
          throwOnError: false,
          displayMode: true
        })
      )
      return `<p ${slf.renderAttrs(tmpToken)} data-processed>${html2}</p>`
    } else {
      return `<p ${slf.renderAttrs(tmpToken)}>${token.content}</p>`
    }
  }
  md.inline.ruler.before(
    'escape',
    'math_inline',
    create_math_inline({
      delimiters: inlineDelimiters || delimiters.inline
    })
  )
  md.block.ruler.after(
    'blockquote',
    'math_block',
    create_math_block({
      delimiters: blockDelimiters || delimiters.block
    }),
    {
      alt: ['paragraph', 'reference', 'blockquote', 'list']
    }
  )
  md.renderer.rules.math_inline = katexInline
  md.renderer.rules.math_block = katexBlock
}
const AdmonitionPlugin = (md, options) => {
  options = options || {}
  const markers = 3,
    markerStr = options.marker || '!',
    markerChar = markerStr.charCodeAt(0),
    markerLen = markerStr.length
  let type = '',
    title = ''
  const render = (tokens, idx, _options, _env, self2) => {
    const token = tokens[idx]
    if (token.type === 'admonition_open') {
      tokens[idx].attrPush(['class', `${prefix}-admonition ${prefix}-admonition-${token.info}`])
    } else if (token.type === 'admonition_title_open') {
      tokens[idx].attrPush(['class', `${prefix}-admonition-title`])
    }
    return self2.renderToken(tokens, idx, _options)
  }
  const validate = (params) => {
    const array = params.trim().split(' ', 2)
    title = ''
    type = array[0]
    if (array.length > 1) {
      title = params.substring(type.length + 2)
    }
  }
  md.block.ruler.before(
    'code',
    'admonition',
    (state, startLine, endLine, silent) => {
      let pos,
        nextLine,
        token,
        autoClosed = false,
        start = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine]
      if (markerChar !== state.src.charCodeAt(start)) {
        return false
      }
      for (pos = start + 1; pos <= max; pos++) {
        if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
          break
        }
      }
      const markerCount = Math.floor((pos - start) / markerLen)
      if (markerCount !== markers) {
        return false
      }
      pos -= (pos - start) % markerLen
      const markup = state.src.slice(start, pos)
      const params = state.src.slice(pos, max)
      validate(params)
      if (silent) {
        return true
      }
      nextLine = startLine
      for (;;) {
        nextLine++
        if (nextLine >= endLine) {
          break
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine]
        max = state.eMarks[nextLine]
        if (start < max && state.sCount[nextLine] < state.blkIndent) {
          break
        }
        if (markerChar !== state.src.charCodeAt(start)) {
          continue
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue
        }
        for (pos = start + 1; pos <= max; pos++) {
          if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
            break
          }
        }
        if (Math.floor((pos - start) / markerLen) < markerCount) {
          continue
        }
        pos -= (pos - start) % markerLen
        pos = state.skipSpaces(pos)
        if (pos < max) {
          continue
        }
        autoClosed = true
        break
      }
      const oldParent = state.parentType
      const oldLineMax = state.lineMax
      state.parentType = 'root'
      state.lineMax = nextLine
      token = state.push('admonition_open', 'div', 1)
      token.markup = markup
      token.block = true
      token.info = type
      token.map = [startLine, nextLine]
      if (title) {
        token = state.push('admonition_title_open', 'p', 1)
        token.markup = markup + ' ' + type
        token.map = [startLine, nextLine]
        token = state.push('inline', '', 0)
        token.content = title
        token.map = [startLine, state.line - 1]
        token.children = []
        token = state.push('admonition_title_close', 'p', -1)
        token.markup = markup + ' ' + type
      }
      state.md.block.tokenize(state, startLine + 1, nextLine)
      token = state.push('admonition_close', 'div', -1)
      token.markup = state.src.slice(start, pos)
      token.block = true
      state.parentType = oldParent
      state.lineMax = oldLineMax
      state.line = nextLine + (autoClosed ? 1 : 0)
      return true
    },
    {
      alt: ['paragraph', 'reference', 'blockquote', 'list']
    }
  )
  md.renderer.rules['admonition_open'] = render
  md.renderer.rules['admonition_title_open'] = render
  md.renderer.rules['admonition_title_close'] = render
  md.renderer.rules['admonition_close'] = render
}
const HeadingPlugin = (md, options) => {
  md.renderer.rules.heading_open = (tokens, idx) => {
    var _a2
    const token = tokens[idx]
    const text2 =
      ((_a2 = tokens[idx + 1].children) == null
        ? void 0
        : _a2.reduce((p, c) => {
            return (
              p + (['text', 'code_inline', 'math_inline'].includes(c.type) ? c.content || '' : '')
            )
          }, '')) || ''
    const level = token.markup.length
    options.headsRef.value.push({
      text: text2,
      level,
      line: token.map[0]
    })
    if (token.map && token.level === 0) {
      token.attrSet('id', options.mdHeadingId(text2, level, options.headsRef.value.length))
    }
    return md.renderer.renderToken(tokens, idx, options)
  }
  md.renderer.rules.heading_close = (tokens, idx, opts, _env, self2) => {
    return self2.renderToken(tokens, idx, opts)
  }
}
const codetabs = (md, _opts) => {
  const defaultRender = md.renderer.rules.fence,
    unescapeAll2 = md.utils.unescapeAll,
    re = /\[(\w*)(?::([\w ]*))?\]/,
    mandatoryRe = /::(open|close)/
  const getInfo = (token) => {
    return token.info ? unescapeAll2(token.info).trim() : ''
  }
  const getGroupAndTab = (token) => {
    const info = getInfo(token),
      [group = null, tab = ''] = (re.exec(info) || []).slice(1)
    return [group, tab]
  }
  const getLangName = (token) => {
    const info = getInfo(token)
    return info ? info.split(/(\s+)/g)[0] : ''
  }
  const getTagType = (token) => {
    const mandatory = token.info.match(mandatoryRe) || []
    const open =
      mandatory[1] === 'open' ||
      (mandatory[1] !== 'close' &&
        _opts.codeFoldable &&
        token.content.trim().split('\n').length < _opts.autoFoldThreshold)
    const tagContainer = mandatory[1] || _opts.codeFoldable ? 'details' : 'div',
      tagHeader = mandatory[1] || _opts.codeFoldable ? 'summary' : 'div'
    return { open, tagContainer, tagHeader }
  }
  const fenceGroup = (tokens, idx, options, env, slf) => {
    var _a2
    if (tokens[idx].hidden) {
      return ''
    }
    const codeCodeText =
      (_a2 = _opts.usedLanguageTextRef.value) == null ? void 0 : _a2.copyCode.text
    const copyBtnHtml = _opts.customIconRef.value.copy || codeCodeText
    const isIcon = !!_opts.customIconRef.value.copy
    const collapseTips = `<span class="${prefix}-collapse-tips">${StrIcon('collapse-tips', _opts.customIconRef.value)}</span>`
    const [GROUP] = getGroupAndTab(tokens[idx])
    if (GROUP === null) {
      const {
        open: open2,
        tagContainer: tagContainer2,
        tagHeader: tagHeader2
      } = getTagType(tokens[idx])
      const addAttrs2 = [['class', `${prefix}-code`]]
      if (open2) addAttrs2.push(['open', ''])
      const tmpToken2 = {
        attrs: mergeAttrs(tokens[idx], addAttrs2)
      }
      tokens[idx].info = tokens[idx].info.replace(mandatoryRe, '')
      const codeRendered = defaultRender(tokens, idx, options, env, slf)
      return `
        <${tagContainer2} ${slf.renderAttrs(tmpToken2)}>
          <${tagHeader2} class="${prefix}-code-head">
            <div class="${prefix}-code-flag"><span></span><span></span><span></span></div>
            <div class="${prefix}-code-action">
              <span class="${prefix}-code-lang">${md.utils.escapeHtml(tokens[idx].info.trim())}</span>
              <span class="${prefix}-copy-button" data-tips="${codeCodeText}"${isIcon ? ' data-is-icon=true' : ''}>${copyBtnHtml}</span>
              ${_opts.extraTools instanceof Function ? _opts.extraTools({ lang: tokens[idx].info.trim() }) : _opts.extraTools || ''}
              ${tagContainer2 === 'details' ? collapseTips : ''}
            </div>
          </${tagHeader2}>
          ${codeRendered}
        </${tagContainer2}>
      `
    }
    let token,
      group,
      tab,
      checked,
      labels = '',
      pres = '',
      langs = ''
    const { open, tagContainer, tagHeader } = getTagType(tokens[idx])
    const addAttrs = [['class', `${prefix}-code`]]
    if (open) addAttrs.push(['open', ''])
    const tmpToken = {
      attrs: mergeAttrs(tokens[idx], addAttrs)
    }
    for (let i = idx; i < tokens.length; i++) {
      token = tokens[i]
      ;[group, tab] = getGroupAndTab(token)
      if (group !== GROUP) {
        break
      }
      token.info = token.info.replace(re, '').replace(mandatoryRe, '')
      token.hidden = true
      const className = `${prefix}-codetab-${_opts.editorId}-${idx}-${i - idx}`
      checked = i - idx > 0 ? '' : 'checked'
      labels += `
        <li>
          <input
            type="radio"
            id="label-${prefix}-codetab-label-1-${_opts.editorId}-${idx}-${i - idx}"
            name="${prefix}-codetab-label-${_opts.editorId}-${idx}"
            class="${className}"
            ${checked}
          >
          <label
            for="label-${prefix}-codetab-label-1-${_opts.editorId}-${idx}-${i - idx}"
            onclick="this.getRootNode().querySelectorAll('.${className}').forEach(e => e.click())"
          >
            ${md.utils.escapeHtml(tab || getLangName(token))}
          </label>
        </li>`
      pres += `
        <div role="tabpanel">
          <input
            type="radio"
            name="${prefix}-codetab-pre-${_opts.editorId}-${idx}"
            class="${className}"
            ${checked}
            role="presentation">
          ${defaultRender(tokens, i, options, env, slf)}
        </div>`
      langs += `
        <input
          type="radio"
          name="${prefix}-codetab-lang-${_opts.editorId}-${idx}"
          class="${className}"
          ${checked}
          role="presentation">
        <span class=${prefix}-code-lang role="note">${md.utils.escapeHtml(getLangName(token))}</span>`
    }
    return `
      <${tagContainer} ${slf.renderAttrs(tmpToken)}>
        <${tagHeader} class="${prefix}-code-head">
          <div class="${prefix}-code-flag">
            <ul class="${prefix}-codetab-label" role="tablist">${labels}</ul>
          </div>
          <div class="${prefix}-code-action">
            <span class="${prefix}-codetab-lang">${langs}</span>
            <span class="${prefix}-copy-button" data-tips="${codeCodeText}"${isIcon ? ' data-is-icon=true' : ''}>${copyBtnHtml}</span>
            ${_opts.extraTools instanceof Function ? _opts.extraTools({ lang: tokens[idx].info.trim() }) : _opts.extraTools || ''}
            ${tagContainer === 'details' ? collapseTips : ''}
          </div>
        </${tagHeader}>
        ${pres}
      </${tagContainer}>
    `
  }
  md.renderer.rules.fence = fenceGroup
  md.renderer.rules.code_block = fenceGroup
}
const attrSet2 = (token, name2, value) => {
  const index2 = token.attrIndex(name2)
  const attr = [name2, value]
  if (index2 < 0) {
    token.attrPush(attr)
  } else {
    token.attrs = token.attrs || []
    token.attrs[index2] = attr
  }
}
const isInline = (token) => {
  return token.type === 'inline'
}
const isParagraph = (token) => {
  return token.type === 'paragraph_open'
}
const isListItem = (token) => {
  return token.type === 'list_item_open'
}
const startsWithTodoMarkdown = (token) => {
  return (
    token.content.indexOf('[ ] ') === 0 ||
    token.content.indexOf('[x] ') === 0 ||
    token.content.indexOf('[X] ') === 0
  )
}
const isTodoItem = (tokens, index2) => {
  return (
    isInline(tokens[index2]) &&
    isParagraph(tokens[index2 - 1]) &&
    isListItem(tokens[index2 - 2]) &&
    startsWithTodoMarkdown(tokens[index2])
  )
}
const parentToken = (tokens, index2) => {
  const targetLevel = tokens[index2].level - 1
  for (let i = index2 - 1; i >= 0; i--) {
    if (tokens[i].level === targetLevel) {
      return i
    }
  }
  return -1
}
const beginLabel = (TokenConstructor) => {
  const token = new TokenConstructor('html_inline', '', 0)
  token.content = '<label>'
  return token
}
const endLabel = (TokenConstructor) => {
  const token = new TokenConstructor('html_inline', '', 0)
  token.content = '</label>'
  return token
}
const afterLabel = (content2, id2, TokenConstructor) => {
  const token = new TokenConstructor('html_inline', '', 0)
  token.content = '<label class="task-list-item-label" for="' + id2 + '">' + content2 + '</label>'
  token.attrs = [{ for: id2 }]
  return token
}
const makeCheckbox = (token, TokenConstructor, options) => {
  const checkbox = new TokenConstructor('html_inline', '', 0)
  const disabledAttr = !options.enabled ? ' disabled="" ' : ' '
  if (token.content.indexOf('[ ] ') === 0) {
    checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">'
  } else if (token.content.indexOf('[x] ') === 0 || token.content.indexOf('[X] ') === 0) {
    checkbox.content =
      '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">'
  }
  return checkbox
}
const todoify = (token, TokenConstructor, options) => {
  token.children = token.children || []
  token.children.unshift(makeCheckbox(token, TokenConstructor, options))
  token.children[1].content = token.children[1].content.slice(3)
  token.content = token.content.slice(3)
  if (options.label) {
    if (options.labelAfter) {
      token.children.pop()
      const id2 = 'task-item-' + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3)
      token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id2 + '">'
      token.children.push(afterLabel(token.content, id2, TokenConstructor))
    } else {
      token.children.unshift(beginLabel(TokenConstructor))
      token.children.push(endLabel(TokenConstructor))
    }
  }
}
const githubTaskLists = (md, options = {}) => {
  md.core.ruler.after('inline', 'github-task-lists', (state) => {
    const tokens = state.tokens
    for (let i = 2; i < tokens.length; i++) {
      if (isTodoItem(tokens, i)) {
        todoify(tokens[i], state.Token, options)
        attrSet2(tokens[i - 2], 'class', 'task-list-item' + (options.enabled ? ' enabled' : ' '))
        attrSet2(tokens[parentToken(tokens, i - 2)], 'class', 'contains-task-list')
      }
    }
  })
}
const initLineNumber = (md) => {
  md.core.ruler.push('init-line-number', (state) => {
    state.tokens.forEach((token) => {
      if (token.map) {
        if (!token.attrs) {
          token.attrs = []
        }
        token.attrs.push(['data-line', token.map[0].toString()])
      }
    })
    return true
  })
}
const useMarkdownIt = (props2, previewOnly) => {
  const { editorConfig, markdownItPlugins, editorExtensions } = globalConfig
  const editorId = inject('editorId')
  const languageRef = inject('language')
  const usedLanguageTextRef = inject('usedLanguageText')
  const showCodeRowNumber = inject('showCodeRowNumber')
  const themeRef = inject('theme')
  const customIconRef = inject('customIcon')
  const rootRef = inject('rootRef')
  const headsRef = ref([])
  let clearMermaidEvents = () => {}
  const hljsRef = useHighlight(props2)
  const katexRef = useKatex(props2)
  const { reRenderRef, replaceMermaid } = useMermaid(props2)
  const md = MarkdownIt({
    html: true,
    breaks: true,
    linkify: true
  })
  const plugins = [
    {
      type: 'image',
      plugin: r,
      options: { figcaption: true, classes: 'md-zoom' }
    },
    {
      type: 'admonition',
      plugin: AdmonitionPlugin,
      options: {}
    },
    {
      type: 'taskList',
      plugin: githubTaskLists,
      options: {}
    },
    {
      type: 'heading',
      plugin: HeadingPlugin,
      options: { mdHeadingId: props2.mdHeadingId, headsRef }
    },
    {
      type: 'code',
      plugin: codetabs,
      options: {
        editorId,
        usedLanguageTextRef,
        // showCodeRowNumber,
        codeFoldable: props2.codeFoldable,
        autoFoldThreshold: props2.autoFoldThreshold,
        customIconRef
      }
    },
    {
      type: 'sub',
      plugin: sub_plugin,
      options: {}
    },
    {
      type: 'sup',
      plugin: sup_plugin,
      options: {}
    }
  ]
  if (!props2.noKatex) {
    plugins.push({
      type: 'katex',
      plugin: KatexPlugin,
      options: { katexRef }
    })
  }
  if (!props2.noMermaid) {
    plugins.push({
      type: 'mermaid',
      plugin: MermaidPlugin,
      options: { themeRef }
    })
  }
  markdownItPlugins(plugins, {
    editorId
  }).forEach((item) => {
    md.use(item.plugin, item.options)
  })
  const userDefHighlight = md.options.highlight
  md.set({
    highlight: (str, language2, attrs) => {
      if (userDefHighlight) {
        const result = userDefHighlight(str, language2, attrs)
        if (result) {
          return result
        }
      }
      let codeHtml
      if (!props2.noHighlight && hljsRef.value) {
        const hljsLang = hljsRef.value.getLanguage(language2)
        if (hljsLang) {
          codeHtml = hljsRef.value.highlight(str, {
            language: language2,
            ignoreIllegals: true
          }).value
        } else {
          codeHtml = hljsRef.value.highlightAuto(str).value
        }
      } else {
        codeHtml = md.utils.escapeHtml(str)
      }
      const codeSpan = showCodeRowNumber
        ? generateCodeRowNumber(codeHtml.replace(/^\n+|\n+$/g, ''), str.replace(/^\n+|\n+$/g, ''))
        : `<span class="${prefix}-code-block">${codeHtml.replace(/^\n+|\n+$/g, '')}</span>`
      return `<pre><code class="language-${language2}" language=${language2}>${codeSpan}</code></pre>`
    }
  })
  initLineNumber(md)
  const key = ref(`_article-key_${U()}`)
  const html2 = ref(
    props2.sanitize(
      md.render(props2.modelValue, {
        srcLines: props2.modelValue.split('\n')
      })
    )
  )
  const updatedTodo = () => {
    bus.emit(editorId, BUILD_FINISHED, html2.value)
    props2.onHtmlChanged(html2.value)
    props2.onGetCatalog(headsRef.value)
    bus.emit(editorId, CATALOG_CHANGED, headsRef.value)
    nextTick(() => {
      replaceMermaid().then(() => {
        var _a2, _b
        if ((_a2 = editorExtensions.mermaid) == null ? void 0 : _a2.enableZoom) {
          clearMermaidEvents()
          clearMermaidEvents = zoomMermaid(
            (_b = rootRef.value) == null
              ? void 0
              : _b.querySelectorAll(`#${editorId} p.${prefix}-mermaid:not([data-closed=false])`),
            {
              customIcon: customIconRef.value
            }
          )
        }
      })
    })
  }
  const markHtml = () => {
    headsRef.value = []
    html2.value = props2.sanitize(
      md.render(props2.modelValue, {
        srcLines: props2.modelValue.split('\n')
      })
    )
    updatedTodo()
  }
  const needReRender = computed(() => {
    return (props2.noKatex || katexRef.value) && (props2.noHighlight || hljsRef.value)
  })
  let timer = -1
  watch([toRef(props2, 'modelValue'), needReRender, reRenderRef, languageRef], () => {
    timer = window.setTimeout(
      () => {
        markHtml()
      },
      previewOnly ? 0 : editorConfig.renderDelay
    )
  })
  watch(
    () => props2.setting.preview,
    () => {
      if (props2.setting.preview) {
        nextTick(() => {
          replaceMermaid().then(() => {
            var _a2, _b
            if ((_a2 = editorExtensions.mermaid) == null ? void 0 : _a2.enableZoom) {
              clearMermaidEvents()
              clearMermaidEvents = zoomMermaid(
                (_b = rootRef.value) == null
                  ? void 0
                  : _b.querySelectorAll(
                      `#${editorId} p.${prefix}-mermaid:not([data-closed=false])`
                    ),
                {
                  customIcon: customIconRef.value
                }
              )
            }
          })
          bus.emit(editorId, CATALOG_CHANGED, headsRef.value)
        })
      }
    }
  )
  onMounted(updatedTodo)
  onMounted(() => {
    bus.on(editorId, {
      name: PUSH_CATALOG,
      callback() {
        bus.emit(editorId, CATALOG_CHANGED, headsRef.value)
      }
    })
    bus.on(editorId, {
      name: RERENDER,
      callback: () => {
        key.value = `_article-key_${U()}`
        markHtml()
      }
    })
  })
  onBeforeUnmount(() => {
    clearMermaidEvents()
    clearTimeout(timer)
  })
  return { html: html2, key }
}
const template = {
  checked: {
    regexp: /- \[x\]/,
    value: '- [ ]'
  },
  unChecked: {
    regexp: /- \[\s\]/,
    value: '- [x]'
  }
}
const useTaskState = (props2, html2) => {
  const editorId = inject('editorId')
  const rootRef = inject('rootRef')
  let removeListener = () => {}
  const addListener = () => {
    if (!rootRef.value) {
      return false
    }
    const tasks = rootRef.value.querySelectorAll('.task-list-item.enabled')
    const listener = (e2) => {
      var _a2
      e2.preventDefault()
      const nextValue = e2.target.checked ? 'unChecked' : 'checked'
      const line = (_a2 = e2.target.parentElement) == null ? void 0 : _a2.dataset.line
      if (!line) {
        return
      }
      const lineNumber = Number(line)
      const lines = props2.modelValue.split('\n')
      const targetValue = lines[Number(lineNumber)].replace(
        template[nextValue].regexp,
        template[nextValue].value
      )
      if (props2.previewOnly) {
        lines[Number(lineNumber)] = targetValue
        props2.onChange(lines.join('\n'))
      } else {
        bus.emit(editorId, TASK_STATE_CHANGED, lineNumber + 1, targetValue)
      }
    }
    tasks.forEach((item) => {
      item.addEventListener('click', listener)
    })
    removeListener = () => {
      tasks.forEach((item) => {
        item.removeEventListener('click', listener)
      })
    }
  }
  onBeforeUnmount(() => {
    removeListener()
  })
  watch(
    [html2],
    () => {
      removeListener()
      nextTick(addListener)
    },
    {
      immediate: true
    }
  )
}
const useRemount = (props2, html2, key) => {
  const handler = () => {
    nextTick(() => {
      var _a2
      ;(_a2 = props2.onRemount) == null ? void 0 : _a2.call(props2)
    })
  }
  const settingPreviewChanged = (nVal) => {
    if (nVal) {
      handler()
    }
  }
  watch([html2, key], handler)
  watch(() => props2.setting.preview, settingPreviewChanged)
  watch(() => props2.setting.htmlPreview, settingPreviewChanged)
  onMounted(handler)
}
const contentPreviewProps = {
  modelValue: {
    type: String,
    default: ''
  },
  onChange: {
    type: Function,
    default: () => {}
  },
  setting: {
    type: Object,
    default: () => ({ preview: true })
  },
  onHtmlChanged: {
    type: Function,
    default: () => {}
  },
  onGetCatalog: {
    type: Function,
    default: () => {}
  },
  mdHeadingId: {
    type: Function,
    default: () => ''
  },
  noMermaid: {
    type: Boolean,
    default: false
  },
  sanitize: {
    type: Function,
    default: (html2) => html2
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: false
  },
  formatCopiedText: {
    type: Function,
    default: (text2) => text2
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  previewOnly: {
    type: Boolean,
    default: false
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  },
  codeFoldable: {
    type: Boolean
  },
  autoFoldThreshold: {
    type: Number
  },
  onRemount: {
    type: Function
  }
}
const contentProps = {
  ...contentPreviewProps,
  updateModelValue: {
    type: Function,
    default: () => {}
  },
  placeholder: {
    type: String,
    default: ''
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {}
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {}
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: 'light'
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {}
  },
  inputBoxWidth: {
    type: String
  },
  oninputBoxWidthChange: {
    type: Function
  },
  transformImgUrl: {
    type: Function,
    default: (t2) => t2
  },
  catalogLayout: {
    type: String
  },
  catalogMaxDepth: {
    type: Number
  }
}
const splitNodes = (html2) => {
  const parser2 = new DOMParser()
  const doc2 = parser2.parseFromString(html2, 'text/html')
  return Array.from(doc2.body.childNodes)
}
const compareHtml = (newNodes, currentNodes) => {
  const updates = []
  const deletes = []
  newNodes.forEach((newNode, index2) => {
    const currentNode = currentNodes[index2]
    if (!currentNode) {
      updates.push({
        index: index2,
        newNode
      })
      return
    }
    if (
      newNode.nodeType !== currentNode.nodeType ||
      newNode.textContent !== currentNode.textContent ||
      (newNode.nodeType === 1 && newNode.outerHTML !== currentNode.outerHTML)
    ) {
      updates.push({
        index: index2,
        newNode
      })
    }
  })
  if (currentNodes.length > newNodes.length) {
    for (let i = newNodes.length; i < currentNodes.length; i++) {
      deletes.push(currentNodes[i])
    }
  }
  return {
    updates,
    deletes
  }
}
const UpdateOnDemand = /* @__PURE__ */ defineComponent({
  name: 'UpdateOnDemand',
  props: {
    html: {
      type: String,
      required: true
    }
  },
  setup(props2) {
    const editorId = inject('editorId')
    const previewTheme = inject('previewTheme')
    const showCodeRowNumber = inject('showCodeRowNumber')
    const htmlContainer = ref()
    const firstHtml = props2.html
    const updateHtmlContent = (updates, deletes) => {
      if (!htmlContainer.value) return
      deletes.forEach((node) => {
        node.remove()
      })
      updates.forEach(({ index: index2, newNode }) => {
        var _a2, _b, _c
        const targetNode = (_a2 = htmlContainer.value) == null ? void 0 : _a2.childNodes[index2]
        if (!targetNode) {
          ;(_b = htmlContainer.value) == null ? void 0 : _b.appendChild(newNode.cloneNode(true))
        } else {
          ;(_c = htmlContainer.value) == null
            ? void 0
            : _c.replaceChild(newNode.cloneNode(true), targetNode)
        }
      })
    }
    watch(
      () => props2.html,
      (newHtml) => {
        var _a2
        const newNodes = splitNodes(newHtml)
        const currentNodes = Array.from(
          ((_a2 = htmlContainer.value) == null ? void 0 : _a2.childNodes) || []
        )
        const { updates, deletes } = compareHtml(newNodes, currentNodes)
        updateHtmlContent(updates, deletes)
      }
    )
    return () =>
      createVNode(
        'div',
        {
          id: `${editorId}-preview`,
          class: [
            `${prefix}-preview`,
            `${previewTheme == null ? void 0 : previewTheme.value}-theme`,
            showCodeRowNumber && `${prefix}-scrn`
          ],
          innerHTML: firstHtml,
          ref: htmlContainer
        },
        null
      )
  }
})
const ContentPreview = /* @__PURE__ */ defineComponent({
  name: 'ContentPreview',
  props: contentPreviewProps,
  setup(props2) {
    const editorId = inject('editorId')
    const { html: html2, key } = useMarkdownIt(props2, props2.previewOnly)
    useCopyCode(props2, html2, key)
    userZoom(props2, html2)
    useTaskState(props2, html2)
    useRemount(props2, html2, key)
    return () => {
      return createVNode(Fragment, null, [
        props2.setting.preview &&
          createVNode(
            'div',
            {
              id: `${editorId}-preview-wrapper`,
              class: `${prefix}-preview-wrapper`,
              key: 'content-preview-wrapper'
            },
            [
              createVNode(
                UpdateOnDemand,
                {
                  key: key.value,
                  html: html2.value
                },
                null
              )
            ]
          ),
        !props2.previewOnly &&
          props2.setting.htmlPreview &&
          createVNode(
            'div',
            {
              id: `${editorId}-html-wrapper`,
              class: `${prefix}-preview-wrapper`,
              key: 'html-preview-wrapper'
            },
            [
              createVNode(
                'div',
                {
                  class: `${prefix}-html`
                },
                [html2.value]
              )
            ]
          )
      ])
    }
  }
})
const useOnSave = (props2, context, options) => {
  const { editorId } = options
  const state = reactive({
    // 是否已编译成html
    buildFinished: false,
    // 存储当前最新的html
    html: ''
  })
  watch(
    () => props2.modelValue,
    () => {
      state.buildFinished = false
    }
  )
  onMounted(() => {
    bus.on(editorId, {
      name: BUILD_FINISHED,
      callback(html2) {
        state.buildFinished = true
        state.html = html2
      }
    })
    bus.on(editorId, {
      name: ON_SAVE,
      callback() {
        const htmlPromise = new Promise((rev) => {
          if (state.buildFinished) {
            rev(state.html)
          } else {
            const buildFinishedCallback = (html2) => {
              rev(html2)
              bus.remove(editorId, BUILD_FINISHED, buildFinishedCallback)
            }
            bus.on(editorId, {
              name: BUILD_FINISHED,
              callback: buildFinishedCallback
            })
          }
        })
        if (props2.onSave) {
          props2.onSave(props2.modelValue, htmlPromise)
        } else {
          context.emit('onSave', props2.modelValue, htmlPromise)
        }
      }
    })
  })
}
const useProvidePreview = (props2, rootRef) => {
  const hljsUrls = globalConfig.editorExtensions.highlight
  const hljsAttrs = globalConfig.editorExtensionsAttrs.highlight
  const editorId = useEditorId(props2)
  provide('editorId', editorId)
  provide('rootRef', rootRef)
  provide(
    'theme',
    computed(() => props2.theme)
  )
  provide(
    'language',
    computed(() => props2.language)
  )
  provide(
    'highlight',
    computed(() => {
      const { js: jsUrl } = hljsUrls
      const cssList = {
        ...codeCss,
        ...hljsUrls.css
      }
      const { js: jsAttrs, css: cssAttrs = {} } = hljsAttrs || {}
      const _theme =
        props2.codeStyleReverse && props2.codeStyleReverseList.includes(props2.previewTheme)
          ? 'dark'
          : props2.theme
      const codeCssHref = cssList[props2.codeTheme]
        ? cssList[props2.codeTheme][_theme]
        : codeCss.atom[_theme]
      const codeCssAttrs =
        cssList[props2.codeTheme] && cssAttrs[props2.codeTheme]
          ? cssAttrs[props2.codeTheme][_theme]
          : cssAttrs['atom']
            ? cssAttrs['atom'][_theme]
            : {}
      return {
        js: {
          src: jsUrl,
          ...jsAttrs
        },
        css: {
          href: codeCssHref,
          ...codeCssAttrs
        }
      }
    })
  )
  provide('showCodeRowNumber', props2.showCodeRowNumber)
  const usedLanguageText = computed(() => {
    const allText = {
      ...staticTextDefault,
      ...globalConfig.editorConfig.languageUserDefined
    }
    return M(u(staticTextDefault['en-US']), allText[props2.language] || {})
  })
  provide('usedLanguageText', usedLanguageText)
  provide(
    'previewTheme',
    computed(() => props2.previewTheme)
  )
  provide(
    'customIcon',
    computed(() => props2.customIcon)
  )
  return { editorId }
}
const useProvide = (props2, rootRef) => {
  provide('tabWidth', props2.tabWidth)
  provide(
    'disabled',
    computed(() => props2.disabled)
  )
  return useProvidePreview(props2, rootRef)
}
const useExpansion = (props2) => {
  const { noPrettier, noUploadImg } = props2
  const { editorExtensions, editorExtensionsAttrs } = globalConfig
  const noPrettierScript = noPrettier || editorExtensions.prettier.prettierInstance
  const noParserMarkdownScript = noPrettier || editorExtensions.prettier.parserMarkdownInstance
  const noCropperScript = noUploadImg || editorExtensions.cropper.instance
  onMounted(() => {
    if (!noCropperScript) {
      const { js = {}, css: css2 = {} } = editorExtensionsAttrs.cropper || {}
      appendHandler('link', {
        ...css2,
        rel: 'stylesheet',
        href: editorExtensions.cropper.css,
        id: CDN_IDS.croppercss
      })
      appendHandler('script', {
        ...js,
        src: editorExtensions.cropper.js,
        id: CDN_IDS.cropperjs
      })
    }
    if (!noPrettierScript) {
      const { standaloneJs = {} } = editorExtensionsAttrs.prettier || {}
      appendHandler('script', {
        ...standaloneJs,
        src: editorExtensions.prettier.standaloneJs,
        id: CDN_IDS.prettier
      })
    }
    if (!noParserMarkdownScript) {
      const { parserMarkdownJs = {} } = editorExtensionsAttrs.prettier || {}
      appendHandler('script', {
        ...parserMarkdownJs,
        src: editorExtensions.prettier.parserMarkdownJs,
        id: CDN_IDS.prettierMD
      })
    }
  })
}
const useErrorCatcher = (props2, context, options) => {
  const { editorId } = options
  onMounted(() => {
    bus.on(editorId, {
      name: ERROR_CATCHER,
      callback: (err) => {
        var _a2
        ;(_a2 = props2.onError) == null ? void 0 : _a2.call(props2, err)
        context.emit('onError', err)
      }
    })
  })
}
const useConfig = (props2, context, options) => {
  const { editorId } = options
  const setting = reactive({
    pageFullscreen: props2.pageFullscreen,
    fullscreen: false,
    preview: props2.preview,
    htmlPreview: props2.preview ? false : props2.htmlPreview,
    previewOnly: false
  })
  const cacheSetting = reactive({ ...setting })
  const updateSetting = (k2, v) => {
    const realValue = v === void 0 ? !setting[k2] : v
    switch (k2) {
      case 'preview': {
        setting.htmlPreview = false
        setting.previewOnly = false
        break
      }
      case 'htmlPreview': {
        setting.preview = false
        setting.previewOnly = false
        break
      }
      case 'previewOnly': {
        if (realValue) {
          if (!setting.preview && !setting.htmlPreview) {
            setting.preview = true
          }
        } else {
          if (!cacheSetting.preview) {
            setting.preview = false
          }
          if (!cacheSetting.htmlPreview) {
            setting.htmlPreview = false
          }
        }
        break
      }
    }
    cacheSetting[k2] = realValue
    setting[k2] = realValue
  }
  let bodyOverflowHistory = ''
  const adjustBody = () => {
    if (setting.pageFullscreen || setting.fullscreen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = bodyOverflowHistory
    }
  }
  watch(() => [setting.pageFullscreen, setting.fullscreen], adjustBody)
  onMounted(() => {
    bus.on(editorId, {
      name: UPLOAD_IMAGE,
      callback(files, cb) {
        const insertHanlder = (urls) => {
          bus.emit(editorId, REPLACE, 'image', {
            desc: '',
            urls
          })
          cb == null ? void 0 : cb()
        }
        if (props2.onUploadImg) {
          props2.onUploadImg(files, insertHanlder)
        } else {
          context.emit('onUploadImg', files, insertHanlder)
        }
      }
    })
    bodyOverflowHistory = document.body.style.overflow
    adjustBody()
  })
  return [setting, updateSetting]
}
const useCatalog = (_props, options) => {
  const { editorId } = options
  const catalogShow = ref(false)
  onMounted(() => {
    bus.on(editorId, {
      name: CHANGE_CATALOG_VISIBLE,
      callback: (v) => {
        if (v === void 0) {
          catalogShow.value = !catalogShow.value
        } else {
          catalogShow.value = v
        }
      }
    })
  })
  return catalogShow
}
const useExpose$1 = (props2, ctx, options) => {
  const { editorId, catalogVisible, setting, updateSetting, codeRef } = options
  watch(
    () => setting.pageFullscreen,
    (newVal) => {
      bus.emit(editorId, PAGE_FULL_SCREEN_CHANGED, newVal)
    }
  )
  watch(
    () => setting.fullscreen,
    (newVal) => {
      bus.emit(editorId, FULL_SCREEN_CHANGED, newVal)
    }
  )
  watch(
    () => setting.preview,
    (newVal) => {
      bus.emit(editorId, PREVIEW_CHANGED, newVal)
    }
  )
  watch(
    () => setting.previewOnly,
    (newVal) => {
      bus.emit(editorId, PREVIEW_ONLY_CHANGED, newVal)
    }
  )
  watch(
    () => setting.htmlPreview,
    (newVal) => {
      bus.emit(editorId, HTML_PREVIEW_CHANGED, newVal)
    }
  )
  watch(catalogVisible, (newVal) => {
    bus.emit(editorId, CATALOG_VISIBLE_CHANGED, newVal)
  })
  const exposeParam = {
    on(eventName, callBack) {
      switch (eventName) {
        case 'pageFullscreen': {
          bus.on(editorId, {
            name: PAGE_FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
        case 'fullscreen': {
          bus.on(editorId, {
            name: FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
        case 'preview': {
          bus.on(editorId, {
            name: PREVIEW_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
        case 'previewOnly': {
          bus.on(editorId, {
            name: PREVIEW_ONLY_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
        case 'htmlPreview': {
          bus.on(editorId, {
            name: HTML_PREVIEW_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
        case 'catalog': {
          bus.on(editorId, {
            name: CATALOG_VISIBLE_CHANGED,
            callback(status) {
              callBack(status)
            }
          })
          break
        }
      }
    },
    togglePageFullscreen(status) {
      updateSetting('pageFullscreen', status)
    },
    toggleFullscreen(status) {
      bus.emit(editorId, CHANGE_FULL_SCREEN, status)
    },
    togglePreview(status) {
      updateSetting('preview', status)
    },
    togglePreviewOnly(status) {
      updateSetting('previewOnly', status)
    },
    toggleHtmlPreview(status) {
      updateSetting('htmlPreview', status)
    },
    toggleCatalog(status) {
      bus.emit(editorId, CHANGE_CATALOG_VISIBLE, status)
    },
    triggerSave() {
      bus.emit(editorId, ON_SAVE)
    },
    insert(generate) {
      bus.emit(editorId, REPLACE, 'universal', { generate })
    },
    focus(options2) {
      var _a2
      ;(_a2 = codeRef.value) == null ? void 0 : _a2.focus(options2)
    },
    rerender() {
      bus.emit(editorId, RERENDER)
    },
    getSelectedText() {
      var _a2
      return (_a2 = codeRef.value) == null ? void 0 : _a2.getSelectedText()
    },
    resetHistory() {
      var _a2
      ;(_a2 = codeRef.value) == null ? void 0 : _a2.resetHistory()
    },
    domEventHandlers(handlers2) {
      bus.emit(editorId, EVENT_LISTENER, handlers2)
    },
    execCommand(direct) {
      bus.emit(editorId, REPLACE, direct)
    },
    getEditorView() {
      var _a2
      return (_a2 = codeRef.value) == null ? void 0 : _a2.getEditorView()
    }
  }
  ctx.expose(exposeParam)
}
const useEditorId = (props2) => {
  const defaultId = useId()
  return props2.id || props2.editorId || `${prefix}-${defaultId}`
}
const mdHeadingId = (text2) => text2
const mdPreviewProps = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ''
  },
  /**
   * input回调事件
   */
  onChange: {
    type: Function,
    default: void 0
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: 'light'
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ''
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: 'zh-CN'
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function,
    default: void 0
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function,
    default: void 0
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   * @deprecated 5.x版本开始使用 id 替换
   */
  editorId: {
    type: String,
    default: void 0
  },
  /**
   * 5.x版本开始 editorId 的替换
   *
   * @default 'md-editor-v3'
   */
  id: {
    type: String,
    default: void 0
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default true
   */
  showCodeRowNumber: {
    type: Boolean,
    default: true
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: 'default'
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: mdHeadingId
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (html2) => html2
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: false
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: false
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: 'atom'
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (text2) => text2
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: true
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ['default', 'mk-cute']
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: false
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (h2) => Promise.resolve(h2)
  },
  /**
   * 是否开启折叠代码功能
   * 不开启会使用div标签替代details标签
   *
   * @default true
   */
  codeFoldable: {
    type: Boolean,
    default: true
  },
  /**
   * 触发自动折叠代码的行数阈值
   *
   * @default 30
   */
  autoFoldThreshold: {
    type: Number,
    default: 30
  },
  /**
   * 内容重新挂载事件
   *
   * 相比起onHtmlChanged，onRemount会在重新挂载后触发
   */
  onRemount: {
    type: Function,
    default: void 0
  }
}
const editorProps = {
  ...mdPreviewProps,
  /**
   * input回调事件
   */
  onSave: {
    type: Function,
    default: void 0
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function,
    default: void 0
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: false
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: true
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: false
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: allToolbar
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: false
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * 也可以是[6, 4, 10, 8]
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ''
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function,
    default: void 0
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: allFooter
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: true
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean,
    default: false
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number,
    default: void 0
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean,
    default: false
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: void 0
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array,
    default: void 0
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: false
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function,
    default: void 0
  },
  onDrop: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWidth: {
    type: String,
    default: '50%'
  },
  /**
   * 输入框宽度变化事件
   */
  oninputBoxWidthChange: {
    type: Function,
    default: void 0
  },
  /**
   * 替换粘贴的图片链接
   *
   * @param t 图片链接
   * @returns
   */
  transformImgUrl: {
    type: Function,
    default: (t2) => t2
  },
  /**
   * 内置的目录显示的状态
   *
   * 'fixed': 悬浮在内容上方
   * 'flat': 展示在右侧
   *
   * \>=5.3.0
   *
   * @default 'fixed'
   */
  catalogLayout: {
    type: String,
    default: 'fixed'
  },
  /**
   * 控制最大显示的目录层级
   */
  catalogMaxDepth: {
    type: Number,
    default: void 0
  },
  /**
   * 工具栏直接插入内容到输入框
   */
  insertLinkDirect: {
    type: Boolean,
    default: false
  }
}
const mdPreviewEmits = [
  'onHtmlChanged',
  'onGetCatalog',
  'onChange',
  'onRemount',
  'update:modelValue'
]
const editorEmits = [
  ...mdPreviewEmits,
  'onSave',
  'onUploadImg',
  'onError',
  'onBlur',
  'onFocus',
  'onInput',
  'onDrop',
  'oninputBoxWidthChange'
]
const useExpose = (props2, ctx, options) => {
  const { editorId } = options
  const exposeParam = {
    rerender() {
      bus.emit(editorId, RERENDER)
    }
  }
  ctx.expose(exposeParam)
}
const MdPreview = /* @__PURE__ */ defineComponent({
  name: 'MdPreview',
  props: mdPreviewProps,
  emits: mdPreviewEmits,
  setup(props2, ctx) {
    const { noKatex, noMermaid, noHighlight } = props2
    const rootRef = ref()
    const { editorId } = useProvidePreview(props2, rootRef)
    useExpose(props2, ctx, {
      editorId
    })
    onBeforeUnmount(() => {
      bus.clear(editorId)
    })
    return () => {
      return createVNode(
        'div',
        {
          id: editorId,
          class: [
            prefix,
            props2.class,
            props2.theme === 'dark' && `${prefix}-dark`,
            `${prefix}-previewOnly`
          ],
          style: props2.style,
          ref: rootRef
        },
        [
          createVNode(
            ContentPreview,
            {
              modelValue: props2.modelValue,
              onChange: (value) => {
                var _a2
                ;(_a2 = props2.onChange) == null ? void 0 : _a2.call(props2, value)
                ctx.emit('onChange', value)
                ctx.emit('update:modelValue', value)
              },
              onHtmlChanged: (html2) => {
                var _a2
                ;(_a2 = props2.onHtmlChanged) == null ? void 0 : _a2.call(props2, html2)
                ctx.emit('onHtmlChanged', html2)
              },
              onGetCatalog: (list2) => {
                var _a2
                ;(_a2 = props2.onGetCatalog) == null ? void 0 : _a2.call(props2, list2)
                ctx.emit('onGetCatalog', list2)
              },
              mdHeadingId: props2.mdHeadingId,
              noMermaid: noMermaid,
              sanitize: props2.sanitize,
              noKatex: noKatex,
              formatCopiedText: props2.formatCopiedText,
              noHighlight: noHighlight,
              noImgZoomIn: props2.noImgZoomIn,
              previewOnly: true,
              sanitizeMermaid: props2.sanitizeMermaid,
              codeFoldable: props2.codeFoldable,
              autoFoldThreshold: props2.autoFoldThreshold,
              onRemount: () => {
                var _a2
                ;(_a2 = props2.onRemount) == null ? void 0 : _a2.call(props2)
                ctx.emit('onRemount')
              }
            },
            null
          )
        ]
      )
    }
  }
})
MdPreview.install = (app) => {
  app.component(MdPreview.name, MdPreview)
  return app
}
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: 'http://www.w3.org/2000/svg',
  width: 24,
  height: 24,
  viewBox: '0 0 24 24',
  fill: 'none',
  stroke: 'currentColor',
  'stroke-width': 2,
  'stroke-linecap': 'round',
  'stroke-linejoin': 'round'
}
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon$2 = (
  {
    size,
    strokeWidth = 2,
    absoluteStrokeWidth,
    color,
    iconNode,
    name: name2,
    class: classes,
    ...props2
  },
  { slots }
) => {
  return h(
    'svg',
    {
      ...defaultAttributes,
      width: size || defaultAttributes.width,
      height: size || defaultAttributes.height,
      stroke: color || defaultAttributes.stroke,
      'stroke-width': absoluteStrokeWidth ? (Number(strokeWidth) * 24) / Number(size) : strokeWidth,
      class: ['lucide', `lucide-${toKebabCase(name2 ?? 'icon')}`],
      ...props2
    },
    [...iconNode.map((child) => h(...child)), ...(slots.default ? [slots.default()] : [])]
  )
}
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon =
  (iconName, iconNode) =>
  (props2, { slots }) =>
    h(
      Icon$2,
      {
        ...props2,
        iconNode,
        name: iconName
      },
      slots
    )
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bold = createLucideIcon('BoldIcon', [
  [
    'path',
    { d: 'M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8', key: 'mg9rjx' }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChartArea = createLucideIcon('ChartAreaIcon', [
  ['path', { d: 'M3 3v16a2 2 0 0 0 2 2h16', key: 'c24i48' }],
  [
    'path',
    {
      d: 'M7 11.207a.5.5 0 0 1 .146-.353l2-2a.5.5 0 0 1 .708 0l3.292 3.292a.5.5 0 0 0 .708 0l4.292-4.292a.5.5 0 0 1 .854.353V16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z',
      key: 'q0gr47'
    }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CodeXml = createLucideIcon('CodeXmlIcon', [
  ['path', { d: 'm18 16 4-4-4-4', key: '1inbqp' }],
  ['path', { d: 'm6 8-4 4 4 4', key: '15zrgr' }],
  ['path', { d: 'm14.5 4-5 16', key: 'e7oirm' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Code = createLucideIcon('CodeIcon', [
  ['polyline', { points: '16 18 22 12 16 6', key: 'z7tu5w' }],
  ['polyline', { points: '8 6 2 12 8 18', key: '1eg1df' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Expand = createLucideIcon('ExpandIcon', [
  ['path', { d: 'm21 21-6-6m6 6v-4.8m0 4.8h-4.8', key: '1c15vz' }],
  ['path', { d: 'M3 16.2V21m0 0h4.8M3 21l6-6', key: '1fsnz2' }],
  ['path', { d: 'M21 7.8V3m0 0h-4.8M21 3l-6 6', key: 'hawz9i' }],
  ['path', { d: 'M3 7.8V3m0 0h4.8M3 3l6 6', key: 'u9ee12' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eye = createLucideIcon('EyeIcon', [
  [
    'path',
    {
      d: 'M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0',
      key: '1nclc0'
    }
  ],
  ['circle', { cx: '12', cy: '12', r: '3', key: '1v7zrd' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Forward = createLucideIcon('ForwardIcon', [
  ['polyline', { points: '15 17 20 12 15 7', key: '1w3sku' }],
  ['path', { d: 'M4 18v-2a4 4 0 0 1 4-4h12', key: 'jmiej9' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Heading = createLucideIcon('HeadingIcon', [
  ['path', { d: 'M6 12h12', key: '8npq4p' }],
  ['path', { d: 'M6 20V4', key: '1w1bmo' }],
  ['path', { d: 'M18 20V4', key: 'o2hl4u' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Image = createLucideIcon('ImageIcon', [
  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', ry: '2', key: '1m3agn' }],
  ['circle', { cx: '9', cy: '9', r: '2', key: 'af1f0g' }],
  ['path', { d: 'm21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21', key: '1xmnt7' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Italic = createLucideIcon('ItalicIcon', [
  ['line', { x1: '19', x2: '10', y1: '4', y2: '4', key: '15jd3p' }],
  ['line', { x1: '14', x2: '5', y1: '20', y2: '20', key: 'bu0au3' }],
  ['line', { x1: '15', x2: '9', y1: '4', y2: '20', key: 'uljnxc' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Link = createLucideIcon('LinkIcon', [
  ['path', { d: 'M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71', key: '1cjeqo' }],
  ['path', { d: 'M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71', key: '19qd67' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ListOrdered = createLucideIcon('ListOrderedIcon', [
  ['path', { d: 'M10 12h11', key: '6m4ad9' }],
  ['path', { d: 'M10 18h11', key: '11hvi2' }],
  ['path', { d: 'M10 6h11', key: 'c7qv1k' }],
  ['path', { d: 'M4 10h2', key: '16xx2s' }],
  ['path', { d: 'M4 6h1v4', key: 'cnovpq' }],
  ['path', { d: 'M6 18H4c0-1 2-2 2-3s-1-1.5-2-1', key: 'm9a95d' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ListTodo = createLucideIcon('ListTodoIcon', [
  ['rect', { x: '3', y: '5', width: '6', height: '6', rx: '1', key: '1defrl' }],
  ['path', { d: 'm3 17 2 2 4-4', key: '1jhpwq' }],
  ['path', { d: 'M13 6h8', key: '15sg57' }],
  ['path', { d: 'M13 12h8', key: 'h98zly' }],
  ['path', { d: 'M13 18h8', key: 'oe0vm4' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ListTree = createLucideIcon('ListTreeIcon', [
  ['path', { d: 'M21 12h-8', key: '1bmf0i' }],
  ['path', { d: 'M21 6H8', key: '1pqkrb' }],
  ['path', { d: 'M21 18h-8', key: '1tm79t' }],
  ['path', { d: 'M3 6v4c0 1.1.9 2 2 2h3', key: '1ywdgy' }],
  ['path', { d: 'M3 10v6c0 1.1.9 2 2 2h3', key: '2wc746' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const List = createLucideIcon('ListIcon', [
  ['path', { d: 'M3 12h.01', key: 'nlz23k' }],
  ['path', { d: 'M3 18h.01', key: '1tta3j' }],
  ['path', { d: 'M3 6h.01', key: '1rqtza' }],
  ['path', { d: 'M8 12h13', key: '1za7za' }],
  ['path', { d: 'M8 18h13', key: '1lx6n3' }],
  ['path', { d: 'M8 6h13', key: 'ik3vkj' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Maximize2 = createLucideIcon('Maximize2Icon', [
  ['polyline', { points: '15 3 21 3 21 9', key: 'mznyad' }],
  ['polyline', { points: '9 21 3 21 3 15', key: '1avn1i' }],
  ['line', { x1: '21', x2: '14', y1: '3', y2: '10', key: 'ota7mn' }],
  ['line', { x1: '3', x2: '10', y1: '21', y2: '14', key: '1atl0r' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Minimize2 = createLucideIcon('Minimize2Icon', [
  ['polyline', { points: '4 14 10 14 10 20', key: '11kfnr' }],
  ['polyline', { points: '20 10 14 10 14 4', key: 'rlmsce' }],
  ['line', { x1: '14', x2: '21', y1: '10', y2: '3', key: 'o5lafz' }],
  ['line', { x1: '3', x2: '10', y1: '21', y2: '14', key: '1atl0r' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Quote = createLucideIcon('QuoteIcon', [
  [
    'path',
    {
      d: 'M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z',
      key: 'rib7q0'
    }
  ],
  [
    'path',
    {
      d: 'M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z',
      key: '1ymkrd'
    }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Reply = createLucideIcon('ReplyIcon', [
  ['polyline', { points: '9 17 4 12 9 7', key: 'hvgpf2' }],
  ['path', { d: 'M20 18v-2a4 4 0 0 0-4-4H4', key: '5vmcpk' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Save = createLucideIcon('SaveIcon', [
  [
    'path',
    {
      d: 'M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z',
      key: '1c8476'
    }
  ],
  ['path', { d: 'M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7', key: '1ydtos' }],
  ['path', { d: 'M7 3v4a1 1 0 0 0 1 1h7', key: 't51u73' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Shrink = createLucideIcon('ShrinkIcon', [
  ['path', { d: 'm15 15 6 6m-6-6v4.8m0-4.8h4.8', key: '17vawe' }],
  ['path', { d: 'M9 19.8V15m0 0H4.2M9 15l-6 6', key: 'chjx8e' }],
  ['path', { d: 'M15 4.2V9m0 0h4.8M15 9l6-6', key: 'lav6yq' }],
  ['path', { d: 'M9 4.2V9m0 0H4.2M9 9 3 3', key: '1pxi2q' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SquareCode = createLucideIcon('SquareCodeIcon', [
  ['path', { d: 'M10 9.5 8 12l2 2.5', key: '3mjy60' }],
  ['path', { d: 'm14 9.5 2 2.5-2 2.5', key: '1bir2l' }],
  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SquareSigma = createLucideIcon('SquareSigmaIcon', [
  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],
  ['path', { d: 'M16 8.9V7H8l4 5-4 5h8v-1.9', key: '9nih0i' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Strikethrough$1 = createLucideIcon('StrikethroughIcon', [
  ['path', { d: 'M16 4H9a3 3 0 0 0-2.83 4', key: '43sutm' }],
  ['path', { d: 'M14 12a4 4 0 0 1 0 8H6', key: 'nlfj13' }],
  ['line', { x1: '4', x2: '20', y1: '12', y2: '12', key: '1e0a9i' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Subscript$1 = createLucideIcon('SubscriptIcon', [
  ['path', { d: 'm4 5 8 8', key: '1eunvl' }],
  ['path', { d: 'm12 5-8 8', key: '1ah0jp' }],
  [
    'path',
    {
      d: 'M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07',
      key: 'e8ta8j'
    }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Superscript$1 = createLucideIcon('SuperscriptIcon', [
  ['path', { d: 'm4 19 8-8', key: 'hr47gm' }],
  ['path', { d: 'm12 19-8-8', key: '1dhhmo' }],
  [
    'path',
    {
      d: 'M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06',
      key: '1dfcux'
    }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Table$1 = createLucideIcon('TableIcon', [
  ['path', { d: 'M12 3v18', key: '108xh3' }],
  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],
  ['path', { d: 'M3 9h18', key: '1pudct' }],
  ['path', { d: 'M3 15h18', key: '5xshup' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash2 = createLucideIcon('Trash2Icon', [
  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],
  ['path', { d: 'M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6', key: '4alrt4' }],
  ['path', { d: 'M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2', key: 'v07s0e' }],
  ['line', { x1: '10', x2: '10', y1: '11', y2: '17', key: '1uufr5' }],
  ['line', { x1: '14', x2: '14', y1: '11', y2: '17', key: 'xtxkd' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Underline = createLucideIcon('UnderlineIcon', [
  ['path', { d: 'M6 4v6a6 6 0 0 0 12 0V4', key: '9kb039' }],
  ['line', { x1: '4', x2: '20', y1: '20', y2: '20', key: 'nun2al' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Upload = createLucideIcon('UploadIcon', [
  ['path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4', key: 'ih7n3h' }],
  ['polyline', { points: '17 8 12 3 7 8', key: 't8dd8p' }],
  ['line', { x1: '12', x2: '12', y1: '3', y2: '15', key: 'widbto' }]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const View = createLucideIcon('ViewIcon', [
  ['path', { d: 'M21 17v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2', key: 'mrq65r' }],
  ['path', { d: 'M21 7V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2', key: 'be3xqs' }],
  ['circle', { cx: '12', cy: '12', r: '1', key: '41hilf' }],
  [
    'path',
    {
      d: 'M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0',
      key: '11ak4c'
    }
  ]
])
/**
 * @license lucide-vue-next v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon('XIcon', [
  ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],
  ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }]
])
const Github = () =>
  createVNode(
    'svg',
    {
      xmlns: 'http://www.w3.org/2000/svg',
      viewBox: '0 0 24 24',
      fill: 'none',
      stroke: 'currentColor',
      'stroke-width': '2',
      'stroke-linecap': 'round',
      'stroke-linejoin': 'round',
      class: 'lucide lucide-github-icon'
    },
    [
      createVNode(
        'path',
        {
          d: 'M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4'
        },
        null
      ),
      createVNode(
        'path',
        {
          d: 'M9 18c-4.51 2-5-2-7-2'
        },
        null
      )
    ]
  )
const iconMaps = {
  bold: Bold,
  underline: Underline,
  italic: Italic,
  'strike-through': Strikethrough$1,
  title: Heading,
  sub: Subscript$1,
  sup: Superscript$1,
  quote: Quote,
  'unordered-list': List,
  'ordered-list': ListOrdered,
  task: ListTodo,
  'code-row': Code,
  code: SquareCode,
  link: Link,
  image: Image,
  table: Table$1,
  revoke: Reply,
  next: Forward,
  save: Save,
  prettier: SquareCode,
  minimize: Minimize2,
  maximize: Maximize2,
  'fullscreen-exit': Shrink,
  fullscreen: Expand,
  'preview-only': View,
  preview: Eye,
  'preview-html': CodeXml,
  catalog: ListTree,
  github: Github,
  mermaid: ChartArea,
  formula: SquareSigma,
  close: X,
  delete: Trash2,
  upload: Upload
}
const Icon$1 = /* @__PURE__ */ defineComponent({
  name: `${prefix}-icon-set`,
  props: {
    name: {
      type: String,
      default: ''
    }
  },
  setup(props2) {
    return () => {
      return h(iconMaps[props2.name], {
        class: `${prefix}-icon`
      })
    }
  }
})
const Icon = /* @__PURE__ */ defineComponent({
  name: `${prefix}-icon`,
  props: {
    name: {
      type: String,
      default: ''
    }
  },
  setup(props2) {
    const customIcon = inject('customIcon')
    return () => {
      const item = customIcon.value[props2.name]
      if (typeof item === 'object') {
        return typeof item.component === 'object'
          ? h(item.component, item.props)
          : createVNode(
              'span',
              {
                innerHTML: item.component
              },
              null
            )
      }
      return createVNode(
        Icon$1,
        {
          name: props2.name
        },
        null
      )
    }
  }
})
const props$b = {
  title: {
    type: [String, Object],
    default: ''
  },
  visible: {
    type: Boolean,
    default: false
  },
  width: {
    type: String,
    default: 'auto'
  },
  height: {
    type: String,
    default: 'auto'
  },
  onClose: {
    type: Function
  },
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function,
    default: () => {}
  },
  class: {
    type: String,
    default: void 0
  },
  style: {
    type: [Object, String],
    default: () => ({})
  },
  showMask: {
    type: Boolean,
    default: true
  }
}
const MdModal = /* @__PURE__ */ defineComponent({
  name: 'MdModal',
  props: props$b,
  emits: ['onClose'],
  setup(props2, ctx) {
    const themeRef = inject('theme')
    const rootRef = inject('rootRef')
    const modalVisible = ref(props2.visible)
    const modalClass = ref([`${prefix}-modal`])
    const modalRef = ref()
    const modalHeaderRef = ref()
    const bodyRef = ref()
    const containerRef = shallowRef()
    let keyMoveClear = () => {}
    const state = reactive({
      maskStyle: {
        zIndex: -1
      },
      modalStyle: {
        zIndex: -1
      },
      initPos: {
        left: '0px',
        top: '0px'
      },
      historyPos: {
        left: '0px',
        top: '0px'
      }
    })
    const innerSize = computed(() => {
      if (props2.isFullscreen) {
        return {
          width: '100%',
          height: '100%'
        }
      } else {
        return {
          width: props2.width,
          height: props2.height
        }
      }
    })
    watch(
      () => props2.isFullscreen,
      (nVal) => {
        if (nVal) {
          keyMoveClear()
        } else {
          nextTick(() => {
            keyMoveClear = keyMove(modalHeaderRef.value, (left, top2) => {
              state.initPos.left = left + 'px'
              state.initPos.top = top2 + 'px'
            })
          })
        }
      }
    )
    watch(
      () => props2.visible,
      (nVal) => {
        if (nVal) {
          state.maskStyle.zIndex = globalConfig.editorConfig.zIndex + getZIndexIncrement()
          state.modalStyle.zIndex = globalConfig.editorConfig.zIndex + getZIndexIncrement()
          modalClass.value.push('zoom-in')
          modalVisible.value = nVal
          nextTick(() => {
            const halfWidth = modalRef.value.offsetWidth / 2
            const halfHeight = modalRef.value.offsetHeight / 2
            const halfClientWidth = document.documentElement.clientWidth / 2
            const halfClientHeight = document.documentElement.clientHeight / 2
            state.initPos.left = halfClientWidth - halfWidth + 'px'
            state.initPos.top = halfClientHeight - halfHeight + 'px'
            if (!props2.isFullscreen) {
              keyMoveClear = keyMove(modalHeaderRef.value, (left, top2) => {
                state.initPos.left = left + 'px'
                state.initPos.top = top2 + 'px'
              })
            }
          })
          setTimeout(() => {
            modalClass.value = modalClass.value.filter((item) => item !== 'zoom-in')
          }, 140)
        } else {
          modalClass.value.push('zoom-out')
          keyMoveClear()
          setTimeout(() => {
            modalClass.value = modalClass.value.filter((item) => item !== 'zoom-out')
            modalVisible.value = nVal
          }, 130)
        }
      }
    )
    const internalStyle = computed(() => ({
      display: modalVisible.value ? 'block' : 'none'
    }))
    const combinedStyle = computed(() => {
      if (typeof props2.style === 'string') {
        return [props2.style, internalStyle.value].join('; ')
      } else if (props2.style instanceof Object) {
        return {
          ...internalStyle.value,
          ...props2.style
        }
      } else {
        return internalStyle.value
      }
    })
    onMounted(() => {
      var _a2
      const rootNode = (_a2 = rootRef.value) == null ? void 0 : _a2.getRootNode()
      bodyRef.value = rootNode instanceof Document ? document.body : rootNode
    })
    return () => {
      const slotDefault = getSlot({
        ctx
      })
      const slotTitle = getSlot(
        {
          props: props2,
          ctx
        },
        'title'
      )
      return bodyRef.value
        ? createVNode(
            Teleport,
            {
              to: bodyRef.value
            },
            {
              default: () => [
                createVNode(
                  'div',
                  {
                    ref: containerRef,
                    class: `${prefix}-modal-container`,
                    'data-theme': themeRef.value
                  },
                  [
                    createVNode(
                      'div',
                      {
                        class: props2.class,
                        style: combinedStyle.value
                      },
                      [
                        props2.showMask &&
                          createVNode(
                            'div',
                            {
                              class: `${prefix}-modal-mask`,
                              style: state.maskStyle,
                              onClick: () => {
                                var _a2
                                ;(_a2 = props2.onClose) == null ? void 0 : _a2.call(props2)
                                ctx.emit('onClose')
                              }
                            },
                            null
                          ),
                        createVNode(
                          'div',
                          {
                            class: modalClass.value,
                            style: {
                              ...state.modalStyle,
                              ...state.initPos,
                              ...innerSize.value
                            },
                            ref: modalRef
                          },
                          [
                            createVNode(
                              'div',
                              {
                                class: `${prefix}-modal-header`,
                                ref: modalHeaderRef
                              },
                              [slotTitle || '']
                            ),
                            createVNode(
                              'div',
                              {
                                class: `${prefix}-modal-body`
                              },
                              [slotDefault]
                            ),
                            createVNode(
                              'div',
                              {
                                class: `${prefix}-modal-func`
                              },
                              [
                                props2.showAdjust &&
                                  createVNode(
                                    'div',
                                    {
                                      class: `${prefix}-modal-adjust`,
                                      onClick: (e2) => {
                                        e2.stopPropagation()
                                        if (!props2.isFullscreen) {
                                          state.historyPos = state.initPos
                                          state.initPos = {
                                            left: '0',
                                            top: '0'
                                          }
                                        } else {
                                          state.initPos = state.historyPos
                                        }
                                        props2.onAdjust(!props2.isFullscreen)
                                      }
                                    },
                                    [
                                      createVNode(
                                        Icon,
                                        {
                                          name: props2.isFullscreen ? 'minimize' : 'maximize'
                                        },
                                        null
                                      )
                                    ]
                                  ),
                                createVNode(
                                  'div',
                                  {
                                    class: `${prefix}-modal-close`,
                                    onClick: (e2) => {
                                      var _a2
                                      e2.stopPropagation()
                                      ;(_a2 = props2.onClose) == null ? void 0 : _a2.call(props2)
                                      ctx.emit('onClose')
                                    }
                                  },
                                  [
                                    createVNode(
                                      Icon,
                                      {
                                        name: 'close'
                                      },
                                      null
                                    )
                                  ]
                                )
                              ]
                            )
                          ]
                        )
                      ]
                    )
                  ]
                )
              ]
            }
          )
        : ''
    }
  }
})
MdModal.install = (app) => {
  app.component(MdModal.name, MdModal)
  return app
}
const DATA_LINE_SELECTOR = `.${prefix}-preview > [data-line]`
const getComputedStyleNum = (ele, key) => {
  return +getComputedStyle(ele).getPropertyValue(key).replace('px', '')
}
const scrollAutoWithScale = (pEle, cEle) => {
  const addEvent = k(() => {
    pEle.removeEventListener('scroll', scrollHandler2)
    pEle.addEventListener('scroll', scrollHandler2)
    cEle.removeEventListener('scroll', scrollHandler2)
    cEle.addEventListener('scroll', scrollHandler2)
  }, 50)
  const scrollHandler2 = (e2) => {
    const pHeight = pEle.clientHeight
    const cHeight = cEle.clientHeight
    const pScrollHeight = pEle.scrollHeight
    const cScrollHeight = cEle.scrollHeight
    const scale = (pScrollHeight - pHeight) / (cScrollHeight - cHeight)
    if (e2.target === pEle) {
      cEle.removeEventListener('scroll', scrollHandler2)
      cEle.scrollTo({
        top: pEle.scrollTop / scale
        // behavior: 'smooth'
      })
      addEvent()
    } else {
      pEle.removeEventListener('scroll', scrollHandler2)
      pEle.scrollTo({
        top: cEle.scrollTop * scale
        // behavior: 'smooth'
      })
      addEvent()
    }
  }
  return [
    () => {
      addEvent().finally(() => {
        pEle.dispatchEvent(new Event('scroll'))
      })
    },
    () => {
      pEle.removeEventListener('scroll', scrollHandler2)
      cEle.removeEventListener('scroll', scrollHandler2)
    }
  ]
}
const scrollAuto = (pEle, cEle, codeMirrorUt) => {
  const { view } = codeMirrorUt
  const smoothScroll2 = x()
  const getTopByLine = (line) => {
    return view.lineBlockAt(view.state.doc.line(line + 1).from).top
  }
  const getBottomByLine = (line) => {
    return view.lineBlockAt(view.state.doc.line(line + 1).from).bottom
  }
  let blockMap = []
  let elesHasLineNumber = []
  let startLines = []
  const buildMap = () => {
    blockMap = []
    elesHasLineNumber = Array.from(cEle.querySelectorAll(DATA_LINE_SELECTOR))
    startLines = elesHasLineNumber.map((item) => Number(item.dataset.line))
    const tempStartLines = [...startLines]
    const { lines } = view.state.doc
    let start = tempStartLines.shift() || 0
    let end = tempStartLines.shift() || lines
    for (let i = 0; i < lines; i++) {
      if (i === end) {
        start = i
        end = tempStartLines.shift() || lines
      }
      blockMap.push({
        start,
        end: end - 1
      })
    }
  }
  const getLineNumber = (pMaxScrollLength, cMaxScrollLength) => {
    let lineNumer = 1
    for (let i = elesHasLineNumber.length - 1; i - 1 >= 0; i--) {
      const curr = elesHasLineNumber[i]
      const sibling = elesHasLineNumber[i - 1]
      if (
        curr.offsetTop + curr.offsetHeight > cMaxScrollLength &&
        sibling.offsetTop < cMaxScrollLength
      ) {
        lineNumer = Number(sibling.dataset.line)
        break
      }
    }
    for (let i = blockMap.length - 1; i >= 0; i--) {
      const itemBottom = getBottomByLine(blockMap[i].end)
      const itemTop = getTopByLine(blockMap[i].start)
      if (itemBottom > pMaxScrollLength && itemTop <= pMaxScrollLength) {
        lineNumer = lineNumer < blockMap[i].start ? lineNumer : blockMap[i].start
        break
      }
    }
    return lineNumer
  }
  let pLock = 0
  let cLock = 0
  const pEleHandler = () => {
    var _a2, _b, _c
    if (cLock !== 0) {
      return false
    }
    pLock++
    const { scrollDOM, contentHeight } = view
    let cElePaddingTop = getComputedStyleNum(cEle, 'padding-top')
    const blockInfo = view.lineBlockAtHeight(scrollDOM.scrollTop)
    const { number: currLine } = view.state.doc.lineAt(blockInfo.from)
    const blockData = blockMap[currLine - 1]
    if (!blockData) {
      return false
    }
    let scale = 1
    const startEle =
      cEle.querySelector(`[data-line="${blockData.start}"]`) ||
      ((_a2 = cEle.firstElementChild) == null ? void 0 : _a2.firstElementChild)
    const endEle =
      cEle.querySelector(`[data-line="${blockData.end + 1}"]`) ||
      ((_b = cEle.lastElementChild) == null ? void 0 : _b.lastElementChild)
    const pMaxScrollLength = scrollDOM.scrollHeight - scrollDOM.clientHeight
    const cMaxScrollLength = cEle.scrollHeight - cEle.clientHeight
    let startTop = getTopByLine(blockData.start)
    let endBottom = getBottomByLine(blockData.end)
    let startEleOffetTop = startEle.offsetTop
    let blockHeight = endEle.offsetTop - startEleOffetTop
    if (startTop === 0) {
      startEleOffetTop = 0
      if (startEle === endEle) {
        cElePaddingTop = 0
        endBottom = contentHeight - scrollDOM.offsetHeight
        blockHeight = cMaxScrollLength
      } else {
        blockHeight = endEle.offsetTop
      }
    }
    scale = (scrollDOM.scrollTop - startTop) / (endBottom - startTop)
    const endElePos =
      endEle == ((_c = cEle.lastElementChild) == null ? void 0 : _c.lastElementChild)
        ? endEle.offsetTop + endEle.clientHeight
        : endEle.offsetTop
    if (endBottom >= pMaxScrollLength || endElePos > cMaxScrollLength) {
      const lineNumer = getLineNumber(pMaxScrollLength, cMaxScrollLength)
      startTop = getTopByLine(lineNumer)
      scale = (scrollDOM.scrollTop - startTop) / (pMaxScrollLength - startTop)
      const _startEle = cEle.querySelector(`[data-line="${lineNumer}"]`)
      if (startTop > 0 && _startEle) {
        startEleOffetTop = _startEle.offsetTop
      }
      blockHeight = cMaxScrollLength - startEleOffetTop + getComputedStyleNum(cEle, 'padding-top')
    }
    const scrollToTop = startEleOffetTop - cElePaddingTop + blockHeight * scale
    smoothScroll2(cEle, scrollToTop, () => {
      pLock--
    })
  }
  const cEleHandler = () => {
    var _a2, _b, _c, _d, _e, _f
    if (pLock !== 0) {
      return
    }
    cLock++
    const { scrollDOM } = view
    const cScrollTop = cEle.scrollTop
    const cScrollHeight = cEle.scrollHeight
    const pMaxScrollLength = scrollDOM.scrollHeight - scrollDOM.clientHeight
    const cMaxScrollLength = cEle.scrollHeight - cEle.clientHeight
    let realEleStart = (_a2 = cEle.firstElementChild) == null ? void 0 : _a2.firstElementChild
    let realEleEnd = (_b = cEle.firstElementChild) == null ? void 0 : _b.lastElementChild
    if (startLines.length > 0) {
      let virtualLine = Math.ceil(startLines[startLines.length - 1] * (cScrollTop / cScrollHeight))
      let startLineIndex = startLines.findLastIndex((value) => value <= virtualLine)
      startLineIndex = startLineIndex === -1 ? 0 : startLineIndex
      virtualLine = startLines[startLineIndex]
      for (let i = startLineIndex; i >= 0 && i < startLines.length; ) {
        const currentElementTop = elesHasLineNumber[i].offsetTop
        if (currentElementTop > cScrollTop) {
          if (i - 1 >= 0) {
            i--
            continue
          }
          virtualLine = -1
          startLineIndex = i
          break
        } else {
          if (i + 1 < startLines.length && elesHasLineNumber[i + 1].offsetTop < cScrollTop) {
            i++
            continue
          }
          virtualLine = startLines[i]
          startLineIndex = i
          break
        }
      }
      switch (startLineIndex) {
        case -1: {
          realEleStart = (_c = cEle.firstElementChild) == null ? void 0 : _c.firstElementChild
          realEleEnd = elesHasLineNumber[startLineIndex]
          break
        }
        case startLines.length - 1: {
          realEleStart = elesHasLineNumber[startLineIndex]
          realEleEnd = (_d = cEle.firstElementChild) == null ? void 0 : _d.lastElementChild
          break
        }
        default: {
          realEleStart = elesHasLineNumber[startLineIndex]
          realEleEnd =
            elesHasLineNumber[
              startLineIndex + 1 === elesHasLineNumber.length ? startLineIndex : startLineIndex + 1
            ]
        }
      }
    }
    let eleStartOffsetTop =
      realEleStart === ((_e = cEle.firstElementChild) == null ? void 0 : _e.firstElementChild)
        ? 0
        : realEleStart.offsetTop - getComputedStyleNum(realEleStart, 'margin-top')
    let eleEndOffsetTop = realEleEnd.offsetTop
    let scale = 0
    const { start, end } = blockMap[Number(realEleStart.dataset.line || 0)]
    let firstLineScrollTop = getTopByLine(start)
    const endLineScrollTop = getTopByLine(end + 1 === view.state.doc.lines ? end : end + 1)
    let blockHeight = 0
    if (
      endLineScrollTop > pMaxScrollLength ||
      realEleEnd.offsetTop + realEleEnd.offsetHeight > cMaxScrollLength
    ) {
      const lineNumer = getLineNumber(pMaxScrollLength, cMaxScrollLength)
      const _startEle = cEle.querySelector(`[data-line="${lineNumer}"]`)
      eleStartOffsetTop = _startEle
        ? _startEle.offsetTop - getComputedStyleNum(_startEle, 'margin-top')
        : eleStartOffsetTop
      firstLineScrollTop = getTopByLine(lineNumer)
      scale = (cScrollTop - eleStartOffsetTop) / (cMaxScrollLength - eleStartOffsetTop)
      blockHeight = pMaxScrollLength - firstLineScrollTop
    } else if (
      realEleStart === ((_f = cEle.firstElementChild) == null ? void 0 : _f.firstElementChild)
    ) {
      if (realEleStart === realEleEnd) {
        eleEndOffsetTop =
          realEleEnd.offsetTop +
          realEleEnd.offsetHeight +
          +getComputedStyle(realEleEnd).marginBottom.replace('px', '')
        blockHeight = endLineScrollTop
      } else {
        blockHeight = endLineScrollTop
      }
      scale = Math.max(cScrollTop / eleEndOffsetTop, 0)
    } else {
      scale = Math.max((cScrollTop - eleStartOffsetTop) / (eleEndOffsetTop - eleStartOffsetTop), 0)
      blockHeight = endLineScrollTop - firstLineScrollTop
    }
    smoothScroll2(pEle, firstLineScrollTop + blockHeight * scale, () => {
      cLock--
    })
  }
  const scrollHandler2 = (e2) => {
    var _a2
    const { scrollDOM, contentHeight } = view
    const scrollDomHeight = scrollDOM.clientHeight
    if (
      contentHeight <= scrollDomHeight ||
      cEle.firstElementChild.clientHeight <= cEle.clientHeight
    ) {
      return false
    }
    if (
      view.state.doc.lines <= ((_a2 = blockMap[blockMap.length - 1]) == null ? void 0 : _a2.end)
    ) {
      return false
    }
    if (e2.target === pEle) {
      pEleHandler()
    } else {
      cEleHandler()
    }
  }
  return [
    () => {
      buildMap()
      pEle.addEventListener('scroll', scrollHandler2)
      cEle.addEventListener('scroll', scrollHandler2)
      pEle.dispatchEvent(new Event('scroll'))
    },
    () => {
      pEle.removeEventListener('scroll', scrollHandler2)
      cEle.removeEventListener('scroll', scrollHandler2)
    }
  ]
}
const props$1$1 = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {}
  },
  onActive: {
    type: Function,
    default: () => {}
  },
  onClick: {
    type: Function,
    default: () => {}
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
}
const CatalogLink = /* @__PURE__ */ defineComponent({
  props: props$1$1,
  setup(props2) {
    const scrollElementRef = inject('scrollElementRef')
    const rootNodeRef = inject('roorNodeRef')
    const currRef = ref()
    watch(
      () => props2.tocItem.active,
      (active) => {
        if (active) {
          props2.onActive(props2.tocItem, currRef.value)
        }
      }
    )
    onMounted(() => {
      if (props2.tocItem.active) {
        props2.onActive(props2.tocItem, currRef.value)
      }
    })
    return () => {
      const { tocItem, mdHeadingId: mdHeadingId2, onClick, scrollElementOffsetTop } = props2
      return createVNode(
        'div',
        {
          ref: currRef,
          class: [`${prefix}-catalog-link`, tocItem.active && `${prefix}-catalog-active`],
          onClick: (e2) => {
            e2.stopPropagation()
            onClick(e2, tocItem)
            if (e2.defaultPrevented) {
              return
            }
            const id2 = mdHeadingId2(tocItem.text, tocItem.level, tocItem.index)
            const targetHeadEle = rootNodeRef.value.getElementById(id2)
            const scrollContainer = scrollElementRef.value
            if (targetHeadEle && scrollContainer) {
              let par = targetHeadEle.offsetParent
              let offsetTop = targetHeadEle.offsetTop
              if (scrollContainer.contains(par)) {
                while (par && scrollContainer != par) {
                  offsetTop += par == null ? void 0 : par.offsetTop
                  par = par == null ? void 0 : par.offsetParent
                }
              }
              const pel = targetHeadEle.previousElementSibling
              let currMarginTop = 0
              if (!pel) {
                currMarginTop = getComputedStyleNum(targetHeadEle, 'margin-top')
              }
              scrollContainer == null
                ? void 0
                : scrollContainer.scrollTo({
                    top: offsetTop - scrollElementOffsetTop - currMarginTop,
                    behavior: 'smooth'
                  })
            }
          }
        },
        [
          createVNode(
            'span',
            {
              title: tocItem.text
            },
            [tocItem.text]
          ),
          tocItem.children &&
            tocItem.children.length > 0 &&
            createVNode(
              'div',
              {
                class: `${prefix}-catalog-wrapper`
              },
              [
                tocItem.children.map((item) =>
                  createVNode(
                    CatalogLink,
                    {
                      mdHeadingId: mdHeadingId2,
                      key: `${tocItem.text}-link-${item.level}-${item.text}`,
                      tocItem: item,
                      onActive: props2.onActive,
                      onClick: onClick,
                      scrollElementOffsetTop: scrollElementOffsetTop
                    },
                    null
                  )
                )
              ]
            )
        ]
      )
    }
  }
})
const props$a = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String,
    default: void 0
  },
  class: {
    type: String,
    default: ''
  },
  mdHeadingId: {
    type: Function,
    default: (text2) => text2
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object],
    default: void 0
  },
  theme: {
    type: String,
    default: 'light'
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onActive: {
    type: Function,
    default: void 0
  },
  /**
   * 滚动容器是否在web component中，默认不在
   *
   * 在其中的话通过document查询不到
   */
  isScrollElementInShadow: {
    type: Boolean,
    default: false
  },
  /**
   * 设置与哪个区域同步，默认与内容区域同步
   *
   * >= v5.3.0
   */
  syncWith: {
    type: String,
    default: 'preview'
  },
  /**
   * 控制最大显示的目录层级
   */
  catalogMaxDepth: {
    type: Number,
    default: void 0
  }
}
const MdCatalog = /* @__PURE__ */ defineComponent({
  name: 'MdCatalog',
  props: props$a,
  emits: ['onClick', 'onActive'],
  setup(props2, ctx) {
    const editorId = props2.editorId
    const defaultScrollElement = `#${editorId}-preview-wrapper`
    const state = reactive({
      list: [],
      show: false,
      scrollElement: props2.scrollElement || defaultScrollElement
    })
    const activeItem = shallowRef()
    const catalogRef = ref()
    const scrollElementRef = ref()
    const scrollContainerRef = ref()
    const rootNodeRef = ref()
    const editorViewRef = shallowRef()
    const indicatorStyles = ref({})
    provide('scrollElementRef', scrollElementRef)
    provide('roorNodeRef', rootNodeRef)
    const catalogs = computed(() => {
      const tocItems = []
      state.list.forEach((listItem, index2) => {
        if (props2.catalogMaxDepth && listItem.level > props2.catalogMaxDepth) {
          return
        }
        const { text: text2, level, line } = listItem
        const item = {
          level,
          text: text2,
          line,
          index: index2 + 1,
          active: activeItem.value === listItem
        }
        if (tocItems.length === 0) {
          tocItems.push(item)
        } else {
          let lastItem = tocItems[tocItems.length - 1]
          if (item.level > lastItem.level) {
            for (let i = lastItem.level + 1; i <= 6; i++) {
              const { children } = lastItem
              if (!children) {
                lastItem.children = [item]
                break
              }
              lastItem = children[children.length - 1]
              if (item.level <= lastItem.level) {
                children.push(item)
                break
              }
            }
          } else {
            tocItems.push(item)
          }
        }
      })
      return tocItems
    })
    const getScrollElement = () => {
      var _a2
      if (state.scrollElement instanceof HTMLElement) {
        return state.scrollElement
      }
      let scrollRoot = document
      if (state.scrollElement === defaultScrollElement || props2.isScrollElementInShadow) {
        scrollRoot = (_a2 = catalogRef.value) == null ? void 0 : _a2.getRootNode()
      }
      return scrollRoot.querySelector(state.scrollElement)
    }
    const findActiveHeading = (list2) => {
      if (list2.length === 0) {
        activeItem.value = void 0
        state.list = []
        return false
      }
      const { activeHead } = list2.reduce(
        (activeData, link2, index2) => {
          var _a2
          let relativeTop = 0
          if (props2.syncWith === 'preview') {
            const linkEle =
              (_a2 = rootNodeRef.value) == null
                ? void 0
                : _a2.getElementById(props2.mdHeadingId(link2.text, link2.level, index2 + 1))
            if (linkEle instanceof HTMLElement) {
              relativeTop = getRelativeTop(linkEle, scrollElementRef.value)
            }
          } else {
            const view = editorViewRef.value
            if (view) {
              const top2 = view.lineBlockAt(view.state.doc.line(link2.line + 1).from).top
              const scrollTop = view.scrollDOM.scrollTop
              relativeTop = top2 - scrollTop
            }
          }
          if (relativeTop < props2.offsetTop && relativeTop > activeData.minTop) {
            return {
              activeHead: link2,
              minTop: relativeTop
            }
          }
          return activeData
        },
        {
          activeHead: list2[0],
          minTop: Number.MIN_SAFE_INTEGER
        }
      )
      activeItem.value = activeHead
      state.list = list2
    }
    const onActive = (tocItem, ele) => {
      var _a2
      indicatorStyles.value.top = ele.offsetTop + getComputedStyleNum(ele, 'padding-top') + 'px'
      ;(_a2 = props2.onActive) == null ? void 0 : _a2.call(props2, tocItem, ele)
      ctx.emit('onActive', tocItem, ele)
    }
    const scrollHandler2 = () => {
      findActiveHeading(state.list)
    }
    const catalogChangedHandler = (_list) => {
      var _a2, _b, _c
      ;(_a2 = scrollContainerRef.value) == null
        ? void 0
        : _a2.removeEventListener('scroll', scrollHandler2)
      if (props2.syncWith === 'editor') {
        scrollContainerRef.value = (_b = editorViewRef.value) == null ? void 0 : _b.scrollDOM
      } else {
        const scrollElement = getScrollElement()
        scrollElementRef.value = scrollElement
        scrollContainerRef.value =
          scrollElement === document.documentElement ? document : scrollElement
      }
      findActiveHeading(_list)
      ;(_c = scrollContainerRef.value) == null
        ? void 0
        : _c.addEventListener('scroll', scrollHandler2)
    }
    const getEditorView = (view) => {
      editorViewRef.value = view
    }
    watch([() => props2.syncWith, editorViewRef, () => props2.catalogMaxDepth], () => {
      catalogChangedHandler(state.list)
    })
    onMounted(() => {
      rootNodeRef.value = catalogRef.value.getRootNode()
      bus.on(editorId, {
        name: CATALOG_CHANGED,
        callback: catalogChangedHandler
      })
      bus.on(editorId, {
        name: GET_EDITOR_VIEW,
        callback: getEditorView
      })
      bus.emit(editorId, PUSH_CATALOG)
      bus.emit(editorId, SEND_EDITOR_VIEW)
    })
    onBeforeUnmount(() => {
      var _a2
      bus.remove(editorId, CATALOG_CHANGED, catalogChangedHandler)
      bus.remove(editorId, GET_EDITOR_VIEW, getEditorView)
      ;(_a2 = scrollContainerRef.value) == null
        ? void 0
        : _a2.removeEventListener('scroll', scrollHandler2)
    })
    return () =>
      createVNode(
        'div',
        {
          class: [
            `${prefix}-catalog`,
            props2.theme === 'dark' && `${prefix}-catalog-dark`,
            props2.class || ''
          ],
          ref: catalogRef
        },
        [
          catalogs.value.length > 0 &&
            createVNode(Fragment, null, [
              createVNode(
                'div',
                {
                  class: `${prefix}-catalog-indicator`,
                  style: indicatorStyles.value
                },
                null
              ),
              createVNode(
                'div',
                {
                  class: `${prefix}-catalog-container`
                },
                [
                  catalogs.value.map((item) => {
                    return createVNode(
                      CatalogLink,
                      {
                        mdHeadingId: props2.mdHeadingId,
                        tocItem: item,
                        key: `link-${item.level}-${item.text}`,
                        onActive: onActive,
                        onClick: (e2, t2) => {
                          var _a2
                          ;(_a2 = props2.onClick) == null ? void 0 : _a2.call(props2, e2, t2)
                          ctx.emit('onClick', e2, t2)
                        },
                        scrollElementOffsetTop: props2.scrollElementOffsetTop
                      },
                      null
                    )
                  })
                ]
              )
            ])
        ]
      )
  }
})
MdCatalog.install = (app) => {
  app.component(MdCatalog.name, MdCatalog)
  return app
}
let rangeFrom = [],
  rangeTo = []
;(() => {
  let numbers =
    'lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o'
      .split(',')
      .map((s) => (s ? parseInt(s, 36) : 1))
  for (let i = 0, n2 = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push((n2 = n2 + numbers[i]))
})()
function isExtendingChar(code) {
  if (code < 768) return false
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = (from + to) >> 1
    if (code < rangeFrom[mid]) to = mid
    else if (code >= rangeTo[mid]) from = mid + 1
    else return true
    if (from == to) return false
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487
}
const ZWJ = 8205
function findClusterBreak$1(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending)
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos
  if (pos && surrogateLow$1(str.charCodeAt(pos)) && surrogateHigh$1(str.charCodeAt(pos - 1))) pos--
  let prev = codePointAt$1(str, pos)
  pos += codePointSize$1(prev)
  while (pos < str.length) {
    let next = codePointAt$1(str, pos)
    if (prev == ZWJ || next == ZWJ || (includeExtending && isExtendingChar(next))) {
      pos += codePointSize$1(next)
      prev = next
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0,
        i = pos - 2
      while (i >= 0 && isRegionalIndicator(codePointAt$1(str, i))) {
        countBefore++
        i -= 2
      }
      if (countBefore % 2 == 0) break
      else pos += 2
    } else {
      break
    }
  }
  return pos
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending)
    if (found < pos) return found
    pos--
  }
  return 0
}
function codePointAt$1(str, pos) {
  let code0 = str.charCodeAt(pos)
  if (!surrogateHigh$1(code0) || pos + 1 == str.length) return code0
  let code1 = str.charCodeAt(pos + 1)
  if (!surrogateLow$1(code1)) return code0
  return ((code0 - 55296) << 10) + (code1 - 56320) + 65536
}
function surrogateLow$1(ch) {
  return ch >= 56320 && ch < 57344
}
function surrogateHigh$1(ch) {
  return ch >= 55296 && ch < 56320
}
function codePointSize$1(code) {
  return code < 65536 ? 1 : 2
}
class Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`)
    return this.lineInner(pos, false, 1, 0)
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n2) {
    if (n2 < 1 || n2 > this.lines)
      throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`)
    return this.lineInner(n2, true, 1, 0)
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text2) {
    ;[from, to] = clip(this, from, to)
    let parts = []
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    )
    if (text2.length)
      text2.decompose(
        0,
        text2.length,
        parts,
        1 | 2
        /* Open.To */
      )
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    )
    return TextNode.from(parts, this.length - (to - from) + text2.length)
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other)
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    ;[from, to] = clip(this, from, to)
    let parts = []
    this.decompose(from, to, parts, 0)
    return TextNode.from(parts, to - from)
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this) return true
    if (other.length != this.length || other.lines != this.lines) return false
    let start = this.scanIdentical(other, 1),
      end = this.length - this.scanIdentical(other, -1)
    let a = new RawTextCursor(this),
      b = new RawTextCursor(other)
    for (let skip = start, pos = start; ; ) {
      a.next(skip)
      b.next(skip)
      skip = 0
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false
      pos += a.value.length
      if (a.done || pos >= end) return true
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir)
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to)
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner
    if (from == null) {
      inner = this.iter()
    } else {
      if (to == null) to = this.lines + 1
      let start = this.line(from).from
      inner = this.iterRange(
        start,
        Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to)
      )
    }
    return new LineCursor(inner)
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0)
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = []
    this.flatten(lines)
    return lines
  }
  /**
  @internal
  */
  constructor() {}
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text2) {
    if (text2.length == 0) throw new RangeError('A document must have at least one line')
    if (text2.length == 1 && !text2[0]) return Text.empty
    return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []))
  }
}
class TextLeaf extends Text {
  constructor(text2, length = textLength(text2)) {
    super()
    this.text = text2
    this.length = length
  }
  get lines() {
    return this.text.length
  }
  get children() {
    return null
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i],
        end = offset + string2.length
      if ((isLine ? line : end) >= target) return new Line$1(offset, end, line, string2)
      offset = end + 1
      line++
    }
  }
  decompose(from, to, target, open) {
    let text2 =
      from <= 0 && to >= this.length
        ? this
        : new TextLeaf(
            sliceText(this.text, from, to),
            Math.min(to, this.length) - Math.max(0, from)
          )
    if (open & 1) {
      let prev = target.pop()
      let joined = appendText(text2.text, prev.text.slice(), 0, text2.length)
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text2.length))
      } else {
        let mid = joined.length >> 1
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)))
      }
    } else {
      target.push(text2)
    }
  }
  replace(from, to, text2) {
    if (!(text2 instanceof TextLeaf)) return super.replace(from, to, text2)
    ;[from, to] = clip(this, from, to)
    let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from)), to)
    let newLen = this.length + text2.length - (to - from)
    if (lines.length <= 32) return new TextLeaf(lines, newLen)
    return TextNode.from(TextLeaf.split(lines, []), newLen)
  }
  sliceString(from, to = this.length, lineSep = '\n') {
    ;[from, to] = clip(this, from, to)
    let result = ''
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i],
        end = pos + line.length
      if (pos > from && i) result += lineSep
      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos)
      pos = end + 1
    }
    return result
  }
  flatten(target) {
    for (let line of this.text) target.push(line)
  }
  scanIdentical() {
    return 0
  }
  static split(text2, target) {
    let part = [],
      len = -1
    for (let line of text2) {
      part.push(line)
      len += line.length + 1
      if (part.length == 32) {
        target.push(new TextLeaf(part, len))
        part = []
        len = -1
      }
    }
    if (len > -1) target.push(new TextLeaf(part, len))
    return target
  }
}
class TextNode extends Text {
  constructor(children, length) {
    super()
    this.children = children
    this.length = length
    this.lines = 0
    for (let child of children) this.lines += child.lines
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i],
        end = offset + child.length,
        endLine = line + child.lines - 1
      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset)
      offset = end + 1
      line = endLine + 1
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0))
        if (pos >= from && end <= to && !childOpen) target.push(child)
        else child.decompose(from - pos, to - pos, target, childOpen)
      }
      pos = end + 1
    }
  }
  replace(from, to, text2) {
    ;[from, to] = clip(this, from, to)
    if (text2.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i],
          end = pos + child.length
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text2)
          let totalLines = this.lines - child.lines + updated.lines
          if (updated.lines < totalLines >> (5 - 1) && updated.lines > totalLines >> (5 + 1)) {
            let copy = this.children.slice()
            copy[i] = updated
            return new TextNode(copy, this.length - (to - from) + text2.length)
          }
          return super.replace(pos, end, updated)
        }
        pos = end + 1
      }
    return super.replace(from, to, text2)
  }
  sliceString(from, to = this.length, lineSep = '\n') {
    ;[from, to] = clip(this, from, to)
    let result = ''
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i],
        end = pos + child.length
      if (pos > from && i) result += lineSep
      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep)
      pos = end + 1
    }
    return result
  }
  flatten(target) {
    for (let child of this.children) child.flatten(target)
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode)) return 0
    let length = 0
    let [iA, iB, eA, eB] =
      dir > 0
        ? [0, 0, this.children.length, other.children.length]
        : [this.children.length - 1, other.children.length - 1, -1, -1]
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB) return length
      let chA = this.children[iA],
        chB = other.children[iB]
      if (chA != chB) return length + chA.scanIdentical(chB, dir)
      length += chA.length + 1
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0
    for (let ch of children) lines += ch.lines
    if (lines < 32) {
      let flat = []
      for (let ch of children) ch.flatten(flat)
      return new TextLeaf(flat, length)
    }
    let chunk = Math.max(
        32,
        lines >> 5
        /* Tree.BranchShift */
      ),
      maxChunk = chunk << 1,
      minChunk = chunk >> 1
    let chunked = [],
      currentLines = 0,
      currentLen = -1,
      currentChunk = []
    function add3(child) {
      let last
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children) add3(node)
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush()
        chunked.push(child)
      } else if (
        child instanceof TextLeaf &&
        currentLines &&
        (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
        child.lines + last.lines <= 32
      ) {
        currentLines += child.lines
        currentLen += child.length + 1
        currentChunk[currentChunk.length - 1] = new TextLeaf(
          last.text.concat(child.text),
          last.length + 1 + child.length
        )
      } else {
        if (currentLines + child.lines > chunk) flush()
        currentLines += child.lines
        currentLen += child.length + 1
        currentChunk.push(child)
      }
    }
    function flush() {
      if (currentLines == 0) return
      chunked.push(
        currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen)
      )
      currentLen = -1
      currentLines = currentChunk.length = 0
    }
    for (let child of children) add3(child)
    flush()
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length)
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([''], 0)
function textLength(text2) {
  let length = -1
  for (let line of text2) length += line.length + 1
  return length
}
function appendText(text2, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text2.length && pos <= to; i++) {
    let line = text2[i],
      end = pos + line.length
    if (end >= from) {
      if (end > to) line = line.slice(0, to - pos)
      if (pos < from) line = line.slice(from - pos)
      if (first) {
        target[target.length - 1] += line
        first = false
      } else target.push(line)
    }
    pos = end + 1
  }
  return target
}
function sliceText(text2, from, to) {
  return appendText(text2, [''], from, to)
}
class RawTextCursor {
  constructor(text2, dir = 1) {
    this.dir = dir
    this.done = false
    this.lineBreak = false
    this.value = ''
    this.nodes = [text2]
    this.offsets = [
      dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1
    ]
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false
    for (;;) {
      let last = this.nodes.length - 1
      let top2 = this.nodes[last],
        offsetValue = this.offsets[last],
        offset = offsetValue >> 1
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true
          this.value = ''
          return this
        }
        if (dir > 0) this.offsets[last - 1]++
        this.nodes.pop()
        this.offsets.pop()
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir
        if (skip == 0) {
          this.lineBreak = true
          this.value = '\n'
          return this
        }
        skip--
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)]
        this.offsets[last] += dir
        if (next.length > Math.max(0, skip)) {
          this.value =
            skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip)
          return this
        }
        skip -= next.length
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)]
        if (skip > next.length) {
          skip -= next.length
          this.offsets[last] += dir
        } else {
          if (dir < 0) this.offsets[last]--
          this.nodes.push(next)
          this.offsets.push(
            dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1
          )
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir)
      skip = this.value.length
    }
    return this.nextInner(skip, this.dir)
  }
}
class PartialTextCursor {
  constructor(text2, start, end) {
    this.value = ''
    this.done = false
    this.cursor = new RawTextCursor(text2, start > end ? -1 : 1)
    this.pos = start > end ? text2.length : 0
    this.from = Math.min(start, end)
    this.to = Math.max(start, end)
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = ''
      this.done = true
      return this
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos)
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos
    if (skip > limit) skip = limit
    limit -= skip
    let { value } = this.cursor.next(skip)
    this.pos += (value.length + skip) * dir
    this.value =
      value.length <= limit
        ? value
        : dir < 0
          ? value.slice(value.length - limit)
          : value.slice(0, limit)
    this.done = !this.value
    return this
  }
  next(skip = 0) {
    if (skip < 0) skip = Math.max(skip, this.from - this.pos)
    else if (skip > 0) skip = Math.min(skip, this.to - this.pos)
    return this.nextInner(skip, this.cursor.dir)
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != ''
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner
    this.afterBreak = true
    this.value = ''
    this.done = false
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip)
    if (done && this.afterBreak) {
      this.value = ''
      this.afterBreak = false
    } else if (done) {
      this.done = true
      this.value = ''
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = ''
      } else {
        this.afterBreak = true
        this.next()
      }
    } else {
      this.value = value
      this.afterBreak = false
    }
    return this
  }
  get lineBreak() {
    return false
  }
}
if (typeof Symbol != 'undefined') {
  Text.prototype[Symbol.iterator] = function () {
    return this.iter()
  }
  RawTextCursor.prototype[Symbol.iterator] =
    PartialTextCursor.prototype[Symbol.iterator] =
    LineCursor.prototype[Symbol.iterator] =
      function () {
        return this
      }
}
let Line$1 = class Line {
  /**
  @internal
  */
  constructor(from, to, number2, text2) {
    this.from = from
    this.to = to
    this.number = number2
    this.text = text2
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from
  }
}
function clip(text2, from, to) {
  from = Math.max(0, Math.min(text2.length, from))
  return [from, Math.max(from, Math.min(text2.length, to))]
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak$1(str, pos, forward, includeExtending)
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos)
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0
  let code1 = str.charCodeAt(pos + 1)
  if (!surrogateLow(code1)) return code0
  return ((code0 - 55296) << 10) + (code1 - 56320) + 65536
}
function fromCodePoint(code) {
  if (code <= 65535) return String.fromCharCode(code)
  code -= 65536
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320)
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2
}
const DefaultSplit = /\r\n?|\n/
var MapMode = /* @__PURE__ */ (function (MapMode2) {
  MapMode2[(MapMode2['Simple'] = 0)] = 'Simple'
  MapMode2[(MapMode2['TrackDel'] = 1)] = 'TrackDel'
  MapMode2[(MapMode2['TrackBefore'] = 2)] = 'TrackBefore'
  MapMode2[(MapMode2['TrackAfter'] = 3)] = 'TrackAfter'
  return MapMode2
})(MapMode || (MapMode = {}))
class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0
    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i]
    return result
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1]
      result += ins < 0 ? this.sections[i] : ins
    }
    return result
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || (this.sections.length == 2 && this.sections[1] < 0)
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++],
        ins = this.sections[i++]
      if (ins < 0) {
        f(posA, posB, len)
        posB += len
      } else {
        posB += ins
      }
      posA += len
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual)
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = []
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++],
        ins = this.sections[i++]
      if (ins < 0) sections.push(len, ins)
      else sections.push(ins, len)
    }
    return new ChangeDesc(sections)
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other)
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before)
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0,
      posB = 0
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++],
        ins = this.sections[i++],
        endA = posA + len
      if (ins < 0) {
        if (endA > pos) return posB + (pos - posA)
        posB += len
      } else {
        if (
          mode != MapMode.Simple &&
          endA >= pos &&
          ((mode == MapMode.TrackDel && posA < pos && endA > pos) ||
            (mode == MapMode.TrackBefore && posA < pos) ||
            (mode == MapMode.TrackAfter && endA > pos))
        )
          return null
        if (endA > pos || (endA == pos && assoc < 0 && !len))
          return pos == posA || assoc < 0 ? posB : posB + ins
        posB += ins
      }
      posA = endA
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`)
    return posB
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++],
        ins = this.sections[i++],
        end = pos + len
      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? 'cover' : true
      pos = end
    }
    return false
  }
  /**
  @internal
  */
  toString() {
    let result = ''
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++],
        ins = this.sections[i++]
      result += (result ? ' ' : '') + len + (ins >= 0 ? ':' + ins : '')
    }
    return result
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != 'number'))
      throw new RangeError('Invalid JSON representation of ChangeDesc')
    return new ChangeDesc(json)
  }
  /**
  @internal
  */
  static create(sections) {
    return new ChangeDesc(sections)
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections)
    this.inserted = inserted
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError('Applying change set to a document with the wrong length')
    iterChanges(
      this,
      (fromA, toA, fromB, _toB, text2) =>
        (doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2)),
      false
    )
    return doc2
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true)
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(),
      inserted = []
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i],
        ins = sections[i + 1]
      if (ins >= 0) {
        sections[i] = ins
        sections[i + 1] = len
        let index2 = i >> 1
        while (inserted.length < index2) inserted.push(Text.empty)
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty)
      }
      pos += len
    }
    return new ChangeSet(sections, inserted)
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true)
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true)
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual)
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections)
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [],
      resultInserted = [],
      filteredSections = []
    let iter = new SectionIter(this)
    done: for (let i = 0, pos = 0; ; ) {
      let next = i == ranges.length ? 1e9 : ranges[i++]
      while (pos < next || (pos == next && iter.len == 0)) {
        if (iter.done) break done
        let len = Math.min(iter.len, next - pos)
        addSection(filteredSections, len, -1)
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0
        addSection(resultSections, len, ins)
        if (ins > 0) addInsert(resultInserted, resultSections, iter.text)
        iter.forward(len)
        pos += len
      }
      let end = ranges[i++]
      while (pos < end) {
        if (iter.done) break done
        let len = Math.min(iter.len, end - pos)
        addSection(resultSections, len, -1)
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0)
        iter.forward(len)
        pos += len
      }
    }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    }
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = []
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i],
        ins = this.sections[i + 1]
      if (ins < 0) parts.push(len)
      else if (ins == 0) parts.push([len])
      else parts.push([len].concat(this.inserted[i >> 1].toJSON()))
    }
    return parts
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [],
      inserted = [],
      pos = 0
    let total = null
    function flush(force = false) {
      if (!force && !sections.length) return
      if (pos < length) addSection(sections, length - pos, -1)
      let set2 = new ChangeSet(sections, inserted)
      total = total ? total.compose(set2.map(total)) : set2
      sections = []
      inserted = []
      pos = 0
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec) process2(sub)
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(
            `Mismatched change set length (got ${spec.length}, expected ${length})`
          )
        flush()
        total = total ? total.compose(spec.map(total)) : spec
      } else {
        let { from, to = from, insert: insert2 } = spec
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`)
        let insText = !insert2
          ? Text.empty
          : typeof insert2 == 'string'
            ? Text.of(insert2.split(lineSep || DefaultSplit))
            : insert2
        let insLen = insText.length
        if (from == to && insLen == 0) return
        if (from < pos) flush()
        if (from > pos) addSection(sections, from - pos, -1)
        addSection(sections, to - from, insLen)
        addInsert(inserted, sections, insText)
        pos = to
      }
    }
    process2(changes)
    flush(!total)
    return total
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], [])
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json)) throw new RangeError('Invalid JSON representation of ChangeSet')
    let sections = [],
      inserted = []
    for (let i = 0; i < json.length; i++) {
      let part = json[i]
      if (typeof part == 'number') {
        sections.push(part, -1)
      } else if (
        !Array.isArray(part) ||
        typeof part[0] != 'number' ||
        part.some((e2, i2) => i2 && typeof e2 != 'string')
      ) {
        throw new RangeError('Invalid JSON representation of ChangeSet')
      } else if (part.length == 1) {
        sections.push(part[0], 0)
      } else {
        while (inserted.length < i) inserted.push(Text.empty)
        inserted[i] = Text.of(part.slice(1))
        sections.push(part[0], inserted[i].length)
      }
    }
    return new ChangeSet(sections, inserted)
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted)
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0) return
  let last = sections.length - 2
  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len
  else if (last >= 0 && len == 0 && sections[last] == 0) sections[last + 1] += ins
  else if (forceJoin) {
    sections[last] += len
    sections[last + 1] += ins
  } else sections.push(len, ins)
}
function addInsert(values2, sections, value) {
  if (value.length == 0) return
  let index2 = (sections.length - 2) >> 1
  if (index2 < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value)
  } else {
    while (values2.length < index2) values2.push(Text.empty)
    values2.push(value)
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++],
      ins = desc.sections[i++]
    if (ins < 0) {
      posA += len
      posB += len
    } else {
      let endA = posA,
        endB = posB,
        text2 = Text.empty
      for (;;) {
        endA += len
        endB += ins
        if (ins && inserted) text2 = text2.append(inserted[(i - 2) >> 1])
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break
        len = desc.sections[i++]
        ins = desc.sections[i++]
      }
      f(posA, endA, posB, endB, text2)
      posA = endA
      posB = endB
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [],
    insert2 = mkSet ? [] : null
  let a = new SectionIter(setA),
    b = new SectionIter(setB)
  for (let inserted = -1; ; ) {
    if ((a.done && b.len) || (b.done && a.len)) {
      throw new Error('Mismatched change set lengths')
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len)
      addSection(sections, len, -1)
      a.forward(len)
      b.forward(len)
    } else if (
      b.ins >= 0 &&
      (a.ins < 0 ||
        inserted == a.i ||
        (a.off == 0 && (b.len < a.len || (b.len == a.len && !before))))
    ) {
      let len = b.len
      addSection(sections, b.ins, -1)
      while (len) {
        let piece = Math.min(a.len, len)
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins)
          if (insert2) addInsert(insert2, sections, a.text)
          inserted = a.i
        }
        a.forward(piece)
        len -= piece
      }
      b.next()
    } else if (a.ins >= 0) {
      let len = 0,
        left = a.len
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len)
          len += piece
          left -= piece
          b.forward(piece)
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len
          b.next()
        } else {
          break
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0)
      if (insert2 && inserted < a.i) addInsert(insert2, sections, a.text)
      inserted = a.i
      a.forward(a.len - left)
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections)
    } else {
      throw new Error('Mismatched change set lengths')
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = []
  let insert2 = mkSet ? [] : null
  let a = new SectionIter(setA),
    b = new SectionIter(setB)
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections)
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open)
      a.next()
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open)
      if (insert2) addInsert(insert2, sections, b.text)
      b.next()
    } else if (a.done || b.done) {
      throw new Error('Mismatched change set lengths')
    } else {
      let len = Math.min(a.len2, b.len),
        sectionLen = sections.length
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins
        addSection(sections, len, insB, open)
        if (insert2 && insB) addInsert(insert2, sections, b.text)
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open)
        if (insert2) addInsert(insert2, sections, a.textBit(len))
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open)
        if (insert2 && !b.off) addInsert(insert2, sections, b.text)
      }
      open = (a.ins > len || (b.ins >= 0 && b.len > len)) && (open || sections.length > sectionLen)
      a.forward2(len)
      b.forward(len)
    }
  }
}
class SectionIter {
  constructor(set2) {
    this.set = set2
    this.i = 0
    this.next()
  }
  next() {
    let { sections } = this.set
    if (this.i < sections.length) {
      this.len = sections[this.i++]
      this.ins = sections[this.i++]
    } else {
      this.len = 0
      this.ins = -2
    }
    this.off = 0
  }
  get done() {
    return this.ins == -2
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins
  }
  get text() {
    let { inserted } = this.set,
      index2 = (this.i - 2) >> 1
    return index2 >= inserted.length ? Text.empty : inserted[index2]
  }
  textBit(len) {
    let { inserted } = this.set,
      index2 = (this.i - 2) >> 1
    return index2 >= inserted.length && !len
      ? Text.empty
      : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len)
  }
  forward(len) {
    if (len == this.len) this.next()
    else {
      this.len -= len
      this.off += len
    }
  }
  forward2(len) {
    if (this.ins == -1) this.forward(len)
    else if (len == this.ins) this.next()
    else {
      this.ins -= len
      this.off += len
    }
  }
}
class SelectionRange {
  constructor(from, to, flags) {
    this.from = from
    this.to = to
    this.flags = flags
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7
    return level == 7 ? null : level
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6
    return value == 16777215 ? void 0 : value
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc)
    } else {
      from = change.mapPos(this.from, 1)
      to = change.mapPos(this.to, -1)
    }
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags)
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to)
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to
    return EditorSelection.range(this.anchor, head)
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return (
      this.anchor == other.anchor &&
      this.head == other.head &&
      (!includeAssoc || !this.empty || this.assoc == other.assoc)
    )
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head }
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != 'number' || typeof json.head != 'number')
      throw new RangeError('Invalid JSON representation for SelectionRange')
    return EditorSelection.range(json.anchor, json.head)
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new SelectionRange(from, to, flags)
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges
    this.mainIndex = mainIndex
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty) return this
    return EditorSelection.create(
      this.ranges.map((r2) => r2.map(change, assoc)),
      this.mainIndex
    )
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false
    return true
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex]
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0)
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1)
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice()
    ranges[which] = range
    return EditorSelection.create(ranges, this.mainIndex)
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex }
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (
      !json ||
      !Array.isArray(json.ranges) ||
      typeof json.main != 'number' ||
      json.main >= json.ranges.length
    )
      throw new RangeError('Invalid JSON representation for EditorSelection')
    return new EditorSelection(
      json.ranges.map((r2) => SelectionRange.fromJSON(r2)),
      json.main
    )
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0)
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0) throw new RangeError('A selection needs at least one range')
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i]
      if (range.empty ? range.from <= pos : range.from < pos)
        return EditorSelection.normalized(ranges.slice(), mainIndex)
      pos = range.to
    }
    return new EditorSelection(ranges, mainIndex)
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(
      pos,
      pos,
      (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) |
        (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
        ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6)
    )
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags =
      ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6) |
      (bidiLevel == null ? 7 : Math.min(6, bidiLevel))
    return head < anchor
      ? SelectionRange.create(head, anchor, 32 | 16 | flags)
      : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags)
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex]
    ranges.sort((a, b) => a.from - b.from)
    mainIndex = ranges.indexOf(main)
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i],
        prev = ranges[i - 1]
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from,
          to = Math.max(range.to, prev.to)
        if (i <= mainIndex) mainIndex--
        ranges.splice(
          --i,
          2,
          range.anchor > range.head
            ? EditorSelection.range(to, from)
            : EditorSelection.range(from, to)
        )
      }
    }
    return new EditorSelection(ranges, mainIndex)
  }
}
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength) throw new RangeError('Selection points outside of document')
}
let nextID = 0
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine
    this.compareInput = compareInput
    this.compare = compare2
    this.isStatic = isStatic
    this.id = nextID++
    this.default = combine([])
    this.extensions = typeof enables == 'function' ? enables(this) : enables
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new Facet(
      config2.combine || ((a) => a),
      config2.compareInput || ((a, b) => a === b),
      config2.compare || (!config2.combine ? sameArray$1 : (a, b) => a === b),
      !!config2.static,
      config2.enables
    )
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value)
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet")
    return new FacetProvider(deps, this, 1, get)
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet")
    return new FacetProvider(deps, this, 2, get)
  }
  from(field, get) {
    if (!get) get = (x2) => x2
    return this.compute([field], (state) => get(state.field(field)))
  }
}
function sameArray$1(a, b) {
  return a == b || (a.length == b.length && a.every((e2, i) => e2 === b[i]))
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies
    this.facet = facet
    this.type = type
    this.value = value
    this.id = nextID++
  }
  dynamicSlot(addresses) {
    var _a2
    let getter = this.value
    let compare2 = this.facet.compareInput
    let id2 = this.id,
      idx = addresses[id2] >> 1,
      multi = this.type == 2
    let depDoc = false,
      depSel = false,
      depAddrs = []
    for (let dep of this.dependencies) {
      if (dep == 'doc') depDoc = true
      else if (dep == 'selection') depSel = true
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id])
    }
    return {
      create(state) {
        state.values[idx] = getter(state)
        return 1
      },
      update(state, tr) {
        if (
          (depDoc && tr.docChanged) ||
          (depSel && (tr.docChanged || tr.selection)) ||
          ensureAll(state, depAddrs)
        ) {
          let newVal = getter(state)
          if (
            multi
              ? !compareArray(newVal, state.values[idx], compare2)
              : !compare2(newVal, state.values[idx])
          ) {
            state.values[idx] = newVal
            return 1
          }
        }
        return 0
      },
      reconfigure: (state, oldState) => {
        let newVal,
          oldAddr = oldState.config.address[id2]
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr)
          if (
            this.dependencies.every((dep) => {
              return dep instanceof Facet
                ? oldState.facet(dep) === state.facet(dep)
                : dep instanceof StateField
                  ? oldState.field(dep, false) == state.field(dep, false)
                  : true
            }) ||
            (multi
              ? compareArray((newVal = getter(state)), oldVal, compare2)
              : compare2((newVal = getter(state)), oldVal))
          ) {
            state.values[idx] = oldVal
            return 0
          }
        } else {
          newVal = getter(state)
        }
        state.values[idx] = newVal
        return 1
      }
    }
  }
}
function compareArray(a, b, compare2) {
  if (a.length != b.length) return false
  for (let i = 0; i < a.length; i++) if (!compare2(a[i], b[i])) return false
  return true
}
function ensureAll(state, addrs) {
  let changed = false
  for (let addr of addrs) if (ensureAddr(state, addr) & 1) changed = true
  return changed
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id])
  let providerTypes = providers.map((p) => p.type)
  let dynamic = providerAddrs.filter((p) => !(p & 1))
  let idx = addresses[facet.id] >> 1
  function get(state) {
    let values2 = []
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i])
      if (providerTypes[i] == 2) for (let val of value) values2.push(val)
      else values2.push(value)
    }
    return facet.combine(values2)
  }
  return {
    create(state) {
      for (let addr of providerAddrs) ensureAddr(state, addr)
      state.values[idx] = get(state)
      return 1
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic)) return 0
      let value = get(state)
      if (facet.compare(value, state.values[idx])) return 0
      state.values[idx] = value
      return 1
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs)
      let oldProviders = oldState.config.facets[facet.id],
        oldValue = oldState.facet(facet)
      if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
        state.values[idx] = oldValue
        return 0
      }
      let value = get(state)
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue
        return 0
      }
      state.values[idx] = value
      return 1
    }
  }
}
const initField = /* @__PURE__ */ Facet.define({ static: true })
class StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2
    this.createF = createF
    this.updateF = updateF
    this.compareF = compareF
    this.spec = spec
    this.provides = void 0
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new StateField(
      nextID++,
      config2.create,
      config2.update,
      config2.compare || ((a, b) => a === b),
      config2
    )
    if (config2.provide) field.provides = config2.provide(field)
    return field
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this)
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state)
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1
    return {
      create: (state) => {
        state.values[idx] = this.create(state)
        return 1
      },
      update: (state, tr) => {
        let oldVal = state.values[idx]
        let value = this.updateF(oldVal, tr)
        if (this.compareF(oldVal, value)) return 0
        state.values[idx] = value
        return 1
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField),
          oldInit = oldState.facet(initField),
          reInit
        if (
          (reInit = init.find((i) => i.field == this)) &&
          reInit != oldInit.find((i) => i.field == this)
        ) {
          state.values[idx] = reInit.create(state)
          return 1
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this)
          return 0
        }
        state.values[idx] = this.create(state)
        return 1
      }
    }
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })]
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 }
function prec(value) {
  return (ext) => new PrecExtension(ext, value)
}
const Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
}
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner
    this.prec = prec2
  }
}
class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext)
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 })
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this)
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment
    this.inner = inner
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2
    this.compartments = compartments
    this.dynamicSlots = dynamicSlots
    this.address = address
    this.staticValues = staticValues
    this.facets = facets
    this.statusTemplate = []
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      )
  }
  staticFacet(facet) {
    let addr = this.address[facet.id]
    return addr == null ? facet.default : this.staticValues[addr >> 1]
  }
  static resolve(base2, compartments, oldState) {
    let fields = []
    let facets = /* @__PURE__ */ Object.create(null)
    let newCompartments = /* @__PURE__ */ new Map()
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField) fields.push(ext)
      else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext)
    }
    let address = /* @__PURE__ */ Object.create(null)
    let staticValues = []
    let dynamicSlots = []
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1
      dynamicSlots.push((a) => field.slot(a))
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets
    for (let id2 in facets) {
      let providers = facets[id2],
        facet = providers[0].facet
      let oldProviders = (oldFacets && oldFacets[id2]) || []
      if (
        providers.every(
          (p) => p.type == 0
          /* Provider.Static */
        )
      ) {
        address[facet.id] = (staticValues.length << 1) | 1
        if (sameArray$1(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet))
        } else {
          let value = facet.combine(providers.map((p) => p.value))
          staticValues.push(
            oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value
          )
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = (staticValues.length << 1) | 1
            staticValues.push(p.value)
          } else {
            address[p.id] = dynamicSlots.length << 1
            dynamicSlots.push((a) => p.dynamicSlot(a))
          }
        }
        address[facet.id] = dynamicSlots.length << 1
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers))
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address))
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets)
  }
}
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []]
  let seen = /* @__PURE__ */ new Map()
  function inner(ext, prec2) {
    let known = seen.get(ext)
    if (known != null) {
      if (known <= prec2) return
      let found = result[known].indexOf(ext)
      if (found > -1) result[known].splice(found, 1)
      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment)
    }
    seen.set(ext, prec2)
    if (Array.isArray(ext)) {
      for (let e2 of ext) inner(e2, prec2)
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`)
      let content2 = compartments.get(ext.compartment) || ext.inner
      newCompartments.set(ext.compartment, content2)
      inner(content2, prec2)
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec)
    } else if (ext instanceof StateField) {
      result[prec2].push(ext)
      if (ext.provides) inner(ext.provides, prec2)
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext)
      if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default)
    } else {
      let content2 = ext.extension
      if (!content2)
        throw new Error(
          `Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
        )
      inner(content2, prec2)
    }
  }
  inner(extension, Prec_.default)
  return result.reduce((a, b) => a.concat(b))
}
function ensureAddr(state, addr) {
  if (addr & 1) return 2
  let idx = addr >> 1
  let status = state.status[idx]
  if (status == 4) throw new Error('Cyclic dependency between fields and/or facets')
  if (status & 2) return status
  state.status[idx] = 4
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx])
  return (state.status[idx] = 2 | changed)
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1]
}
const languageData = /* @__PURE__ */ Facet.define()
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((v) => v),
  static: true
})
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values2) => (values2.length ? values2[0] : void 0),
  static: true
})
const changeFilter = /* @__PURE__ */ Facet.define()
const transactionFilter = /* @__PURE__ */ Facet.define()
const transactionExtender = /* @__PURE__ */ Facet.define()
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values2) => (values2.length ? values2[0] : false)
})
class Annotation {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type
    this.value = value
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType()
  }
}
class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value)
  }
}
class StateEffectType {
  /**
  @internal
  */
  constructor(map2) {
    this.map = map2
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value)
  }
}
class StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type
    this.value = value
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping)
    return mapped === void 0
      ? void 0
      : mapped == this.value
        ? this
        : new StateEffect(this.type, mapped)
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v))
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length) return effects
    let result = []
    for (let effect of effects) {
      let mapped = effect.map(mapping)
      if (mapped) result.push(mapped)
    }
    return result
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define()
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define()
class Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    this.startState = startState
    this.changes = changes
    this.selection = selection2
    this.effects = effects
    this.annotations = annotations
    this.scrollIntoView = scrollIntoView2
    this._doc = null
    this._state = null
    if (selection2) checkSelection(selection2, changes.newLength)
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()))
  }
  /**
  @internal
  */
  static create(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection2, effects, annotations, scrollIntoView2)
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc))
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes)
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state) this.startState.applyTransaction(this)
    return this._state
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations) if (ann.type == type) return ann.value
    return void 0
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e2 = this.annotation(Transaction.userEvent)
    return !!(
      e2 &&
      (e2 == event ||
        (e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == '.'))
    )
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define()
Transaction.userEvent = /* @__PURE__ */ Annotation.define()
Transaction.addToHistory = /* @__PURE__ */ Annotation.define()
Transaction.remote = /* @__PURE__ */ Annotation.define()
function joinRanges(a, b) {
  let result = []
  for (let iA = 0, iB = 0; ; ) {
    let from, to
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++]
      to = a[iA++]
    } else if (iB < b.length) {
      from = b[iB++]
      to = b[iB++]
    } else return result
    if (!result.length || result[result.length - 1] < from) result.push(from, to)
    else if (result[result.length - 1] < to) result[result.length - 1] = to
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2
  let mapForA, mapForB, changes
  if (sequential) {
    mapForA = b.changes
    mapForB = ChangeSet.empty(b.changes.length)
    changes = a.changes.compose(b.changes)
  } else {
    mapForA = b.changes.map(a.changes)
    mapForB = a.changes.mapDesc(b.changes, true)
    changes = a.changes.compose(mapForA)
  }
  return {
    changes,
    selection: b.selection
      ? b.selection.map(mapForB)
      : (_a2 = a.selection) === null || _a2 === void 0
        ? void 0
        : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(
      StateEffect.mapEffects(b.effects, mapForB)
    ),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  }
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection,
    annotations = asArray(spec.annotations)
  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent))
  return {
    changes:
      spec.changes instanceof ChangeSet
        ? spec.changes
        : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection:
      sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  }
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length)
  if (specs.length && specs[0].filter === false) filter = false
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false) filter = false
    let seq = !!specs[i].sequential
    s = mergeTransaction(
      s,
      resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length),
      seq
    )
  }
  let tr = Transaction.create(
    state,
    s.changes,
    s.selection,
    s.effects,
    s.annotations,
    s.scrollIntoView
  )
  return extendTransaction(filter ? filterTransaction(tr) : tr)
}
function filterTransaction(tr) {
  let state = tr.startState
  let result = true
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr)
    if (value === false) {
      result = false
      break
    }
    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value)
  }
  if (result !== true) {
    let changes, back
    if (result === false) {
      back = tr.changes.invertedDesc
      changes = ChangeSet.empty(state.doc.length)
    } else {
      let filtered = tr.changes.filter(result)
      changes = filtered.changes
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc
    }
    tr = Transaction.create(
      state,
      changes,
      tr.selection && tr.selection.map(back),
      StateEffect.mapEffects(tr.effects, back),
      tr.annotations,
      tr.scrollIntoView
    )
  }
  let filters = state.facet(transactionFilter)
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr)
    if (filtered instanceof Transaction) tr = filtered
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0]
    else tr = resolveTransaction(state, asArray(filtered), false)
  }
  return tr
}
function extendTransaction(tr) {
  let state = tr.startState,
    extenders = state.facet(transactionExtender),
    spec = tr
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr)
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(
        spec,
        resolveTransactionInner(state, extension, tr.changes.newLength),
        true
      )
  }
  return spec == tr
    ? tr
    : Transaction.create(
        state,
        tr.changes,
        tr.selection,
        spec.effects,
        spec.annotations,
        spec.scrollIntoView
      )
}
const none$3 = []
function asArray(value) {
  return value == null ? none$3 : Array.isArray(value) ? value : [value]
}
var CharCategory = /* @__PURE__ */ (function (CharCategory2) {
  CharCategory2[(CharCategory2['Word'] = 0)] = 'Word'
  CharCategory2[(CharCategory2['Space'] = 1)] = 'Space'
  CharCategory2[(CharCategory2['Other'] = 2)] = 'Other'
  return CharCategory2
})(CharCategory || (CharCategory = {}))
const nonASCIISingleCaseWordChar =
  /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
let wordChar
try {
  wordChar = /* @__PURE__ */ new RegExp('[\\p{Alphabetic}\\p{Number}_]', 'u')
} catch (_2) {}
function hasWordChar(str) {
  if (wordChar) return wordChar.test(str)
  for (let i = 0; i < str.length; i++) {
    let ch = str[i]
    if (
      /\w/.test(ch) ||
      (ch > '' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
    )
      return true
  }
  return false
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char)) return CharCategory.Space
    if (hasWordChar(char)) return CharCategory.Word
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word
    return CharCategory.Other
  }
}
class EditorState {
  constructor(config2, doc2, selection2, values2, computeSlot, tr) {
    this.config = config2
    this.doc = doc2
    this.selection = selection2
    this.values = values2
    this.status = config2.statusTemplate.slice()
    this.computeSlot = computeSlot
    if (tr) tr._state = this
    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1)
    this.computeSlot = null
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id]
    if (addr == null) {
      if (require2) throw new RangeError('Field is not present in this state')
      return void 0
    }
    ensureAddr(this, addr)
    return getAddr(this, addr)
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true)
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config,
      { base: base2, compartments } = conf
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map()
          conf.compartments.forEach((val, key) => compartments.set(key, val))
          conf = null
        }
        compartments.set(effect.value.compartment, effect.value.extension)
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null
        base2 = effect.value
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null
        base2 = asArray(base2).concat(effect.value)
      }
    }
    let startValues
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this)
      let intermediateState = new EditorState(
        conf,
        this.doc,
        this.selection,
        conf.dynamicSlots.map(() => null),
        (state, slot) => slot.reconfigure(state, this),
        null
      )
      startValues = intermediateState.values
    } else {
      startValues = tr.startState.values.slice()
    }
    let selection2 = tr.startState.facet(allowMultipleSelections)
      ? tr.newSelection
      : tr.newSelection.asSingle()
    new EditorState(
      conf,
      tr.newDoc,
      selection2,
      startValues,
      (state, slot) => slot.update(state, tr),
      tr
    )
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text2) {
    if (typeof text2 == 'string') text2 = this.toText(text2)
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text2 },
      range: EditorSelection.cursor(range.from + text2.length)
    }))
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection
    let result1 = f(sel.ranges[0])
    let changes = this.changes(result1.changes),
      ranges = [result1.range]
    let effects = asArray(result1.effects)
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i])
      let newChanges = this.changes(result.changes),
        newMapped = newChanges.map(changes)
      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped)
      let mapBy = changes.mapDesc(newChanges, true)
      ranges.push(result.range.map(mapBy))
      changes = changes.compose(newMapped)
      effects = StateEffect.mapEffects(effects, newMapped).concat(
        StateEffect.mapEffects(asArray(result.effects), mapBy)
      )
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    }
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet) return spec
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator))
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit))
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak)
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id]
    if (addr == null) return facet.default
    ensureAddr(this, addr)
    return getAddr(this, addr)
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    }
    if (fields)
      for (let prop in fields) {
        let value = fields[prop]
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this)
      }
    return result
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != 'string')
      throw new RangeError('Invalid JSON representation for EditorState')
    let fieldInit = []
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop],
            value = json[prop]
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)))
        }
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    })
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map())
    let doc2 =
      config2.doc instanceof Text
        ? config2.doc
        : Text.of(
            (config2.doc || '').split(
              configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit
            )
          )
    let selection2 = !config2.selection
      ? EditorSelection.single(0)
      : config2.selection instanceof EditorSelection
        ? config2.selection
        : EditorSelection.single(config2.selection.anchor, config2.selection.head)
    checkSelection(selection2, doc2.length)
    if (!configuration.staticFacet(allowMultipleSelections)) selection2 = selection2.asSingle()
    return new EditorState(
      configuration,
      doc2,
      selection2,
      configuration.dynamicSlots.map(() => null),
      (state, slot) => slot.create(state),
      null
    )
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(EditorState.tabSize)
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || '\n'
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly)
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map2 of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map2, phrase2)) {
        phrase2 = map2[phrase2]
        break
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == '$') return '$'
        let n2 = +(i || 1)
        return !n2 || n2 > insert2.length ? m : insert2[n2 - 1]
      })
    return phrase2
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values2 = []
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2)) values2.push(result[name2])
      }
    }
    return values2
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt('wordChars', at).join(''))
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text: text2, from, length } = this.doc.lineAt(pos)
    let cat = this.charCategorizer(pos)
    let start = pos - from,
      end = pos - from
    while (start > 0) {
      let prev = findClusterBreak(text2, start, false)
      if (cat(text2.slice(prev, start)) != CharCategory.Word) break
      start = prev
    }
    while (end < length) {
      let next = findClusterBreak(text2, end)
      if (cat(text2.slice(end, next)) != CharCategory.Word) break
      end = next
    }
    return start == end ? null : EditorSelection.range(start + from, end + from)
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values2) => (values2.length ? values2[0] : 4)
})
EditorState.lineSeparator = lineSeparator
EditorState.readOnly = readOnly
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a),
      kB = Object.keys(b)
    return kA.length == kB.length && kA.every((k2) => a[k2] == b[k2])
  }
})
EditorState.languageData = languageData
EditorState.changeFilter = changeFilter
EditorState.transactionFilter = transactionFilter
EditorState.transactionExtender = transactionExtender
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define()
function combineConfig(configs, defaults, combine = {}) {
  let result = {}
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key],
        current = result[key]
      if (current === void 0) result[key] = value
      else if (current === value || value === void 0);
      else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value)
      else throw new Error('Config merge conflict for field ' + key)
    }
  for (let key in defaults) if (result[key] === void 0) result[key] = defaults[key]
  return result
}
class RangeValue {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range$1.create(from, to, this)
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0
RangeValue.prototype.point = false
RangeValue.prototype.mapMode = MapMode.TrackDel
let Range$1 = class Range {
  constructor(from, to, value) {
    this.from = from
    this.to = to
    this.value = value
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new Range(from, to, value)
  }
}
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide
}
class Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from
    this.to = to
    this.value = value
    this.maxPoint = maxPoint
  }
  get length() {
    return this.to[this.to.length - 1]
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi) return lo
      let mid = (lo + hi) >> 1
      let diff =
        arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side
      if (mid == lo) return diff >= 0 ? lo : hi
      if (diff >= 0) hi = mid
      else lo = mid + 1
    }
  }
  between(offset, from, to, f) {
    for (
      let i = this.findIndex(from, -1e9, true), e2 = this.findIndex(to, 1e9, false, i);
      i < e2;
      i++
    )
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false
  }
  map(offset, changes) {
    let value = [],
      from = [],
      to = [],
      newPos = -1,
      maxPoint = -1
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i],
        curFrom = this.from[i] + offset,
        curTo = this.to[i] + offset,
        newFrom,
        newTo
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode)
        if (mapped == null) continue
        newFrom = newTo = mapped
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide)
          if (newTo < newFrom) continue
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide)
        newTo = changes.mapPos(curTo, val.endSide)
        if (newFrom > newTo || (newFrom == newTo && val.startSide > 0 && val.endSide <= 0)) continue
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue
      if (newPos < 0) newPos = newFrom
      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom)
      value.push(val)
      from.push(newFrom - newPos)
      to.push(newTo - newPos)
    }
    return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos }
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos
    this.chunk = chunk
    this.nextLayer = nextLayer
    this.maxPoint = maxPoint
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint)
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length)
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty) return 0
    let size = this.nextLayer.size
    for (let chunk of this.chunk) size += chunk.value.length
    return size
  }
  /**
  @internal
  */
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec
    let filter = updateSpec.filter
    if (add3.length == 0 && !filter) return this
    if (sort) add3 = add3.slice().sort(cmpRange)
    if (this.isEmpty) return add3.length ? RangeSet.of(add3) : this
    let cur2 = new LayerCursor(this, null, -1).goto(0),
      i = 0,
      spill = []
    let builder = new RangeSetBuilder()
    while (cur2.value || i < add3.length) {
      if (
        i < add3.length &&
        (cur2.from - add3[i].from || cur2.startSide - add3[i].value.startSide) >= 0
      ) {
        let range = add3[i++]
        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range)
      } else if (
        cur2.rangeIndex == 1 &&
        cur2.chunkIndex < this.chunk.length &&
        (i == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i].from) &&
        (!filter ||
          filterFrom > this.chunkEnd(cur2.chunkIndex) ||
          filterTo < this.chunkPos[cur2.chunkIndex]) &&
        builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])
      ) {
        cur2.nextChunk()
      } else {
        if (
          !filter ||
          filterFrom > cur2.to ||
          filterTo < cur2.from ||
          filter(cur2.from, cur2.to, cur2.value)
        ) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range$1.create(cur2.from, cur2.to, cur2.value))
        }
        cur2.next()
      }
    }
    return builder.finishInner(
      this.nextLayer.isEmpty && !spill.length
        ? RangeSet.empty
        : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo })
    )
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty) return this
    let chunks = [],
      chunkPos = [],
      maxPoint = -1
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
        chunk = this.chunk[i]
      let touch = changes.touchesRange(start, start + chunk.length)
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint)
        chunks.push(chunk)
        chunkPos.push(changes.mapPos(start))
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes)
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint)
          chunks.push(mapped)
          chunkPos.push(pos)
        }
      }
    }
    let next = this.nextLayer.map(changes)
    return chunks.length == 0
      ? next
      : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint)
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty) return
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
        chunk = this.chunk[i]
      if (
        to >= start &&
        from <= start + chunk.length &&
        chunk.between(start, from - start, to - start, f) === false
      )
        return
    }
    this.nextLayer.between(from, to, f)
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from)
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from)
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter(
      (set2) => set2.maxPoint > 0 || (!set2.isEmpty && set2.maxPoint >= minPointSize)
    )
    let b = newSets.filter(
      (set2) => set2.maxPoint > 0 || (!set2.isEmpty && set2.maxPoint >= minPointSize)
    )
    let sharedChunks = findSharedChunks(a, b, textDiff)
    let sideA = new SpanCursor(a, sharedChunks, minPointSize)
    let sideB = new SpanCursor(b, sharedChunks, minPointSize)
    textDiff.iterGaps((fromA, fromB, length) =>
      compare(sideA, fromA, sideB, fromB, length, comparator)
    )
    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator)
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null) to = 1e9 - 1
    let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0)
    let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0)
    if (a.length != b.length) return false
    if (!a.length) return true
    let sharedChunks = findSharedChunks(a, b)
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
      sideB = new SpanCursor(b, sharedChunks, 0).goto(from)
    for (;;) {
      if (
        sideA.to != sideB.to ||
        !sameValues(sideA.active, sideB.active) ||
        (sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
      )
        return false
      if (sideA.to > to) return true
      sideA.next()
      sideB.next()
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from),
      pos = from
    let openRanges = cursor2.openStart
    for (;;) {
      let curTo = Math.min(cursor2.to, to)
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to)
        let openCount =
          cursor2.pointFrom < from
            ? active.length + 1
            : cursor2.point.startSide < 0
              ? active.length
              : Math.min(active.length, openRanges)
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank)
        openRanges = Math.min(cursor2.openEnd(curTo), active.length)
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges)
        openRanges = cursor2.openEnd(curTo)
      }
      if (cursor2.to > to) return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0)
      pos = cursor2.to
      cursor2.next()
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder()
    for (let range of ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value)
    return build.finish()
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length) return RangeSet.empty
    let result = sets[sets.length - 1]
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer2 = sets[i]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer)
        result = new RangeSet(
          layer2.chunkPos,
          layer2.chunk,
          result,
          Math.max(layer2.maxPoint, result.maxPoint)
        )
    }
    return result
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1)
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur2 = ranges[i]
      if (cmpRange(prev, cur2) > 0) return ranges.slice().sort(cmpRange)
      prev = cur2
    }
  return ranges
}
RangeSet.empty.nextLayer = RangeSet.empty
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint))
    this.chunkPos.push(this.chunkStart)
    this.chunkStart = -1
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)
    this.maxPoint = -1
    if (newArrays) {
      this.from = []
      this.to = []
      this.value = []
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = []
    this.chunkPos = []
    this.chunkStart = -1
    this.last = null
    this.lastFrom = -1e9
    this.lastTo = -1e9
    this.from = []
    this.to = []
    this.value = []
    this.maxPoint = -1
    this.setMaxPoint = -1
    this.nextLayer = null
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value)
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error('Ranges must be added sorted by `from` position and `startSide`')
    if (diff < 0) return false
    if (this.from.length == 250) this.finishChunk(true)
    if (this.chunkStart < 0) this.chunkStart = from
    this.from.push(from - this.chunkStart)
    this.to.push(to - this.chunkStart)
    this.last = value
    this.lastFrom = from
    this.lastTo = to
    this.value.push(value)
    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from)
    return true
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false
    if (this.from.length) this.finishChunk(true)
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint)
    this.chunks.push(chunk)
    this.chunkPos.push(from)
    let last = chunk.value.length - 1
    this.last = chunk.value[last]
    this.lastFrom = chunk.from[last] + from
    this.lastTo = chunk.to[last] + from
    return true
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty)
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length) this.finishChunk(false)
    if (this.chunks.length == 0) return next
    let result = RangeSet.create(
      this.chunkPos,
      this.chunks,
      this.nextLayer ? this.nextLayer.finishInner(next) : next,
      this.setMaxPoint
    )
    this.from = null
    return result
  }
}
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map()
  for (let set2 of a)
    for (let i = 0; i < set2.chunk.length; i++)
      if (set2.chunk[i].maxPoint <= 0) inA.set(set2.chunk[i], set2.chunkPos[i])
  let shared = /* @__PURE__ */ new Set()
  for (let set2 of b)
    for (let i = 0; i < set2.chunk.length; i++) {
      let known = inA.get(set2.chunk[i])
      if (
        known != null &&
        (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i] &&
        !(textDiff === null || textDiff === void 0
          ? void 0
          : textDiff.touchesRange(known, known + set2.chunk[i].length))
      )
        shared.add(set2.chunk[i])
    }
  return shared
}
class LayerCursor {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2
    this.skip = skip
    this.minPoint = minPoint
    this.rank = rank
  }
  get startSide() {
    return this.value ? this.value.startSide : 0
  }
  get endSide() {
    return this.value ? this.value.endSide : 0
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0
    this.gotoInner(pos, side, false)
    return this
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex]
      if (
        !(
          (this.skip && this.skip.has(next)) ||
          this.layer.chunkEnd(this.chunkIndex) < pos ||
          next.maxPoint < this.minPoint
        )
      )
        break
      this.chunkIndex++
      forward = false
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(
        pos - this.layer.chunkPos[this.chunkIndex],
        side,
        true
      )
      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex)
    }
    this.next()
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true)
  }
  next() {
    for (;;) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9
        this.value = null
        break
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex],
          chunk = this.layer.chunk[this.chunkIndex]
        let from = chunkPos + chunk.from[this.rangeIndex]
        this.from = from
        this.to = chunkPos + chunk.to[this.rangeIndex]
        this.value = chunk.value[this.rangeIndex]
        this.setRangeIndex(this.rangeIndex + 1)
        if (this.minPoint < 0 || (this.value.point && this.to - this.from >= this.minPoint)) break
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++
      if (this.skip) {
        while (
          this.chunkIndex < this.layer.chunk.length &&
          this.skip.has(this.layer.chunk[this.chunkIndex])
        )
          this.chunkIndex++
      }
      this.rangeIndex = 0
    } else {
      this.rangeIndex = index2
    }
  }
  nextChunk() {
    this.chunkIndex++
    this.rangeIndex = 0
    this.next()
  }
  compare(other) {
    return (
      this.from - other.from ||
      this.startSide - other.startSide ||
      this.rank - other.rank ||
      this.to - other.to ||
      this.endSide - other.endSide
    )
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = []
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint) heap.push(new LayerCursor(cur2, skip, minPoint, i))
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap)
  }
  get startSide() {
    return this.value ? this.value.startSide : 0
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap) cur2.goto(pos, side)
    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i)
    this.next()
    return this
  }
  forward(pos, side) {
    for (let cur2 of this.heap) cur2.forward(pos, side)
    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i)
    if ((this.to - pos || this.value.endSide - side) < 0) this.next()
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9
      this.value = null
      this.rank = -1
    } else {
      let top2 = this.heap[0]
      this.from = top2.from
      this.to = top2.to
      this.value = top2.value
      this.rank = top2.rank
      if (top2.value) top2.next()
      heapBubble(this.heap, 0)
    }
  }
}
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1
    if (childIndex >= heap.length) break
    let child = heap[childIndex]
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1]
      childIndex++
    }
    if (cur2.compare(child) < 0) break
    heap[childIndex] = cur2
    heap[index2] = child
    index2 = childIndex
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint
    this.active = []
    this.activeTo = []
    this.activeRank = []
    this.minActive = -1
    this.point = null
    this.pointFrom = 0
    this.pointRank = 0
    this.to = -1e9
    this.endSide = 0
    this.openStart = -1
    this.cursor = HeapCursor.from(sets, skip, minPoint)
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side)
    this.active.length = this.activeTo.length = this.activeRank.length = 0
    this.minActive = -1
    this.to = pos
    this.endSide = side
    this.openStart = -1
    this.next()
    return this
  }
  forward(pos, side) {
    while (
      this.minActive > -1 &&
      (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0
    )
      this.removeActive(this.minActive)
    this.cursor.forward(pos, side)
  }
  removeActive(index2) {
    remove(this.active, index2)
    remove(this.activeTo, index2)
    remove(this.activeRank, index2)
    this.minActive = findMinIndex(this.active, this.activeTo)
  }
  addActive(trackOpen) {
    let i = 0,
      { value, to, rank } = this.cursor
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
      i++
    insert(this.active, i, value)
    insert(this.activeTo, i, to)
    insert(this.activeRank, i, rank)
    if (trackOpen) insert(trackOpen, i, this.cursor.from)
    this.minActive = findMinIndex(this.active, this.activeTo)
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to,
      wasPoint = this.point
    this.point = null
    let trackOpen = this.openStart < 0 ? [] : null
    for (;;) {
      let a = this.minActive
      if (
        a > -1 &&
        (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0
      ) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a]
          this.endSide = this.active[a].endSide
          break
        }
        this.removeActive(a)
        if (trackOpen) remove(trackOpen, a)
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9
        break
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from
        this.endSide = this.cursor.startSide
        break
      } else {
        let nextVal = this.cursor.value
        if (!nextVal.point) {
          this.addActive(trackOpen)
          this.cursor.next()
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next()
        } else {
          this.point = nextVal
          this.pointFrom = this.cursor.from
          this.pointRank = this.cursor.rank
          this.to = this.cursor.to
          this.endSide = nextVal.endSide
          this.cursor.next()
          this.forward(this.to, this.endSide)
          break
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--) this.openStart++
    }
  }
  activeForPoint(to) {
    if (!this.active.length) return this.active
    let active = []
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank) break
      if (
        this.activeTo[i] > to ||
        (this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
      )
        active.push(this.active[i])
    }
    return active.reverse()
  }
  openEnd(to) {
    let open = 0
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++
    return open
  }
}
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA)
  b.goto(startB)
  let endB = startB + length
  let pos = startB,
    dPos = startB - startA
  for (;;) {
    let dEnd = a.to + dPos - b.to,
      diff = dEnd || a.endSide - b.endSide
    let end = diff < 0 ? a.to + dPos : b.to,
      clipEnd = Math.min(end, endB)
    if (a.point || b.point) {
      if (
        !(
          a.point &&
          b.point &&
          (a.point == b.point || a.point.eq(b.point)) &&
          sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))
        )
      )
        comparator.comparePoint(pos, clipEnd, a.point, b.point)
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active)
    }
    if (end > endB) break
    if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange) comparator.boundChange(end)
    pos = end
    if (diff <= 0) a.next()
    if (diff >= 0) b.next()
  }
}
function sameValues(a, b) {
  if (a.length != b.length) return false
  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false
  return true
}
function remove(array, index2) {
  for (let i = index2, e2 = array.length - 1; i < e2; i++) array[i] = array[i + 1]
  array.pop()
}
function insert(array, index2, value) {
  for (let i = array.length - 1; i >= index2; i--) array[i + 1] = array[i]
  array[index2] = value
}
function findMinIndex(value, array) {
  let found = -1,
    foundPos = 1e9
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i
      foundPos = array[i]
    }
  return found
}
function countColumn(string2, tabSize, to = string2.length) {
  let n2 = 0
  for (let i = 0; i < to && i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n2 += tabSize - (n2 % tabSize)
      i++
    } else {
      n2++
      i = findClusterBreak(string2, i)
    }
  }
  return n2
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n2 = 0; ; ) {
    if (n2 >= col) return i
    if (i == string2.length) break
    n2 += string2.charCodeAt(i) == 9 ? tabSize - (n2 % tabSize) : 1
    i = findClusterBreak(string2, i)
  }
  return string2.length
}
const C = 'ͼ'
const COUNT = typeof Symbol == 'undefined' ? '__' + C : Symbol.for(C)
const SET =
  typeof Symbol == 'undefined' ? '__styleSet' + Math.floor(Math.random() * 1e8) : Symbol('styleSet')
const top =
  typeof globalThis != 'undefined' ? globalThis : typeof window != 'undefined' ? window : {}
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = []
    let { finish } = options || {}
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/)
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [],
        isAt = /^@(\w+)\b/.exec(selectors[0]),
        keyframes = isAt && isAt[1] == 'keyframes'
      if (isAt && spec2 == null) return target.push(selectors[0] + ';')
      for (let prop in spec2) {
        let value = spec2[prop]
        if (/&/.test(prop)) {
          render(
            prop
              .split(/,\s*/)
              .map((part) => selectors.map((sel) => part.replace(/&/, sel)))
              .reduce((a, b) => a.concat(b)),
            value,
            target
          )
        } else if (value && typeof value == 'object') {
          if (!isAt)
            throw new RangeError(
              'The value of a property (' + prop + ') should be a primitive value.'
            )
          render(splitSelector(prop), value, local, keyframes)
        } else if (value != null) {
          local.push(
            prop.replace(/_.*/, '').replace(/[A-Z]/g, (l) => '-' + l.toLowerCase()) +
              ': ' +
              value +
              ';'
          )
        }
      }
      if (local.length || keyframes) {
        target.push(
          (finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(', ') +
            ' {' +
            local.join(' ') +
            '}'
        )
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join('\n')
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1
    top[COUNT] = id2 + 1
    return C + id2.toString(36)
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set2 = root[SET],
      nonce = options && options.nonce
    if (!set2) set2 = new StyleSet(root, nonce)
    else if (nonce) set2.setNonce(nonce)
    set2.mount(Array.isArray(modules) ? modules : [modules], root)
  }
}
let adoptedSet = /* @__PURE__ */ new Map()
class StyleSet {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root,
      win = doc2.defaultView
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2)
      if (adopted) return (root[SET] = adopted)
      this.sheet = new win.CSSStyleSheet()
      adoptedSet.set(doc2, this)
    } else {
      this.styleTag = doc2.createElement('style')
      if (nonce) this.styleTag.setAttribute('nonce', nonce)
    }
    this.modules = []
    root[SET] = this
  }
  mount(modules, root) {
    let sheet = this.sheet
    let pos = 0,
      j = 0
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i],
        index2 = this.modules.indexOf(mod)
      if (index2 < j && index2 > -1) {
        this.modules.splice(index2, 1)
        j--
        index2 = -1
      }
      if (index2 == -1) {
        this.modules.splice(j++, 0, mod)
        if (sheet)
          for (let k2 = 0; k2 < mod.rules.length; k2++) sheet.insertRule(mod.rules[k2], pos++)
      } else {
        while (j < index2) pos += this.modules[j++].rules.length
        pos += mod.rules.length
        j++
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]
    } else {
      let text2 = ''
      for (let i = 0; i < this.modules.length; i++) text2 += this.modules[i].getRules() + '\n'
      this.styleTag.textContent = text2
      let target = root.head || root
      if (this.styleTag.parentNode != target) target.insertBefore(this.styleTag, target.firstChild)
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute('nonce') != nonce)
      this.styleTag.setAttribute('nonce', nonce)
  }
}
var base = {
  8: 'Backspace',
  9: 'Tab',
  10: 'Enter',
  12: 'NumLock',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  44: 'PrintScreen',
  45: 'Insert',
  46: 'Delete',
  59: ';',
  61: '=',
  91: 'Meta',
  92: 'Meta',
  106: '*',
  107: '+',
  108: ',',
  109: '-',
  110: '.',
  111: '/',
  144: 'NumLock',
  145: 'ScrollLock',
  160: 'Shift',
  161: 'Shift',
  162: 'Control',
  163: 'Control',
  164: 'Alt',
  165: 'Alt',
  173: '-',
  186: ';',
  187: '=',
  188: ',',
  189: '-',
  190: '.',
  191: '/',
  192: '`',
  219: '[',
  220: '\\',
  221: ']',
  222: "'"
}
var shift = {
  48: ')',
  49: '!',
  50: '@',
  51: '#',
  52: '$',
  53: '%',
  54: '^',
  55: '&',
  56: '*',
  57: '(',
  59: ':',
  61: '+',
  173: '_',
  186: ':',
  187: '+',
  188: '<',
  189: '_',
  190: '>',
  191: '?',
  192: '~',
  219: '{',
  220: '|',
  221: '}',
  222: '"'
}
var mac = typeof navigator != 'undefined' && /Mac/.test(navigator.platform)
var ie$1 =
  typeof navigator != 'undefined' &&
  /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)
for (var i = 1; i <= 24; i++) base[i + 111] = 'F' + i
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]
function keyName(event) {
  var ignoreKey =
    (mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey) ||
    (ie$1 && event.shiftKey && event.key && event.key.length == 1) ||
    event.key == 'Unidentified'
  var name2 =
    (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key ||
    'Unidentified'
  if (name2 == 'Esc') name2 = 'Escape'
  if (name2 == 'Del') name2 = 'Delete'
  if (name2 == 'Left') name2 = 'ArrowLeft'
  if (name2 == 'Up') name2 = 'ArrowUp'
  if (name2 == 'Right') name2 = 'ArrowRight'
  if (name2 == 'Down') name2 = 'ArrowDown'
  return name2
}
function crelt() {
  var elt2 = arguments[0]
  if (typeof elt2 == 'string') elt2 = document.createElement(elt2)
  var i = 1,
    next = arguments[1]
  if (next && typeof next == 'object' && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next)
      if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2]
        if (typeof value == 'string') elt2.setAttribute(name2, value)
        else if (value != null) elt2[name2] = value
      }
    i++
  }
  for (; i < arguments.length; i++) add2(elt2, arguments[i])
  return elt2
}
function add2(elt2, child) {
  if (typeof child == 'string') {
    elt2.appendChild(document.createTextNode(child))
  } else if (child == null);
  else if (child.nodeType != null) {
    elt2.appendChild(child)
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add2(elt2, child[i])
  } else {
    throw new RangeError('Unsupported child node: ' + child)
  }
}
function getSelection(root) {
  let target
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument
  } else {
    target = root
  }
  return target.getSelection()
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode) return false
  try {
    return contains(dom, selection2.anchorNode)
  } catch (_2) {
    return false
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects()
  else if (dom.nodeType == 1) return dom.getClientRects()
  else return []
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode
    ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1)
    : false
}
function domIndex(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling
    if (!node) return index2
  }
}
function isBlockElement(node) {
  return (
    node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName)
  )
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == 'DIV') return false
      let parent = node.parentNode
      if (!parent || parent.nodeType != 1) return false
      off = domIndex(node) + (dir < 0 ? 0 : 1)
      node = parent
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)]
      if (node.nodeType == 1 && node.contentEditable == 'false') return false
      off = dir < 0 ? maxOffset(node) : 0
    } else {
      return false
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}
function flattenRect(rect, left) {
  let x2 = left ? rect.left : rect.right
  return { left: x2, right: x2, top: rect.top, bottom: rect.bottom }
}
function windowRect(win) {
  let vp = win.visualViewport
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    }
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  }
}
function getScale(elt2, rect) {
  let scaleX = rect.width / elt2.offsetWidth
  let scaleY = rect.height / elt2.offsetHeight
  if (
    (scaleX > 0.995 && scaleX < 1.005) ||
    !isFinite(scaleX) ||
    Math.abs(rect.width - elt2.offsetWidth) < 1
  )
    scaleX = 1
  if (
    (scaleY > 0.995 && scaleY < 1.005) ||
    !isFinite(scaleY) ||
    Math.abs(rect.height - elt2.offsetHeight) < 1
  )
    scaleY = 1
  return { scaleX, scaleY }
}
function scrollRectIntoView(dom, rect, side, x2, y2, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument,
    win = doc2.defaultView || window
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding,
        top2 = cur2 == doc2.body
      let scaleX = 1,
        scaleY = 1
      if (top2) {
        bounding = windowRect(win)
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position)) stop = true
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode
          continue
        }
        let rect2 = cur2.getBoundingClientRect()
        ;({ scaleX, scaleY } = getScale(cur2, rect2))
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        }
      }
      let moveX = 0,
        moveY = 0
      if (y2 == 'nearest') {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin)
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin)
        }
      } else {
        let rectHeight = rect.bottom - rect.top,
          boundingHeight = bounding.bottom - bounding.top
        let targetTop =
          y2 == 'center' && rectHeight <= boundingHeight
            ? rect.top + rectHeight / 2 - boundingHeight / 2
            : y2 == 'start' || (y2 == 'center' && side < 0)
              ? rect.top - yMargin
              : rect.bottom - boundingHeight + yMargin
        moveY = targetTop - bounding.top
      }
      if (x2 == 'nearest') {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin)
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin)
        }
      } else {
        let targetLeft =
          x2 == 'center'
            ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2
            : (x2 == 'start') == ltr
              ? rect.left - xMargin
              : rect.right - (bounding.right - bounding.left) + xMargin
        moveX = targetLeft - bounding.left
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY)
        } else {
          let movedX = 0,
            movedY = 0
          if (moveY) {
            let start = cur2.scrollTop
            cur2.scrollTop += moveY / scaleY
            movedY = (cur2.scrollTop - start) * scaleY
          }
          if (moveX) {
            let start = cur2.scrollLeft
            cur2.scrollLeft += moveX / scaleX
            movedX = (cur2.scrollLeft - start) * scaleX
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          }
          if (movedX && Math.abs(movedX - moveX) < 1) x2 = 'nearest'
          if (movedY && Math.abs(movedY - moveY) < 1) y2 = 'nearest'
        }
      }
      if (top2) break
      if (
        rect.top < bounding.top ||
        rect.bottom > bounding.bottom ||
        rect.left < bounding.left ||
        rect.right > bounding.right
      )
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        }
      cur2 = cur2.assignedSlot || cur2.parentNode
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host
    } else {
      break
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument,
    x2,
    y2
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || (x2 && y2)) {
      break
    } else if (cur2.nodeType == 1) {
      if (!y2 && cur2.scrollHeight > cur2.clientHeight) y2 = cur2
      if (!x2 && cur2.scrollWidth > cur2.clientWidth) x2 = cur2
      cur2 = cur2.assignedSlot || cur2.parentNode
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host
    } else {
      break
    }
  }
  return { x: x2, y: y2 }
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null
    this.anchorOffset = 0
    this.focusNode = null
    this.focusOffset = 0
  }
  eq(domSel) {
    return (
      this.anchorNode == domSel.anchorNode &&
      this.anchorOffset == domSel.anchorOffset &&
      this.focusNode == domSel.focusNode &&
      this.focusOffset == domSel.focusOffset
    )
  }
  setRange(range) {
    let { anchorNode, focusNode } = range
    this.set(
      anchorNode,
      Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0),
      focusNode,
      Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0)
    )
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode
    this.anchorOffset = anchorOffset
    this.focusNode = focusNode
    this.focusOffset = focusOffset
  }
}
let preventScrollSupported = null
function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive()
  if (preventScrollSupported) return dom.focus(preventScrollSupported)
  let stack = []
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft)
    if (cur2 == cur2.ownerDocument) break
  }
  dom.focus(
    preventScrollSupported == null
      ? {
          get preventScroll() {
            preventScrollSupported = { preventScroll: true }
            return true
          }
        }
      : void 0
  )
  if (!preventScrollSupported) {
    preventScrollSupported = false
    for (let i = 0; i < stack.length; ) {
      let elt2 = stack[i++],
        top2 = stack[i++],
        left = stack[i++]
      if (elt2.scrollTop != top2) elt2.scrollTop = top2
      if (elt2.scrollLeft != left) elt2.scrollLeft = left
    }
  }
}
let scratchRange
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange())
  range.setEnd(node, to)
  range.setStart(node, from)
  return range
}
function dispatchKey(elt2, name2, code, mods) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true }
  if (mods)
    ({
      altKey: options.altKey,
      ctrlKey: options.ctrlKey,
      shiftKey: options.shiftKey,
      metaKey: options.metaKey
    } = mods)
  let down = new KeyboardEvent('keydown', options)
  down.synthetic = true
  elt2.dispatchEvent(down)
  let up = new KeyboardEvent('keyup', options)
  up.synthetic = true
  elt2.dispatchEvent(up)
  return down.defaultPrevented || up.defaultPrevented
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || (node.nodeType == 11 && node.host))) return node
    node = node.assignedSlot || node.parentNode
  }
  return null
}
function clearAttributes(node) {
  while (node.attributes.length) node.removeAttributeNode(node.attributes[0])
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode,
    offset = selection2.focusOffset
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset) return false
  offset = Math.min(offset, maxOffset(node))
  for (;;) {
    if (offset) {
      if (node.nodeType != 1) return false
      let prev = node.childNodes[offset - 1]
      if (prev.contentEditable == 'false') offset--
      else {
        node = prev
        offset = maxOffset(node)
      }
    } else if (node == doc2) {
      return true
    } else {
      offset = domIndex(node)
      node = node.parentNode
    }
  }
}
function isScrolledToBottom(elt2) {
  return elt2.scrollTop > Math.max(1, elt2.scrollHeight - elt2.clientHeight - 4)
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset }
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == 'false') return null
      node = node.childNodes[offset - 1]
      offset = maxOffset(node)
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node)
      node = node.parentNode
    } else {
      return null
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset }
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == 'false') return null
      node = node.childNodes[offset]
      offset = 0
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1
      node = node.parentNode
    } else {
      return null
    }
  }
}
class DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node
    this.offset = offset
    this.precise = precise
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise)
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise)
  }
}
const noChildren = []
class ContentView {
  constructor() {
    this.parent = null
    this.dom = null
    this.flags = 2
  }
  get overrideDOMText() {
    return null
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0
  }
  get posAtEnd() {
    return this.posAtStart + this.length
  }
  posBefore(view) {
    let pos = this.posAtStart
    for (let child of this.children) {
      if (child == view) return pos
      pos += child.length + child.breakAfter
    }
    throw new RangeError('Invalid child in posBefore')
  }
  posAfter(view) {
    return this.posBefore(view) + view.length
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom
      let prev = null,
        next
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = ContentView.get(next)
            if (!contentView || (!contentView.parent && contentView.canReuseDOM(child)))
              child.reuseDOM(next)
          }
          child.sync(view, track)
          child.flags &= -8
        }
        next = prev ? prev.nextSibling : parent.firstChild
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom) next = rm$1(next)
        } else {
          parent.insertBefore(child.dom, next)
        }
        prev = child.dom
      }
      next = prev ? prev.nextSibling : parent.firstChild
      if (next && track && track.node == parent) track.written = true
      while (next) next = rm$1(next)
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track)
          child.flags &= -8
        }
    }
  }
  reuseDOM(_dom) {}
  localPosFromDOM(node, offset) {
    let after
    if (node == this.dom) {
      after = this.dom.childNodes[offset]
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1
      for (;;) {
        let parent = node.parentNode
        if (parent == this.dom) break
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild) bias = -1
          else bias = 1
        }
        node = parent
      }
      if (bias < 0) after = node
      else after = node.nextSibling
    }
    if (after == this.dom.firstChild) return 0
    while (after && !ContentView.get(after)) after = after.nextSibling
    if (!after) return this.length
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i]
      if (child.dom == after) return pos
      pos += child.length + child.breakAfter
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1,
      fromStart = -1,
      toI = -1,
      toEnd = -1
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length
      if (pos < from && end > to) return child.domBoundsAround(from, to, pos)
      if (end >= from && fromI == -1) {
        fromI = i
        fromStart = pos
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i
        toEnd = prevEnd
        break
      }
      prevEnd = end
      pos = end + child.breakAfter
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    }
  }
  markDirty(andParent = false) {
    this.flags |= 2
    this.markParentsDirty(andParent)
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList) parent.flags |= 2
      if (parent.flags & 1) return
      parent.flags |= 1
      childList = false
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent
      if (this.flags & 7) this.markParentsDirty(true)
    }
  }
  setDOM(dom) {
    if (this.dom == dom) return
    if (this.dom) this.dom.cmView = null
    this.dom = dom
    dom.cmView = this
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent
      if (!parent) return v
      v = parent
    }
  }
  replaceChildren(from, to, children = noChildren) {
    this.markDirty()
    for (let i = from; i < to; i++) {
      let child = this.children[i]
      if (child.parent == this && children.indexOf(child) < 0) child.destroy()
    }
    if (children.length < 250) this.children.splice(from, to - from, ...children)
    else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to))
    for (let i = 0; i < children.length; i++) children[i].setParent(this)
  }
  ignoreMutation(_rec) {
    return false
  }
  ignoreEvent(_event) {
    return false
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length)
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias)
  }
  toString() {
    let name2 = this.constructor.name.replace('View', '')
    return (
      name2 +
      (this.children.length
        ? '(' + this.children.join() + ')'
        : this.length
          ? '[' + (name2 == 'Text' ? this.text : this.length) + ']'
          : '') +
      (this.breakAfter ? '#' : '')
    )
  }
  static get(node) {
    return node.cmView
  }
  get isEditable() {
    return true
  }
  get isWidget() {
    return false
  }
  get isHidden() {
    return false
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false
  }
  become(other) {
    return false
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8)
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0
  }
  destroy() {
    for (let child of this.children) if (child.parent == this) child.destroy()
    this.parent = null
  }
}
ContentView.prototype.breakAfter = 0
function rm$1(dom) {
  let next = dom.nextSibling
  dom.parentNode.removeChild(dom)
  return next
}
class ChildCursor {
  constructor(children, pos, i) {
    this.children = children
    this.pos = pos
    this.i = i
    this.off = 0
  }
  findPos(pos, bias = 1) {
    for (;;) {
      if (
        pos > this.pos ||
        (pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
      ) {
        this.off = pos - this.pos
        return this
      }
      let next = this.children[--this.i]
      this.pos -= next.length + next.breakAfter
    }
  }
}
function replaceRange(
  parent,
  fromI,
  fromOff,
  toI,
  toOff,
  insert2,
  breakAtStart,
  openStart,
  openEnd
) {
  let { children } = parent
  let before = children.length ? children[fromI] : null
  let last = insert2.length ? insert2[insert2.length - 1] : null
  let breakAtEnd = last ? last.breakAfter : breakAtStart
  if (
    fromI == toI &&
    before &&
    !breakAtStart &&
    !breakAtEnd &&
    insert2.length < 2 &&
    before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd)
  )
    return
  if (toI < children.length) {
    let after = children[toI]
    if (
      after &&
      (toOff < after.length ||
        (after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter)))
    ) {
      if (fromI == toI) {
        after = after.split(toOff)
        toOff = 0
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after
      } else {
        if (toOff || (after.children.length && !after.children[0].length))
          after.merge(0, toOff, null, false, 0, openEnd)
        insert2.push(after)
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last) last.breakAfter = 1
      else breakAtStart = 1
    }
    toI++
  }
  if (before) {
    before.breakAfter = breakAtStart
    if (fromOff > 0) {
      if (
        !breakAtStart &&
        insert2.length &&
        before.merge(fromOff, before.length, insert2[0], false, openStart, 0)
      ) {
        before.breakAfter = insert2.shift().breakAfter
      } else if (
        fromOff < before.length ||
        (before.children.length && before.children[before.children.length - 1].length == 0)
      ) {
        before.merge(fromOff, before.length, null, false, openStart, 0)
      }
      fromI++
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--
      insert2.pop()
      openEnd = insert2.length ? 0 : openStart
    } else if (children[fromI].become(insert2[0])) {
      fromI++
      insert2.shift()
      openStart = insert2.length ? 0 : openEnd
    } else {
      break
    }
  }
  if (
    !insert2.length &&
    fromI &&
    toI < children.length &&
    !children[fromI - 1].breakAfter &&
    children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)
  )
    fromI--
  if (fromI < toI || insert2.length) parent.replaceChildren(fromI, toI, insert2)
}
function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor()
  let { i: toI, off: toOff } = cur2.findPos(to, 1)
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1)
  let dLen = from - to
  for (let view of insert2) dLen += view.length
  parent.length += dLen
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd)
}
let nav = typeof navigator != 'undefined' ? navigator : { userAgent: '', vendor: '', platform: '' }
let doc = typeof document != 'undefined' ? document : { documentElement: { style: {} } }
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent)
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent)
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent)
const ie = !!(ie_upto10 || ie_11up || ie_edge)
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent)
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent)
const webkit = 'webkitFontSmoothing' in doc.documentElement.style
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor)
const ios = safari && /* @__PURE__ */ (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2)
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ (/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1]) : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  safari,
  webkit_version: webkit
    ? +(/* @__PURE__ */ (/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1])
    : 0,
  tabSize: doc.documentElement.style.tabSize != null ? 'tab-size' : '-moz-tab-size'
}
const MaxJoinLen = 256
class TextView extends ContentView {
  constructor(text2) {
    super()
    this.text = text2
  }
  get length() {
    return this.text.length
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text))
  }
  sync(view, track) {
    if (!this.dom) this.createDOM()
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom) track.written = true
      this.dom.nodeValue = this.text
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3) this.createDOM(dom)
  }
  merge(from, to, source) {
    if (
      this.flags & 8 ||
      (source &&
        (!(source instanceof TextView) ||
          this.length - (to - from) + source.length > MaxJoinLen ||
          source.flags & 8))
    )
      return false
    this.text = this.text.slice(0, from) + (source ? source.text : '') + this.text.slice(to)
    this.markDirty()
    return true
  }
  split(from) {
    let result = new TextView(this.text.slice(from))
    this.text = this.text.slice(0, from)
    this.markDirty()
    result.flags |= this.flags & 8
    return result
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos)
  }
  domBoundsAround(_from, _to, offset) {
    return {
      from: offset,
      to: offset + this.length,
      startDOM: this.dom,
      endDOM: this.dom.nextSibling
    }
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side)
  }
}
class MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super()
    this.mark = mark
    this.children = children
    this.length = length
    for (let ch of children) ch.setParent(this)
  }
  setAttrs(dom) {
    clearAttributes(dom)
    if (this.mark.class) dom.className = this.mark.class
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs) dom.setAttribute(name2, this.mark.attrs[name2])
    return dom
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8)
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node)
      this.flags |= 4 | 2
    }
  }
  sync(view, track) {
    if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)))
    else if (this.flags & 4) this.setAttrs(this.dom)
    super.sync(view, track)
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (
      source &&
      (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
        (from && openStart <= 0) ||
        (to < this.length && openEnd <= 0))
    )
      return false
    mergeChildrenInto(
      this,
      from,
      to,
      source ? source.children.slice() : [],
      openStart - 1,
      openEnd - 1
    )
    this.markDirty()
    return true
  }
  split(from) {
    let result = [],
      off = 0,
      detachFrom = -1,
      i = 0
    for (let elt2 of this.children) {
      let end = off + elt2.length
      if (end > from) result.push(off < from ? elt2.split(from - off) : elt2)
      if (detachFrom < 0 && off >= from) detachFrom = i
      off = end
      i++
    }
    let length = this.length - from
    this.length = from
    if (detachFrom > -1) {
      this.children.length = detachFrom
      this.markDirty()
    }
    return new MarkView(this.mark, result, length)
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos)
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side)
  }
}
function textCoords(text2, pos, side) {
  let length = text2.nodeValue.length
  if (pos > length) pos = length
  let from = pos,
    to = pos,
    flatten2 = 0
  if ((pos == 0 && side < 0) || (pos == length && side >= 0)) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--
        flatten2 = 1
      } else if (to < length) {
        to++
        flatten2 = -1
      }
    }
  } else {
    if (side < 0) from--
    else if (to < length) to++
  }
  let rects = textRange(text2, from, to).getClientRects()
  if (!rects.length) return null
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1]
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null
}
class WidgetView extends ContentView {
  static create(widget, length, side) {
    return new WidgetView(widget, length, side)
  }
  constructor(widget, length, side) {
    super()
    this.widget = widget
    this.length = length
    this.side = side
    this.prevWidget = null
  }
  split(from) {
    let result = WidgetView.create(this.widget, this.length - from, this.side)
    this.length -= from
    return result
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom)
      this.prevWidget = null
      this.setDOM(this.widget.toDOM(view))
      if (!this.widget.editable) this.dom.contentEditable = 'false'
    }
  }
  getSide() {
    return this.side
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (
      source &&
      (!(source instanceof WidgetView) ||
        !this.widget.compare(source.widget) ||
        (from > 0 && openStart <= 0) ||
        (to < this.length && openEnd <= 0))
    )
      return false
    this.length = from + (source ? source.length : 0) + (this.length - to)
    return true
  }
  become(other) {
    if (
      other instanceof WidgetView &&
      other.side == this.side &&
      this.widget.constructor == other.widget.constructor
    ) {
      if (!this.widget.compare(other.widget)) this.markDirty(true)
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget
      this.widget = other.widget
      this.length = other.length
      return true
    }
    return false
  }
  ignoreMutation() {
    return true
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event)
  }
  get overrideDOMText() {
    if (this.length == 0) return Text.empty
    let top2 = this
    while (top2.parent) top2 = top2.parent
    let { view } = top2,
      text2 = view && view.state.doc,
      start = this.posAtStart
    return text2 ? text2.slice(start, start + this.length) : Text.empty
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0)
      ? DOMPos.before(this.dom)
      : DOMPos.after(this.dom, pos == this.length)
  }
  domBoundsAround() {
    return null
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side)
    if (custom) return custom
    let rects = this.dom.getClientRects(),
      rect = null
    if (!rects.length) return null
    let fromBack = this.side ? this.side < 0 : pos > 0
    for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
      rect = rects[i]
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break
    }
    return flattenRect(rect, !fromBack)
  }
  get isEditable() {
    return false
  }
  get isWidget() {
    return true
  }
  get isHidden() {
    return this.widget.isHidden
  }
  destroy() {
    super.destroy()
    if (this.dom) this.widget.destroy(this.dom)
  }
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super()
    this.side = side
  }
  get length() {
    return 0
  }
  merge() {
    return false
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side
  }
  split() {
    return new WidgetBufferView(this.side)
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement('img')
      dom.className = 'cm-widgetBuffer'
      dom.setAttribute('aria-hidden', 'true')
      this.setDOM(dom)
    }
  }
  getSide() {
    return this.side
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom)
  }
  localPosFromDOM() {
    return 0
  }
  domBoundsAround() {
    return null
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect()
  }
  get overrideDOMText() {
    return Text.empty
  }
  get isHidden() {
    return true
  }
}
TextView.prototype.children =
  WidgetView.prototype.children =
  WidgetBufferView.prototype.children =
    noChildren
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom,
    { children } = parent,
    i = 0
  for (let off = 0; i < children.length; i++) {
    let child = children[i],
      end = off + child.length
    if (end == off && child.getSide() <= 0) continue
    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off)
    if (pos <= off) break
    off = end
  }
  for (let j = i; j > 0; j--) {
    let prev = children[j - 1]
    if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length)
  }
  for (let j = i; j < children.length; j++) {
    let next = children[j]
    if (next.dom.parentNode == dom) return next.domAtPos(0)
  }
  return new DOMPos(dom, 0)
}
function joinInlineInto(parent, view, open) {
  let last,
    { children } = parent
  if (
    open > 0 &&
    view instanceof MarkView &&
    children.length &&
    (last = children[children.length - 1]) instanceof MarkView &&
    last.mark.eq(view.mark)
  ) {
    joinInlineInto(last, view.children[0], open - 1)
  } else {
    children.push(view)
    view.setParent(parent)
  }
  parent.length += view.length
}
function coordsInChildren(view, pos, side) {
  let before = null,
    beforePos = -1,
    after = null,
    afterPos = -1
  function scan(view2, pos2) {
    for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
      let child = view2.children[i],
        end = off + child.length
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off)
        } else if (
          (!after || (after.isHidden && (side > 0 || onSameLine(after, child)))) &&
          (end > pos2 || (off == end && child.getSide() > 0))
        ) {
          after = child
          afterPos = pos2 - off
        } else if (off < pos2 || (off == end && child.getSide() < 0 && !child.isHidden)) {
          before = child
          beforePos = pos2 - off
        }
      }
      off = end
    }
  }
  scan(view, pos)
  let target = (side < 0 ? before : after) || before || after
  if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side)
  return fallbackRect(view)
}
function fallbackRect(view) {
  let last = view.dom.lastChild
  if (!last) return view.dom.getBoundingClientRect()
  let rects = clientRectsFor(last)
  return rects[rects.length - 1] || null
}
function onSameLine(a, b) {
  let posA = a.coordsAt(0, 1),
    posB = b.coordsAt(0, 1)
  return posA && posB && posB.top < posA.bottom
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == 'class' && target.class) target.class += ' ' + source.class
    else if (name2 == 'style' && target.style) target.style += ';' + source.style
    else target[name2] = source[name2]
  }
  return target
}
const noAttrs$1 = /* @__PURE__ */ Object.create(null)
function attrsEq(a, b, ignore) {
  if (a == b) return true
  if (!a) a = noAttrs$1
  if (!b) b = noAttrs$1
  let keysA = Object.keys(a),
    keysB = Object.keys(b)
  if (
    keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
    keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)
  )
    return false
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false
  }
  return true
}
function updateAttrs(dom, prev, attrs) {
  let changed = false
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true
        if (name2 == 'style') dom.style.cssText = ''
        else dom.removeAttribute(name2)
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true
        if (name2 == 'style') dom.style.cssText = attrs[name2]
        else dom.setAttribute(name2, attrs[name2])
      }
  }
  return changed
}
function getAttrs$2(dom) {
  let attrs = /* @__PURE__ */ Object.create(null)
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i]
    attrs[attr.name] = attr.value
  }
  return attrs
}
class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || (this.constructor == other.constructor && this.eq(other))
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null
  }
  /**
  @internal
  */
  get isHidden() {
    return false
  }
  /**
  @internal
  */
  get editable() {
    return false
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {}
}
var BlockType = /* @__PURE__ */ (function (BlockType2) {
  BlockType2[(BlockType2['Text'] = 0)] = 'Text'
  BlockType2[(BlockType2['WidgetBefore'] = 1)] = 'WidgetBefore'
  BlockType2[(BlockType2['WidgetAfter'] = 2)] = 'WidgetAfter'
  BlockType2[(BlockType2['WidgetRange'] = 3)] = 'WidgetRange'
  return BlockType2
})(BlockType || (BlockType = {}))
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super()
    this.startSide = startSide
    this.endSide = endSide
    this.widget = widget
    this.spec = spec
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec)
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)),
      block2 = !!spec.block
    side += block2 && !spec.inlineOrder ? (side > 0 ? 3e8 : -4e8) : side > 0 ? 1e8 : -1e8
    return new PointDecoration(spec, side, side, block2, spec.widget || null, false)
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block2 = !!spec.block,
      startSide,
      endSide
    if (spec.isBlockGap) {
      startSide = -5e8
      endSide = 4e8
    } else {
      let { start, end } = getInclusive(spec, block2)
      startSide = (start ? (block2 ? -3e8 : -1) : 5e8) - 1
      endSide = (end ? (block2 ? 2e8 : 1) : -6e8) + 1
    }
    return new PointDecoration(spec, startSide, endSide, block2, spec.widget || null, true)
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec)
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort)
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false
  }
}
Decoration.none = RangeSet.empty
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec)
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec)
    this.tagName = spec.tagName || 'span'
    this.class = spec.class || ''
    this.attrs = spec.attributes || null
  }
  eq(other) {
    var _a2, _b
    return (
      this == other ||
      (other instanceof MarkDecoration &&
        this.tagName == other.tagName &&
        (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) ==
          (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
        attrsEq(this.attrs, other.attrs, 'class'))
    )
  }
  range(from, to = from) {
    if (from >= to) throw new RangeError('Mark decorations may not be empty')
    return super.range(from, to)
  }
}
MarkDecoration.prototype.point = false
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec)
  }
  eq(other) {
    return (
      other instanceof LineDecoration &&
      this.spec.class == other.spec.class &&
      attrsEq(this.spec.attributes, other.spec.attributes)
    )
  }
  range(from, to = from) {
    if (to != from) throw new RangeError('Line decoration ranges must be zero-length')
    return super.range(from, to)
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore
LineDecoration.prototype.point = true
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block2, widget, isReplace) {
    super(startSide, endSide, widget, spec)
    this.block = block2
    this.isReplace = isReplace
    this.mapMode = !block2
      ? MapMode.TrackDel
      : startSide <= 0
        ? MapMode.TrackBefore
        : MapMode.TrackAfter
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide
      ? BlockType.WidgetRange
      : this.startSide <= 0
        ? BlockType.WidgetBefore
        : BlockType.WidgetAfter
  }
  get heightRelevant() {
    return (
      this.block ||
      (!!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0))
    )
  }
  eq(other) {
    return (
      other instanceof PointDecoration &&
      widgetsEq(this.widget, other.widget) &&
      this.block == other.block &&
      this.startSide == other.startSide &&
      this.endSide == other.endSide
    )
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
      throw new RangeError('Invalid range for replacement decoration')
    if (!this.isReplace && to != from)
      throw new RangeError('Widget decorations can only have zero-length ranges')
    return super.range(from, to)
  }
}
PointDecoration.prototype.point = true
function getInclusive(spec, block2 = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec
  if (start == null) start = spec.inclusive
  if (end == null) end = spec.inclusive
  return {
    start: start !== null && start !== void 0 ? start : block2,
    end: end !== null && end !== void 0 ? end : block2
  }
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b))
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1
  if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to)
  else ranges.push(from, to)
}
class LineView extends ContentView {
  constructor() {
    super(...arguments)
    this.children = []
    this.length = 0
    this.prevAttrs = void 0
    this.attrs = null
    this.breakAfter = 0
  }
  // Consumes source
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView)) return false
      if (!this.dom) source.transferDOM(this)
    }
    if (hasStart) this.setDeco(source ? source.attrs : null)
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd)
    return true
  }
  split(at) {
    let end = new LineView()
    end.breakAfter = this.breakAfter
    if (this.length == 0) return end
    let { i, off } = this.childPos(at)
    if (off) {
      end.append(this.children[i].split(off), 0)
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0)
      i++
    }
    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0)
    while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy()
    this.children.length = i
    this.markDirty()
    this.length = at
    return end
  }
  transferDOM(other) {
    if (!this.dom) return
    this.markDirty()
    other.setDOM(this.dom)
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs
    this.prevAttrs = void 0
    this.dom = null
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs
        this.markDirty()
      }
      this.attrs = attrs
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart)
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes,
      cls = deco.spec.class
    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {})
    if (cls) this.attrs = combineAttrs({ class: cls }, this.attrs || {})
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos)
  }
  reuseDOM(node) {
    if (node.nodeName == 'DIV') {
      this.setDOM(node)
      this.flags |= 4 | 2
    }
  }
  sync(view, track) {
    var _a2
    if (!this.dom) {
      this.setDOM(document.createElement('div'))
      this.dom.className = 'cm-line'
      this.prevAttrs = this.attrs ? null : void 0
    } else if (this.flags & 4) {
      clearAttributes(this.dom)
      this.dom.className = 'cm-line'
      this.prevAttrs = this.attrs ? null : void 0
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs)
      this.dom.classList.add('cm-line')
      this.prevAttrs = void 0
    }
    super.sync(view, track)
    let last = this.dom.lastChild
    while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild
    if (
      !last ||
      !this.length ||
      (last.nodeName != 'BR' &&
        ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) ==
          false &&
        (!browser.ios || !this.children.some((ch) => ch instanceof TextView)))
    ) {
      let hack = document.createElement('BR')
      hack.cmIgnore = true
      this.dom.appendChild(hack)
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null
    let totalWidth = 0,
      textHeight
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null
      let rects = clientRectsFor(child.dom)
      if (rects.length != 1) return null
      totalWidth += rects[0].width
      textHeight = rects[0].height
    }
    return !totalWidth
      ? null
      : {
          lineHeight: this.dom.getBoundingClientRect().height,
          charWidth: totalWidth / this.length,
          textHeight
        }
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side)
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState,
        height = rect.bottom - rect.top
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2
        return {
          top: rect.top + dist2,
          bottom: rect.bottom - dist2,
          left: rect.left,
          right: rect.left
        }
      }
    }
    return rect
  }
  become(other) {
    return (
      other instanceof LineView &&
      this.children.length == 0 &&
      other.children.length == 0 &&
      attrsEq(this.attrs, other.attrs) &&
      this.breakAfter == other.breakAfter
    )
  }
  covers() {
    return true
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block2 = docView.children[i],
        end = off + block2.length
      if (end >= pos) {
        if (block2 instanceof LineView) return block2
        if (end > pos) break
      }
      off = end + block2.breakAfter
    }
    return null
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super()
    this.widget = widget
    this.length = length
    this.deco = deco
    this.breakAfter = 0
    this.prevWidget = null
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (
      source &&
      (!(source instanceof BlockWidgetView) ||
        !this.widget.compare(source.widget) ||
        (from > 0 && openStart <= 0) ||
        (to < this.length && openEnd <= 0))
    )
      return false
    this.length = from + (source ? source.length : 0) + (this.length - to)
    return true
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length)
  }
  split(at) {
    let len = this.length - at
    this.length = at
    let end = new BlockWidgetView(this.widget, len, this.deco)
    end.breakAfter = this.breakAfter
    return end
  }
  get children() {
    return noChildren
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom)
      this.prevWidget = null
      this.setDOM(this.widget.toDOM(view))
      if (!this.widget.editable) this.dom.contentEditable = 'false'
    }
  }
  get overrideDOMText() {
    return this.parent
      ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd)
      : Text.empty
  }
  domBoundsAround() {
    return null
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget)) this.markDirty(true)
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget
      this.widget = other.widget
      this.length = other.length
      this.deco = other.deco
      this.breakAfter = other.breakAfter
      return true
    }
    return false
  }
  ignoreMutation() {
    return true
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event)
  }
  get isEditable() {
    return false
  }
  get isWidget() {
    return true
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side)
    if (custom) return custom
    if (this.widget instanceof BlockGapWidget) return null
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0)
  }
  destroy() {
    super.destroy()
    if (this.dom) this.widget.destroy(this.dom)
  }
  covers(side) {
    let { startSide, endSide } = this.deco
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0
  }
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super()
    this.height = height
  }
  toDOM() {
    let elt2 = document.createElement('div')
    elt2.className = 'cm-gap'
    this.updateDOM(elt2)
    return elt2
  }
  eq(other) {
    return other.height == this.height
  }
  updateDOM(elt2) {
    elt2.style.height = this.height + 'px'
    return true
  }
  get editable() {
    return true
  }
  get estimatedHeight() {
    return this.height
  }
  ignoreEvent() {
    return false
  }
}
class ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2
    this.pos = pos
    this.end = end
    this.disallowBlockEffectsFor = disallowBlockEffectsFor
    this.content = []
    this.curLine = null
    this.breakAtStart = 0
    this.pendingBuffer = 0
    this.bufferMarks = []
    this.atCursorPos = true
    this.openStart = -1
    this.openEnd = -1
    this.text = ''
    this.textOff = 0
    this.cursor = doc2.iter()
    this.skip = pos
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos
    let last = this.content[this.content.length - 1]
    return !(last.breakAfter || (last instanceof BlockWidgetView && last.deco.endSide < 0))
  }
  getLine() {
    if (!this.curLine) {
      this.content.push((this.curLine = new LineView()))
      this.atCursorPos = true
    }
    return this.curLine
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length)
      this.pendingBuffer = 0
    }
  }
  addBlockWidget(view) {
    this.flushBuffer()
    this.curLine = null
    this.content.push(view)
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer()
    else this.pendingBuffer = 0
    if (
      !this.posCovered() &&
      !(
        openEnd &&
        this.content.length &&
        this.content[this.content.length - 1] instanceof BlockWidgetView
      )
    )
      this.getLine()
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip)
        this.skip = 0
        if (done) throw new Error('Ran out of text content when drawing inline views')
        if (lineBreak) {
          if (!this.posCovered()) this.getLine()
          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1
          else this.breakAtStart = 1
          this.flushBuffer()
          this.curLine = null
          this.atCursorPos = true
          length--
          continue
        } else {
          this.text = value
          this.textOff = 0
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      )
      this.flushBuffer(active.slice(active.length - openStart))
      this.getLine().append(
        wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active),
        openStart
      )
      this.atCursorPos = true
      this.textOff += take
      length -= take
      openStart = 0
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart)
    this.pos = to
    if (this.openStart < 0) this.openStart = openStart
  }
  point(from, to, deco, active, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block) throw new RangeError('Block decorations may not be specified via plugins')
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError(
          'Decorations that replace line breaks may not be specified via plugins'
        )
    }
    let len = to - from
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered()) this.getLine()
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco))
      } else {
        let view = WidgetView.create(
          deco.widget || NullWidget.inline,
          len,
          len ? 0 : deco.startSide
        )
        let cursorBefore =
          this.atCursorPos &&
          !view.isEditable &&
          openStart <= active.length &&
          (from < to || deco.startSide > 0)
        let cursorAfter =
          !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0)
        let line = this.getLine()
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable) this.pendingBuffer = 0
        this.flushBuffer(active)
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart)
          openStart = active.length + Math.max(0, openStart - active.length)
        }
        line.append(wrapMarks(view, active), openStart)
        this.atCursorPos = cursorAfter
        this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2
        if (this.pendingBuffer) this.bufferMarks = active.slice()
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco)
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len
      } else {
        this.skip += len - (this.text.length - this.textOff)
        this.text = ''
        this.textOff = 0
      }
      this.pos = to
    }
    if (this.openStart < 0) this.openStart = openStart
  }
  static build(text2, from, to, decorations2, dynamicDecorationMap) {
    let builder = new ContentBuilder(text2, from, to, dynamicDecorationMap)
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder)
    if (builder.openStart < 0) builder.openStart = builder.openEnd
    builder.finish(builder.openEnd)
    return builder
  }
}
function wrapMarks(view, active) {
  for (let mark of active) view = new MarkView(mark, [view], view.length)
  return view
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super()
    this.tag = tag
  }
  eq(other) {
    return other.tag == this.tag
  }
  toDOM() {
    return document.createElement(this.tag)
  }
  updateDOM(elt2) {
    return elt2.nodeName.toLowerCase() == this.tag
  }
  get isHidden() {
    return true
  }
}
NullWidget.inline = /* @__PURE__ */ new NullWidget('span')
NullWidget.block = /* @__PURE__ */ new NullWidget('div')
var Direction = /* @__PURE__ */ (function (Direction2) {
  Direction2[(Direction2['LTR'] = 0)] = 'LTR'
  Direction2[(Direction2['RTL'] = 1)] = 'RTL'
  return Direction2
})(Direction || (Direction = {}))
const LTR = Direction.LTR,
  RTL = Direction.RTL
function dec(str) {
  let result = []
  for (let i = 0; i < str.length; i++) result.push(1 << +str[i])
  return result
}
const LowTypes = /* @__PURE__ */ dec(
  '88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008'
)
const ArabicTypes = /* @__PURE__ */ dec(
  '4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333'
)
const Brackets = /* @__PURE__ */ Object.create(null),
  BracketStack = []
for (let p of ['()', '[]', '{}']) {
  let l = /* @__PURE__ */ p.charCodeAt(0),
    r2 = /* @__PURE__ */ p.charCodeAt(1)
  Brackets[l] = r2
  Brackets[r2] = -l
}
function charType(ch) {
  return ch <= 247
    ? LowTypes[ch]
    : 1424 <= ch && ch <= 1524
      ? 2
      : 1536 <= ch && ch <= 1785
        ? ArabicTypes[ch - 1536]
        : 1774 <= ch && ch <= 2220
          ? 4
          : 8192 <= ch && ch <= 8204
            ? 256
            : 64336 <= ch && ch <= 65023
              ? 4
              : 1
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/
class BidiSpan {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR
  }
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from
    this.to = to
    this.level = level
  }
  /**
  @internal
  */
  side(end, dir) {
    return (this.dir == dir) == end ? this.to : this.from
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir)
  }
  /**
  @internal
  */
  static find(order, index2, level, assoc) {
    let maybe = -1
    for (let i = 0; i < order.length; i++) {
      let span = order[i]
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level) return i
        if (
          maybe < 0 ||
          (assoc != 0
            ? assoc < 0
              ? span.from < index2
              : span.to > index2
            : order[maybe].level > span.level)
        )
          maybe = i
      }
    }
    if (maybe < 0) throw new RangeError('Index out of range')
    return maybe
  }
}
function isolatesEq(a, b) {
  if (a.length != b.length) return false
  for (let i = 0; i < a.length; i++) {
    let iA = a[i],
      iB = b[i]
    if (
      iA.from != iB.from ||
      iA.to != iB.to ||
      iA.direction != iB.direction ||
      !isolatesEq(iA.inner, iB.inner)
    )
      return false
  }
  return true
}
const types = []
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo
    let prevType = iI ? 256 : outerType
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i))
      if (type == 512) type = prev
      else if (type == 8 && prevStrong == 4) type = 16
      types[i] = type == 4 ? 2 : type
      if (type & 7) prevStrong = type
      prev = type
    }
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i]
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24) type = types[i] = prev
        else types[i] = 256
      } else if (type == 64) {
        let end = i + 1
        while (end < to && types[end] == 64) end++
        let replace2 =
          (i && prev == 8) || (end < rTo && types[end] == 8) ? (prevStrong == 1 ? 1 : 8) : 256
        for (let j = i; j < end; j++) types[j] = replace2
        i = end - 1
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1
      }
      prev = type
      if (type & 7) prevStrong = type
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo
    for (let i = from, ch, br, type; i < to; i++) {
      if ((br = Brackets[(ch = line.charCodeAt(i))])) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2]
              let type2 =
                flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType
              if (type2) types[i] = types[BracketStack[sJ]] = type2
              sI = sJ
              break
            }
          }
        } else if (BracketStack.length == 189) {
          break
        } else {
          BracketStack[sI++] = i
          BracketStack[sI++] = ch
          BracketStack[sI++] = context
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType
        context = embed ? 0 : 1
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2]
          if (cur2 & 2) break
          if (embed) {
            BracketStack[sJ + 2] |= 2
          } else {
            if (cur2 & 4) break
            BracketStack[sJ + 2] |= 4
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo
    for (let i = from; i < to; ) {
      let type = types[i]
      if (type == 256) {
        let end = i + 1
        for (;;) {
          if (end == to) {
            if (iI == isolates.length) break
            end = isolates[iI++].to
            to = iI < isolates.length ? isolates[iI].from : rTo
          } else if (types[end] == 256) {
            end++
          } else {
            break
          }
        }
        let beforeL = prev == 1
        let afterL = (end < rTo ? types[end] : outerType) == 1
        let replace2 = beforeL == afterL ? (beforeL ? 1 : 2) : outerType
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
          if (j == fromJ) {
            j = isolates[--jI].from
            fromJ = jI ? isolates[jI - 1].to : rFrom
          }
          types[--j] = replace2
        }
        i = end
      } else {
        prev = type
        i++
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true,
        isNum = false
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh]
        if (next != ourType) {
          sameDir = false
          isNum = next == 16
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null
      let localLevel = sameDir ? level : level + 1
      let iScan = iCh
      run: for (;;) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum) break run
          let iso = isolates[iI]
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to) break run
              if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to
              else if (types[upto] == ourType) break run
              else break
            }
          iI++
          if (recurse) {
            recurse.push(iso)
          } else {
            if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel))
            let dirSwap = (iso.direction == LTR) != !(localLevel % 2)
            computeSectionOrder(
              line,
              dirSwap ? level + 1 : level,
              baseLevel,
              iso.inner,
              iso.from,
              iso.to,
              order
            )
            iCh = iso.to
          }
          iScan = iso.to
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break
        } else {
          iScan++
        }
      }
      if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order)
      else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel))
      iCh = iScan
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true,
        isNum = false
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1]
        if (next != ourType) {
          sameDir = false
          isNum = next == 16
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null
      let localLevel = sameDir ? level : level + 1
      let iScan = iCh
      run: for (;;) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum) break run
          let iso = isolates[--iI]
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from) break run
              if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from
              else if (types[upto - 1] == ourType) break run
              else break
            }
          if (recurse) {
            recurse.push(iso)
          } else {
            if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel))
            let dirSwap = (iso.direction == LTR) != !(localLevel % 2)
            computeSectionOrder(
              line,
              dirSwap ? level + 1 : level,
              baseLevel,
              iso.inner,
              iso.from,
              iso.to,
              order
            )
            iCh = iso.from
          }
          iScan = iso.from
        } else if (
          iScan == from ||
          (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)
        ) {
          break
        } else {
          iScan--
        }
      }
      if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order)
      else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel))
      iCh = iScan
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1
  computeCharTypes(line, from, to, isolates, outerType)
  processBracketPairs(line, from, to, isolates, outerType)
  processNeutrals(from, to, isolates, outerType)
  emitSpans(line, from, to, level, baseLevel, isolates, order)
}
function computeOrder(line, direction, isolates) {
  if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)]
  if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length)
  if (isolates.length) while (line.length > types.length) types[types.length] = 256
  let order = [],
    level = direction == LTR ? 0 : 1
  computeSectionOrder(line, level, level, isolates, 0, line.length, order)
  return order
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)]
}
let movedOver = ''
function moveVisually(line, order, dir, start, forward) {
  var _a2
  let startIndex = start.head - line.from
  let spanI = BidiSpan.find(
    order,
    startIndex,
    (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1,
    start.assoc
  )
  let span = order[spanI],
    spanEnd = span.side(forward, dir)
  if (startIndex == spanEnd) {
    let nextI = (spanI += forward ? 1 : -1)
    if (nextI < 0 || nextI >= order.length) return null
    span = order[(spanI = nextI)]
    startIndex = span.side(!forward, dir)
    spanEnd = span.side(forward, dir)
  }
  let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir))
  if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex))
  let nextSpan =
    spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)]
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(
      nextSpan.side(!forward, dir) + line.from,
      nextSpan.forward(forward, dir) ? 1 : -1,
      nextSpan.level
    )
  return EditorSelection.cursor(
    nextIndex + line.from,
    span.forward(forward, dir) ? -1 : 1,
    span.level
  )
}
function autoDirection(text2, from, to) {
  for (let i = from; i < to; i++) {
    let type = charType(text2.charCodeAt(i))
    if (type == 1) return LTR
    if (type == 2 || type == 4) return RTL
  }
  return LTR
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define()
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define()
const mouseSelectionStyle = /* @__PURE__ */ Facet.define()
const exceptionSink = /* @__PURE__ */ Facet.define()
const updateListener = /* @__PURE__ */ Facet.define()
const inputHandler = /* @__PURE__ */ Facet.define()
const focusChangeEffect = /* @__PURE__ */ Facet.define()
const clipboardInputFilter = /* @__PURE__ */ Facet.define()
const clipboardOutputFilter = /* @__PURE__ */ Facet.define()
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x2) => x2)
})
const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x2) => x2)
})
const scrollHandler = /* @__PURE__ */ Facet.define()
class ScrollTarget {
  constructor(range, y2 = 'nearest', x2 = 'nearest', yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range
    this.y = y2
    this.x = x2
    this.yMargin = yMargin
    this.xMargin = xMargin
    this.isSnapshot = isSnapshot
  }
  map(changes) {
    return changes.empty
      ? this
      : new ScrollTarget(
          this.range.map(changes),
          this.y,
          this.x,
          this.yMargin,
          this.xMargin,
          this.isSnapshot
        )
  }
  clip(state) {
    return this.range.to <= state.doc.length
      ? this
      : new ScrollTarget(
          EditorSelection.cursor(state.doc.length),
          this.y,
          this.x,
          this.yMargin,
          this.xMargin,
          this.isSnapshot
        )
  }
}
const scrollIntoView$1 = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) })
const setEditContextFormatting = /* @__PURE__ */ StateEffect.define()
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink)
  if (handler.length) handler[0](exception)
  else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception));
  else if (context) console.error(context + ':', exception)
  else console.error(exception)
}
const editable = /* @__PURE__ */ Facet.define({
  combine: (values2) => (values2.length ? values2[0] : true)
})
let nextPluginID = 0
const viewPlugin = /* @__PURE__ */ Facet.define({
  combine(plugins) {
    return plugins.filter((p, i) => {
      for (let j = 0; j < i; j++) if (plugins[j].plugin == p.plugin) return false
      return true
    })
  }
})
class ViewPlugin {
  constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2
    this.create = create
    this.domEventHandlers = domEventHandlers
    this.domEventObservers = domEventObservers
    this.baseExtensions = buildExtensions(this)
    this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }))
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(arg) {
    return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }))
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, eventObservers, provide: provide2, decorations: deco } = spec || {}
    return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
      let ext = []
      if (deco)
        ext.push(
          decorations.of((view) => {
            let pluginInst = view.plugin(plugin)
            return pluginInst ? deco(pluginInst) : Decoration.none
          })
        )
      if (provide2) ext.push(provide2(plugin))
      return ext
    })
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return ViewPlugin.define((view, arg) => new cls(view, arg), spec)
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec
    this.mustUpdate = null
    this.value = null
  }
  get plugin() {
    return this.spec && this.spec.plugin
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.plugin.create(view, this.spec.arg)
        } catch (e2) {
          logException(view.state, e2, 'CodeMirror plugin crashed')
          this.deactivate()
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate
      this.mustUpdate = null
      if (this.value.update) {
        try {
          this.value.update(update)
        } catch (e2) {
          logException(update.state, e2, 'CodeMirror plugin crashed')
          if (this.value.destroy)
            try {
              this.value.destroy()
            } catch (_2) {}
          this.deactivate()
        }
      }
    }
    return this
  }
  destroy(view) {
    var _a2
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy()
      } catch (e2) {
        logException(view.state, e2, 'CodeMirror plugin crashed')
      }
    }
  }
  deactivate() {
    this.spec = this.value = null
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define()
const contentAttributes = /* @__PURE__ */ Facet.define()
const decorations = /* @__PURE__ */ Facet.define()
const outerDecorations = /* @__PURE__ */ Facet.define()
const atomicRanges = /* @__PURE__ */ Facet.define()
const bidiIsolatedRanges = /* @__PURE__ */ Facet.define()
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges)
  if (!isolates.length) return isolates
  let sets = isolates.map((i) => (i instanceof Function ? i(view) : i))
  let result = []
  RangeSet.spans(sets, line.from, line.to, {
    point() {},
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from,
        to = toDoc - line.from
      let level = result
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate,
          update
        if (direction == null) direction = autoDirection(line.text, from, to)
        if (
          open > 0 &&
          level.length &&
          (update = level[level.length - 1]).to == from &&
          update.direction == direction
        ) {
          update.to = to
          level = update.inner
        } else {
          let add3 = { from, to, direction, inner: [] }
          level.push(add3)
          level = add3.inner
        }
      }
    }
  })
  return result
}
const scrollMargins = /* @__PURE__ */ Facet.define()
function getScrollMargins(view) {
  let left = 0,
    right = 0,
    top2 = 0,
    bottom = 0
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view)
    if (m) {
      if (m.left != null) left = Math.max(left, m.left)
      if (m.right != null) right = Math.max(right, m.right)
      if (m.top != null) top2 = Math.max(top2, m.top)
      if (m.bottom != null) bottom = Math.max(bottom, m.bottom)
    }
  }
  return { left, right, top: top2, bottom }
}
const styleModule = /* @__PURE__ */ Facet.define()
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA
    this.toA = toA
    this.fromB = fromB
    this.toB = toB
  }
  join(other) {
    return new ChangedRange(
      Math.min(this.fromA, other.fromA),
      Math.max(this.toA, other.toA),
      Math.min(this.fromB, other.fromB),
      Math.max(this.toB, other.toB)
    )
  }
  addToSet(set2) {
    let i = set2.length,
      me = this
    for (; i > 0; i--) {
      let range = set2[i - 1]
      if (range.fromA > me.toA) continue
      if (range.toA < me.fromA) break
      me = me.join(range)
      set2.splice(i - 1, 1)
    }
    set2.splice(i, 0, me)
    return set2
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0) return diff
    let result = []
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI],
        off = posA - posB
      let end = next ? next.fromB : 1e9
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI],
          to = ranges[rI + 1]
        let fromB = Math.max(posB, from),
          toB = Math.min(end, to)
        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result)
        if (to > end) break
        else rI += 2
      }
      if (!next) return result
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result)
      posA = next.toA
      posB = next.toB
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view
    this.state = state
    this.transactions = transactions
    this.flags = 0
    this.startState = view.state
    this.changes = ChangeSet.empty(this.startState.doc.length)
    for (let tr of transactions) this.changes = this.changes.compose(tr.changes)
    let changedRanges = []
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) =>
      changedRanges.push(new ChangedRange(fromA, toA, fromB, toB))
    )
    this.changedRanges = changedRanges
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions)
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection)
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0
  }
}
class DocView extends ContentView {
  get length() {
    return this.view.state.doc.length
  }
  constructor(view) {
    super()
    this.view = view
    this.decorations = []
    this.dynamicDecorationMap = [false]
    this.domChanged = null
    this.hasComposition = null
    this.markedForComposition = /* @__PURE__ */ new Set()
    this.editContextFormatting = Decoration.none
    this.lastCompositionAfterCursor = false
    this.minWidth = 0
    this.minWidthFrom = 0
    this.minWidthTo = 0
    this.impreciseAnchor = null
    this.impreciseHead = null
    this.forceSelection = false
    this.lastUpdate = Date.now()
    this.setDOM(view.contentDOM)
    this.children = [new LineView()]
    this.children[0].setParent(this)
    this.updateDeco()
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null)
  }
  // Update the document view to a given state.
  update(update) {
    var _a2
    let changedRanges = update.changedRanges
    if (this.minWidth > 0 && changedRanges.length) {
      if (
        !changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)
      ) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1)
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1)
      }
    }
    this.updateEditContextFormatting(update)
    let readCompositionAt = -1
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head
    }
    let composition =
      readCompositionAt > -1
        ? findCompositionRange(this.view, update.changes, readCompositionAt)
        : null
    this.domChanged = null
    if (this.hasComposition) {
      this.markedForComposition.clear()
      let { from, to } = this.hasComposition
      changedRanges = new ChangedRange(
        from,
        to,
        update.changes.mapPos(from, -1),
        update.changes.mapPos(to, 1)
      ).addToSet(changedRanges.slice())
    }
    this.hasComposition = composition
      ? { from: composition.range.fromB, to: composition.range.toB }
      : null
    if (
      (browser.ie || browser.chrome) &&
      !composition &&
      update &&
      update.state.doc.lines != update.startState.doc.lines
    )
      this.forceSelection = true
    let prevDeco = this.decorations,
      deco = this.updateDeco()
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes)
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff)
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition)
      if (update.transactions.length) this.lastUpdate = Date.now()
      return true
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true
    this.updateChildren(changes, oldLength, composition)
    let { observer } = this.view
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + 'px'
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + 'px' : ''
      let track =
        browser.chrome || browser.ios
          ? { node: observer.selectionRange.focusNode, written: false }
          : void 0
      this.sync(this.view, track)
      this.flags &= -8
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true
      this.dom.style.height = ''
    })
    this.markedForComposition.forEach(
      (cView) => (cView.flags &= -9)
      /* ViewFlag.Composition */
    )
    let gaps = []
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom)
    }
    observer.updateGaps(gaps)
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes
    let cursor2 = this.childCursor(oldLength)
    for (let i = ranges.length - 1; ; i--) {
      let next = i >= 0 ? ranges[i] : null
      if (!next) break
      let { fromA, toA, fromB, toB } = next,
        content2,
        breakAtStart,
        openStart,
        openEnd
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(
          this.view.state.doc,
          fromB,
          composition.range.fromB,
          this.decorations,
          this.dynamicDecorationMap
        )
        let after = ContentBuilder.build(
          this.view.state.doc,
          composition.range.toB,
          toB,
          this.decorations,
          this.dynamicDecorationMap
        )
        breakAtStart = before.breakAtStart
        openStart = before.openStart
        openEnd = after.openEnd
        let compLine = this.compositionView(composition)
        if (after.breakAtStart) {
          compLine.breakAfter = 1
        } else if (
          after.content.length &&
          compLine.merge(
            compLine.length,
            compLine.length,
            after.content[0],
            false,
            after.openStart,
            0
          )
        ) {
          compLine.breakAfter = after.content[0].breakAfter
          after.content.shift()
        }
        if (
          before.content.length &&
          compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)
        ) {
          before.content.pop()
        }
        content2 = before.content.concat(compLine).concat(after.content)
      } else {
        ;({
          content: content2,
          breakAtStart,
          openStart,
          openEnd
        } = ContentBuilder.build(
          this.view.state.doc,
          fromB,
          toB,
          this.decorations,
          this.dynamicDecorationMap
        ))
      }
      let { i: toI, off: toOff } = cursor2.findPos(toA, 1)
      let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1)
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd)
    }
    if (composition) this.fixCompositionDOM(composition)
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes)
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value
        }
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue)
    cur2.flags |= 8
    for (let { deco } of composition.marks) cur2 = new MarkView(deco, [cur2], cur2.length)
    let line = new LineView()
    line.append(cur2, 0)
    return line
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |=
        8 |
        (cView2.children.some(
          (c) => c.flags & 7
          /* ViewFlag.Dirty */
        )
          ? 1
          : 0)
      this.markedForComposition.add(cView2)
      let prev = ContentView.get(dom)
      if (prev && prev != cView2) prev.dom = null
      cView2.setDOM(dom)
    }
    let pos = this.childPos(composition.range.fromB, 1)
    let cView = this.children[pos.i]
    fix(composition.line, cView)
    for (let i = composition.marks.length - 1; i >= -1; i--) {
      pos = cView.childPos(pos.off, 1)
      cView = cView.children[pos.i]
      fix(i >= 0 ? composition.marks[i].node : composition.text, cView)
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange()
    let activeElt = this.view.root.activeElement,
      focused = activeElt == this.dom
    let selectionNotFocus =
      !focused &&
      !(this.view.state.facet(editable) || this.dom.tabIndex > -1) &&
      hasSelection(this.dom, this.view.observer.selectionRange) &&
      !(activeElt && this.dom.contains(activeElt))
    if (!(focused || fromPointer || selectionNotFocus)) return
    let force = this.forceSelection
    this.forceSelection = false
    let main = this.view.state.selection.main
    let anchor = this.moveToLine(this.domAtPos(main.anchor))
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head))
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode('')
      this.view.observer.ignore(() =>
        anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null)
      )
      anchor = head = new DOMPos(dummy, 0)
      force = true
    }
    let domSel = this.view.observer.selectionRange
    if (
      force ||
      !domSel.focusNode ||
      ((!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
        !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) &&
        !this.suppressWidgetCursorChange(domSel, main))
    ) {
      this.view.observer.ignore(() => {
        if (
          browser.android &&
          browser.chrome &&
          this.dom.contains(domSel.focusNode) &&
          inUneditable(domSel.focusNode, this.dom)
        ) {
          this.dom.blur()
          this.dom.focus({ preventScroll: true })
        }
        let rawSel = getSelection(this.view.root)
        if (!rawSel);
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset)
            if (nextTo && nextTo != (1 | 2)) {
              let text2 = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset)
              if (text2) anchor = new DOMPos(text2.node, text2.offset)
            }
          }
          rawSel.collapse(anchor.node, anchor.offset)
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset)
          try {
            rawSel.extend(head.node, head.offset)
          } catch (_2) {}
        } else {
          let range = document.createRange()
          if (main.anchor > main.head) [anchor, head] = [head, anchor]
          range.setEnd(head.node, head.offset)
          range.setStart(anchor.node, anchor.offset)
          rawSel.removeAllRanges()
          rawSel.addRange(range)
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur()
          if (activeElt) activeElt.focus()
        }
      })
      this.view.observer.setSelectionRange(anchor, head)
    }
    this.impreciseAnchor = anchor.precise
      ? null
      : new DOMPos(domSel.anchorNode, domSel.anchorOffset)
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset)
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return (
      this.hasComposition &&
      cursor2.empty &&
      isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &&
      this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head
    )
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return
    let { view } = this,
      cursor2 = view.state.selection.main
    let sel = getSelection(view.root)
    let { anchorNode, anchorOffset } = view.observer.selectionRange
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify) return
    let line = LineView.find(this, cursor2.head)
    if (!line) return
    let lineStart = line.posAtStart
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length) return
    let before = this.coordsAt(cursor2.head, -1),
      after = this.coordsAt(cursor2.head, 1)
    if (!before || !after || before.bottom > after.top) return
    let dom = this.domAtPos(cursor2.head + cursor2.assoc)
    sel.collapse(dom.node, dom.offset)
    sel.modify('move', cursor2.assoc < 0 ? 'forward' : 'backward', 'lineboundary')
    view.observer.readSelectionRange()
    let newRange = view.observer.selectionRange
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset)
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom,
      newPos
    if (pos.node != dom) return pos
    for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
      let view = ContentView.get(dom.childNodes[i])
      if (view instanceof LineView) newPos = view.domAtPos(0)
    }
    for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
      let view = ContentView.get(dom.childNodes[i])
      if (view instanceof LineView) newPos = view.domAtPos(view.length)
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2)
      if (domView && domView.rootView == this) return domView
      cur2 = cur2.parentNode
    }
    return null
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node)
    if (!view)
      throw new RangeError('Trying to find position for a DOM position outside of the document')
    return view.localPosFromDOM(node, offset) + view.posAtStart
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1)
    for (; i < this.children.length - 1; ) {
      let child = this.children[i]
      if (off < child.length || child instanceof LineView) break
      i++
      off = 0
    }
    return this.children[i].domAtPos(off)
  }
  coordsAt(pos, side) {
    let best = null,
      bestPos = 0
    for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
      let child = this.children[i],
        end = off - child.breakAfter,
        start = end - child.length
      if (end < pos) break
      if (
        start <= pos &&
        (start < pos || child.covers(-1)) &&
        (end > pos || child.covers(1)) &&
        (!best || (child instanceof LineView && !(best instanceof LineView && side >= 0)))
      ) {
        best = child
        bestPos = start
      } else if (
        best &&
        start == pos &&
        end == pos &&
        child instanceof BlockWidgetView &&
        Math.abs(side) < 2
      ) {
        if (child.deco.startSide < 0) break
        else if (i) best = null
      }
      off = start
    }
    return best ? best.coordsAt(pos - bestPos, side) : null
  }
  coordsForChar(pos) {
    let { i, off } = this.childPos(pos, 1),
      child = this.children[i]
    if (!(child instanceof LineView)) return null
    while (child.children.length) {
      let { i: i2, off: childOff } = child.childPos(off, 1)
      for (; ; i2++) {
        if (i2 == child.children.length) return null
        if ((child = child.children[i2]).length) break
      }
      off = childOff
    }
    if (!(child instanceof TextView)) return null
    let end = findClusterBreak(child.text, off)
    if (end == off) return null
    let rects = textRange(child.dom, off, end).getClientRects()
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2]
      if (i2 == rects.length - 1 || (rect.top < rect.bottom && rect.left < rect.right)) return rect
    }
    return null
  }
  measureVisibleLineHeights(viewport) {
    let result = [],
      { from, to } = viewport
    let contentWidth = this.view.contentDOM.clientWidth
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1
    let widest = -1,
      ltr = this.view.textDirection == Direction.LTR
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length
      if (end > to) break
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect()
        result.push(childRect.height)
        if (isWider) {
          let last = child.dom.lastChild
          let rects = last ? clientRectsFor(last) : []
          if (rects.length) {
            let rect = rects[rects.length - 1]
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left
            if (width > widest) {
              widest = width
              this.minWidth = contentWidth
              this.minWidthFrom = pos
              this.minWidthTo = end
            }
          }
        }
      }
      pos = end + child.breakAfter
    }
    return result
  }
  textDirectionAt(pos) {
    let { i } = this.childPos(pos, 1)
    return getComputedStyle(this.children[i].dom).direction == 'rtl' ? Direction.RTL : Direction.LTR
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize()
        if (measure) return measure
      }
    }
    let dummy = document.createElement('div'),
      lineHeight,
      charWidth,
      textHeight
    dummy.className = 'cm-line'
    dummy.style.width = '99999px'
    dummy.style.position = 'absolute'
    dummy.textContent = 'abc def ghi jkl mno pqr stu'
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy)
      let rect = clientRectsFor(dummy.firstChild)[0]
      lineHeight = dummy.getBoundingClientRect().height
      charWidth = rect ? rect.width / 27 : 7
      textHeight = rect ? rect.height : lineHeight
      dummy.remove()
    })
    return { lineHeight, charWidth, textHeight }
  }
  childCursor(pos = this.length) {
    let i = this.children.length
    if (i) pos -= this.children[--i].length
    return new ChildCursor(this.children, pos, i)
  }
  computeBlockGapDeco() {
    let deco = [],
      vs = this.view.viewState
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i]
      let end = next ? next.from - 1 : this.length
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY
        deco.push(
          Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end)
        )
      }
      if (!next) break
      pos = next.to + 1
    }
    return Decoration.set(deco)
  }
  updateDeco() {
    let i = 1
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = (this.dynamicDecorationMap[i++] = typeof d == 'function')
      return dynamic ? d(this.view) : d
    })
    let dynamicOuter = false,
      outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
        let dynamic = typeof d == 'function'
        if (dynamic) dynamicOuter = true
        return dynamic ? d(this.view) : d
      })
    if (outerDeco.length) {
      this.dynamicDecorationMap[i++] = dynamicOuter
      allDeco.push(RangeSet.join(outerDeco))
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]
    while (i < this.decorations.length) this.dynamicDecorationMap[i++] = false
    return this.decorations
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref2 = this.view.viewState.lineBlockAt(target.range.head)
      this.view.scrollDOM.scrollTop = ref2.top - target.yMargin
      this.view.scrollDOM.scrollLeft = target.xMargin
      return
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target)) return true
      } catch (e2) {
        logException(this.view.state, e2, 'scroll handler')
      }
    }
    let { range } = target
    let rect = this.coordsAt(
        range.head,
        range.empty ? range.assoc : range.head > range.anchor ? -1 : 1
      ),
      other
    if (!rect) return
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      }
    let margins = getScrollMargins(this.view)
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    }
    let { offsetWidth, offsetHeight } = this.view.scrollDOM
    scrollRectIntoView(
      this.view.scrollDOM,
      targetRect,
      range.head < range.anchor ? -1 : 1,
      target.x,
      target.y,
      Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth),
      Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight),
      this.view.textDirection == Direction.LTR
    )
  }
}
function betweenUneditable(pos) {
  return (
    pos.node.nodeType == 1 &&
    pos.node.firstChild &&
    (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == 'false') &&
    (pos.offset == pos.node.childNodes.length ||
      pos.node.childNodes[pos.offset].contentEditable == 'false')
  )
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange
  if (!sel.focusNode) return null
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset)
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset)
  let textNode = textBefore || textAfter
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node)
    if (
      !descAfter ||
      (descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue)
    ) {
      textNode = textAfter
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node)
      if (
        !(
          !descBefore ||
          (descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)
        )
      )
        textNode = textAfter
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore
  if (!textNode) return null
  let from = headPos - textNode.offset
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node }
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos)
  if (!found) return null
  let { node: textNode, from, to } = found,
    text2 = textNode.nodeValue
  if (/[\n\r]/.test(text2)) return null
  if (view.state.doc.sliceString(found.from, found.to) != text2) return null
  let inv = changes.invertedDesc
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to)
  let marks = []
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent)
    if (parentView instanceof MarkView) marks.push({ node: parent, deco: parentView.mark })
    else if (
      parentView instanceof LineView ||
      (parent.nodeName == 'DIV' && parent.parentNode == view.contentDOM)
    )
      return { range, text: textNode, marks, line: parent }
    else if (parent != view.contentDOM)
      marks.push({
        node: parent,
        deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs$2(parent),
          tagName: parent.tagName.toLowerCase()
        })
      })
    else return null
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1) return 0
  return (
    (offset && node.childNodes[offset - 1].contentEditable == 'false' ? 1 : 0) |
    (offset < node.childNodes.length && node.childNodes[offset].contentEditable == 'false' ? 2 : 0)
  )
}
let DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = []
  }
  compareRange(from, to) {
    addRange(from, to, this.changes)
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes)
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes)
  }
}
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1()
  RangeSet.compare(a, b, diff, comp)
  return comp.changes
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == 'false') {
      return true
    }
  }
  return false
}
function touchesComposition(changes, composition) {
  let touched = false
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from) touched = true
    })
  return touched
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos)
  let line = state.doc.lineAt(pos),
    linePos = pos - line.from
  if (line.length == 0) return EditorSelection.cursor(pos)
  if (linePos == 0) bias = 1
  else if (linePos == line.length) bias = -1
  let from = linePos,
    to = linePos
  if (bias < 0) from = findClusterBreak(line.text, linePos, false)
  else to = findClusterBreak(line.text, linePos)
  let cat = categorize(line.text.slice(from, to))
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false)
    if (categorize(line.text.slice(prev, from)) != cat) break
    from = prev
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to)
    if (categorize(line.text.slice(to, next)) != cat) break
    to = next
  }
  return EditorSelection.range(from + line.from, to + line.from)
}
function getdx(x2, rect) {
  return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right)
}
function getdy(y2, rect) {
  return rect.top > y2 ? rect.top - y2 : Math.max(0, y2 - rect.bottom)
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1
}
function upTop(rect, top2) {
  return top2 < rect.top
    ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom }
    : rect
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect
}
function domPosAtCoords(parent, x2, y2) {
  let closest,
    closestRect,
    closestX,
    closestY,
    closestOverlap = false
  let above, below, aboveRect, belowRect
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child)
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i]
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top)
      let dx = getdx(x2, rect),
        dy = getdy(y2, rect)
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x2, y2) : domPosAtCoords(child, x2, y2)
      if (!closest || closestY > dy || (closestY == dy && closestX > dx)) {
        closest = child
        closestRect = rect
        closestX = dx
        closestY = dy
        closestOverlap = !dx ? true : x2 < rect.left ? i > 0 : i < rects.length - 1
      }
      if (dx == 0) {
        if (y2 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child
          aboveRect = rect
        } else if (y2 < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child
          belowRect = rect
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom)
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top)
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y2) {
    closest = above
    closestRect = aboveRect
  } else if (belowRect && belowRect.top <= y2) {
    closest = below
    closestRect = belowRect
  }
  if (!closest) return { node: parent, offset: 0 }
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2))
  if (closest.nodeType == 3) return domPosInText(closest, clipX, y2)
  if (closestOverlap && closest.contentEditable != 'false')
    return domPosAtCoords(closest, clipX, y2)
  let offset =
    Array.prototype.indexOf.call(parent.childNodes, closest) +
    (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0)
  return { node: parent, offset }
}
function domPosInText(node, x2, y2) {
  let len = node.nodeValue.length
  let closestOffset = -1,
    closestDY = 1e9,
    generalSide = 0
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects()
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j]
      if (rect.top == rect.bottom) continue
      if (!generalSide) generalSide = x2 - rect.left
      let dy = (rect.top > y2 ? rect.top - y2 : y2 - rect.bottom) - 1
      if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
        let right = x2 >= (rect.left + rect.right) / 2,
          after = right
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect()
          if (rectBefore.left == rect.right) after = !right
        }
        if (dy <= 0) return { node, offset: i + (after ? 1 : 0) }
        closestOffset = i + (after ? 1 : 0)
        closestDY = dy
      }
    }
  }
  return {
    node,
    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
  }
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b
  let content2 = view.contentDOM.getBoundingClientRect(),
    docTop = content2.top + view.viewState.paddingTop
  let block2,
    { docHeight } = view.viewState
  let { x: x2, y: y2 } = coords,
    yOffset = y2 - docTop
  if (yOffset < 0) return 0
  if (yOffset > docHeight) return view.state.doc.length
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block2 = view.elementAtHeight(yOffset)
    if (block2.type == BlockType.Text) break
    for (;;) {
      yOffset = bias > 0 ? block2.bottom + halfLine : block2.top - halfLine
      if (yOffset >= 0 && yOffset <= docHeight) break
      if (bounced) return precise ? null : 0
      bounced = true
      bias = -bias
    }
  }
  y2 = docTop + yOffset
  let lineStart = block2.from
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0
      ? 0
      : precise
        ? null
        : posAtCoordsImprecise(view, content2, block2, x2, y2)
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length
      ? view.state.doc.length
      : precise
        ? null
        : posAtCoordsImprecise(view, content2, block2, x2, y2)
  let doc2 = view.dom.ownerDocument
  let root = view.root.elementFromPoint ? view.root : doc2
  let element = root.elementFromPoint(x2, y2)
  if (element && !view.contentDOM.contains(element)) element = null
  if (!element) {
    x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2))
    element = root.elementFromPoint(x2, y2)
    if (element && !view.contentDOM.contains(element)) element = null
  }
  let node,
    offset = -1
  if (
    element &&
    ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) !=
      false
  ) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x2, y2)
      if (pos) ({ offsetNode: node, offset } = pos)
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x2, y2)
      if (range) {
        ;({ startContainer: node, startOffset: offset } = range)
        if (
          !view.contentDOM.contains(node) ||
          (browser.safari && isSuspiciousSafariCaretResult(node, offset, x2)) ||
          (browser.chrome && isSuspiciousChromeCaretResult(node, offset, x2))
        )
          node = void 0
      }
    }
    if (node) offset = Math.min(maxOffset(node), offset)
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart)
    if (!line) return yOffset > block2.top + block2.height / 2 ? block2.to : block2.from
    ;({ node, offset } = domPosAtCoords(line.dom, x2, y2))
  }
  let nearest = view.docView.nearest(node)
  if (!nearest) return null
  if (
    nearest.isWidget &&
    ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1
  ) {
    let rect = nearest.dom.getBoundingClientRect()
    return coords.y < rect.top ||
      (coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2)
      ? nearest.posAtStart
      : nearest.posAtEnd
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart
  }
}
function posAtCoordsImprecise(view, contentRect, block2, x2, y2) {
  let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth)
  if (view.lineWrapping && block2.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight
    let line = Math.floor(
      (y2 - block2.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight
    )
    into += line * view.viewState.heightOracle.lineLength
  }
  let content2 = view.state.sliceDoc(block2.from, block2.to)
  return block2.from + findColumn(content2, into, view.state.tabSize)
}
function isSuspiciousSafariCaretResult(node, offset, x2) {
  let len,
    scan = node
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false
  for (;;) {
    let next = scan.nextSibling
    if (next) {
      if (next.nodeName == 'BR') break
      return false
    } else {
      let parent = scan.parentNode
      if (!parent || parent.nodeName == 'DIV') break
      scan = parent
    }
  }
  return textRange(node, len - 1, len).getBoundingClientRect().right > x2
}
function isSuspiciousChromeCaretResult(node, offset, x2) {
  if (offset != 0) return false
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2) return false
    if (parent.classList.contains('cm-line')) break
    cur2 = parent
  }
  let rect =
    node.nodeType == 1
      ? node.getBoundingClientRect()
      : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect()
  return x2 - rect.left > 5
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos)
  if (Array.isArray(line.type)) {
    let best
    for (let l of line.type) {
      if (l.from > pos) break
      if (l.to < pos) continue
      if (l.from < pos && l.to > pos) return l
      if (
        !best ||
        (l.type == BlockType.Text &&
          (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos)))
      )
        best = l
    }
    return best || line
  }
  return line
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1)
  let coords =
    !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks)
      ? null
      : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head)
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect()
    let direction = view.textDirectionAt(line.from)
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    })
    if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1)
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1)
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head),
    spans = view.bidiSpans(line)
  let direction = view.textDirectionAt(line.from)
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward),
      char = movedOver
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1)) return cur2
      char = '\n'
      line = view.state.doc.line(line.number + (forward ? 1 : -1))
      spans = view.bidiSpans(line)
      next = view.visualLineSide(line, !forward)
    }
    if (!check) {
      if (!by) return next
      check = by(char)
    } else if (!check(char)) {
      return cur2
    }
    cur2 = next
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos)
  let cat = categorize(start)
  return (next) => {
    let nextCat = categorize(next)
    if (cat == CharCategory.Space) cat = nextCat
    return cat == nextCat
  }
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head,
    dir = forward ? 1 : -1
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc)
  let goal = start.goalColumn,
    startY
  let rect = view.contentDOM.getBoundingClientRect()
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1),
    docTop = view.documentTop
  if (startCoords) {
    if (goal == null) goal = startCoords.left - rect.left
    startY = dir < 0 ? startCoords.top : startCoords.bottom
  } else {
    let line = view.viewState.lineBlockAt(startPos)
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from))
    startY = (dir < 0 ? line.top : line.bottom) + docTop
  }
  let resolvedGoal = rect.left + goal
  let dist2 =
    distance !== null && distance !== void 0
      ? distance
      : view.viewState.heightOracle.textHeight >> 1
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir)
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos)
      let assoc = !charRect || curY < charRect.top ? -1 : 1
      return EditorSelection.cursor(pos, assoc, void 0, goal)
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (;;) {
    let moved = 0
    for (let set2 of atoms) {
      set2.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1)
          pos = side < 0 ? from : to
          moved = side
        }
      })
    }
    if (!moved) return pos
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(
    view.state.facet(atomicRanges).map((f) => f(view)),
    pos.from,
    oldPos.head > pos.from ? -1 : 1
  )
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1)
}
const LineBreakPlaceholder = '￿'
class DOMReader {
  constructor(points, state) {
    this.points = points
    this.text = ''
    this.lineSeparator = state.facet(EditorState.lineSeparator)
  }
  append(text2) {
    this.text += text2
  }
  lineBreak() {
    this.text += LineBreakPlaceholder
  }
  readRange(start, end) {
    if (!start) return this
    let parent = start.parentNode
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2)
      let oldLen = this.text.length
      this.readNode(cur2)
      let next = cur2.nextSibling
      if (next == end) break
      let view = ContentView.get(cur2),
        nextView = ContentView.get(next)
      if (
        view && nextView
          ? view.breakAfter
          : (view ? view.breakAfter : isBlockElement(cur2)) ||
            (isBlockElement(next) &&
              (cur2.nodeName != 'BR' || cur2.cmIgnore) &&
              this.text.length > oldLen)
      )
        this.lineBreak()
      cur2 = next
    }
    this.findPointBefore(parent, end)
    return this
  }
  readTextNode(node) {
    let text2 = node.nodeValue
    for (let point of this.points)
      if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text2.length)
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1,
        breakSize = 1,
        m
      if (this.lineSeparator) {
        nextBreak = text2.indexOf(this.lineSeparator, off)
        breakSize = this.lineSeparator.length
      } else if ((m = re.exec(text2))) {
        nextBreak = m.index
        breakSize = m[0].length
      }
      this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak))
      if (nextBreak < 0) break
      this.lineBreak()
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1
      }
      off = nextBreak + breakSize
    }
  }
  readNode(node) {
    if (node.cmIgnore) return
    let view = ContentView.get(node)
    let fromView = view && view.overrideDOMText
    if (fromView != null) {
      this.findPointInside(node, fromView.length)
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak) this.lineBreak()
        else this.append(i.value)
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node)
    } else if (node.nodeName == 'BR') {
      if (node.nextSibling) this.lineBreak()
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null)
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0)
  }
}
function isAtEnd(parent, node, offset) {
  for (;;) {
    if (!node || offset < maxOffset(node)) return false
    if (node == parent) return true
    offset = domIndex(node) + 1
    node = node.parentNode
  }
}
class DOMPoint {
  constructor(node, offset) {
    this.node = node
    this.offset = offset
    this.pos = -1
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver
    this.bounds = null
    this.text = ''
    this.domChanged = start > -1
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView
    if (view.state.readOnly && start > -1) {
      this.newSel = null
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view)
      let reader = new DOMReader(selPoints, view.state)
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM)
      this.text = reader.text
      this.newSel = selectionFromPoints(selPoints, this.bounds.from)
    } else {
      let domSel = view.observer.selectionRange
      let head =
        (iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset) ||
        !contains(view.contentDOM, domSel.focusNode)
          ? view.state.selection.main.head
          : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset)
      let anchor =
        (iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset) ||
        !contains(view.contentDOM, domSel.anchorNode)
          ? view.state.selection.main.anchor
          : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset)
      let vp = view.viewport
      if (
        (browser.ios || browser.chrome) &&
        view.state.selection.main.empty &&
        head != anchor &&
        (vp.from > 0 || vp.to < view.state.doc.length)
      ) {
        let from = Math.min(head, anchor),
          to = Math.max(head, anchor)
        let offFrom = vp.from - from,
          offTo = vp.to - to
        if (
          (offFrom == 0 || offFrom == 1 || from == 0) &&
          (offTo == 0 || offTo == -1 || to == view.state.doc.length)
        ) {
          head = 0
          anchor = view.state.doc.length
        }
      }
      this.newSel = EditorSelection.single(anchor, head)
    }
  }
}
function applyDOMChange(view, domChange) {
  let change
  let { newSel } = domChange,
    sel = view.state.selection.main
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1
  if (domChange.bounds) {
    let { from, to } = domChange.bounds
    let preferredPos = sel.from,
      preferredSide = null
    if (lastKey === 8 || (browser.android && domChange.text.length < to - from)) {
      preferredPos = sel.to
      preferredSide = 'end'
    }
    let diff = findDiff(
      view.state.doc.sliceString(from, to, LineBreakPlaceholder),
      domChange.text,
      preferredPos - from,
      preferredSide
    )
    if (diff) {
      if (
        browser.chrome &&
        lastKey == 13 &&
        diff.toB == diff.from + 2 &&
        domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder
      )
        diff.toB--
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      }
    }
  } else if (newSel && ((!view.hasFocus && view.state.facet(editable)) || newSel.main.eq(sel))) {
    newSel = null
  }
  if (!change && !newSel) return false
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) }
  } else if (
    (browser.mac || browser.android) &&
    change &&
    change.from == change.to &&
    change.from == sel.head - 1 &&
    /^\. ?$/.test(change.insert.toString()) &&
    view.contentDOM.getAttribute('autocorrect') == 'off'
  ) {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1)
    change = {
      from: change.from,
      to: change.to,
      insert: Text.of([change.insert.toString().replace('.', ' ')])
    }
  } else if (
    change &&
    change.from >= sel.from &&
    change.to <= sel.to &&
    (change.from != sel.from || change.to != sel.to) &&
    sel.to - sel.from - (change.to - change.from) <= 4
  ) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc
        .slice(sel.from, change.from)
        .append(change.insert)
        .append(view.state.doc.slice(change.to, sel.to))
    }
  } else if (
    browser.chrome &&
    change &&
    change.from == change.to &&
    change.from == sel.head &&
    change.insert.toString() == '\n ' &&
    view.lineWrapping
  ) {
    if (newSel) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1)
    change = { from: sel.from, to: sel.to, insert: Text.of([' ']) }
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey)
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false,
      userEvent = 'select'
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == 'select') scrollIntoView2 = true
      userEvent = view.inputState.lastSelectionOrigin
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent })
    return true
  } else {
    return false
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change)) return true
  let sel = view.state.selection.main
  if (
    browser.android &&
    ((change.to == sel.to && // GBoard will sometimes remove a space it just inserted
      // after a completion when you press enter
      (change.from == sel.from ||
        (change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == ' ')) &&
      change.insert.length == 1 &&
      change.insert.lines == 2 &&
      dispatchKey(view.contentDOM, 'Enter', 13)) ||
      (((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0) ||
        (lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head)) &&
        dispatchKey(view.contentDOM, 'Backspace', 8)) ||
      (change.from == sel.from &&
        change.to == sel.to + 1 &&
        change.insert.length == 0 &&
        dispatchKey(view.contentDOM, 'Delete', 46)))
  )
    return true
  let text2 = change.insert.toString()
  if (view.inputState.composing >= 0) view.inputState.composing++
  let defaultTr
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel))
  if (
    !view.state
      .facet(inputHandler)
      .some((h2) => h2(view, change.from, change.to, text2, defaultInsert))
  )
    view.dispatch(defaultInsert())
  return true
}
function applyDefaultInsert(view, change, newSel) {
  let tr,
    startState = view.state,
    sel = startState.selection.main
  if (
    change.from >= sel.from &&
    change.to <= sel.to &&
    change.to - change.from >= (sel.to - sel.from) / 3 &&
    (!newSel || (newSel.main.empty && newSel.main.from == change.from + change.insert.length)) &&
    view.inputState.composing < 0
  ) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : ''
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : ''
    tr = startState.replaceSelection(
      view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after)
    )
  } else {
    let changes = startState.changes(change)
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0
    if (
      startState.selection.ranges.length > 1 &&
      view.inputState.composing >= 0 &&
      change.to <= sel.to &&
      change.to >= sel.to - 10
    ) {
      let replaced = view.state.sliceDoc(change.from, change.to)
      let compositionRange,
        composition = newSel && findCompositionNode(view, newSel.main.head)
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from)
        compositionRange = { from: composition.from, to: composition.to - dLen }
      } else {
        compositionRange = view.state.doc.lineAt(sel.head)
      }
      let offset = sel.to - change.to,
        size = sel.to - sel.from
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) }
        let to = range.to - offset,
          from = to - replaced.length
        if (
          range.to - range.from != size ||
          view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          (range.to >= compositionRange.from && range.from <= compositionRange.to)
        )
          return { range }
        let rangeChanges = startState.changes({ from, to, insert: change.insert }),
          selOff = range.to - sel.to
        return {
          changes: rangeChanges,
          range: !mainSel
            ? range.map(rangeChanges)
            : EditorSelection.range(
                Math.max(0, mainSel.anchor + selOff),
                Math.max(0, mainSel.head + selOff)
              )
        }
      })
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      }
    }
  }
  let userEvent = 'input.type'
  if (
    view.composing ||
    (view.inputState.compositionPendingChange &&
      view.inputState.compositionEndedAt > Date.now() - 50)
  ) {
    view.inputState.compositionPendingChange = false
    userEvent += '.compose'
    if (view.inputState.compositionFirstChange) {
      userEvent += '.start'
      view.inputState.compositionFirstChange = false
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true })
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length)
  let from = 0
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++
  if (from == minLen && a.length == b.length) return null
  let toA = a.length,
    toB = b.length
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--
    toB--
  }
  if (preferredSide == 'end') {
    let adjust = Math.max(0, from - Math.min(toA, toB))
    preferredPos -= toA + adjust - from
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0
    from -= move
    toB = from + (toB - toA)
    toA = from
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0
    from -= move
    toA = from + (toA - toB)
    toB = from
  }
  return { from, toA, toB }
}
function selectionPoints(view) {
  let result = []
  if (view.root.activeElement != view.contentDOM) return result
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset))
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset))
  }
  return result
}
function selectionFromPoints(points, base2) {
  if (points.length == 0) return null
  let anchor = points[0].pos,
    head = points.length == 2 ? points[1].pos : anchor
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin
    this.lastSelectionTime = Date.now()
  }
  constructor(view) {
    this.view = view
    this.lastKeyCode = 0
    this.lastKeyTime = 0
    this.lastTouchTime = 0
    this.lastFocusTime = 0
    this.lastScrollTop = 0
    this.lastScrollLeft = 0
    this.pendingIOSKey = void 0
    this.tabFocusMode = -1
    this.lastSelectionOrigin = null
    this.lastSelectionTime = 0
    this.lastContextMenu = 0
    this.scrollHandlers = []
    this.handlers = /* @__PURE__ */ Object.create(null)
    this.composing = -1
    this.compositionFirstChange = null
    this.compositionEndedAt = 0
    this.compositionPendingKey = false
    this.compositionPendingChange = false
    this.mouseSelection = null
    this.draggedContent = null
    this.handleEvent = this.handleEvent.bind(this)
    this.notifiedFocused = view.hasFocus
    if (browser.safari) view.contentDOM.addEventListener('input', () => null)
    if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument)
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return
    if (event.type == 'keydown' && this.keydown(event)) return
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event.type, event))
    else this.runHandlers(event.type, event)
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type]
    if (handlers2) {
      for (let observer of handlers2.observers) observer(this.view, event)
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented) break
        if (handler(this.view, event)) {
          event.preventDefault()
          break
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins),
      prev = this.handlers,
      dom = this.view.contentDOM
    for (let type in handlers2)
      if (type != 'scroll') {
        let passive = !handlers2[type].handlers.length
        let exists = prev[type]
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent)
          exists = null
        }
        if (!exists) dom.addEventListener(type, this.handleEvent, { passive })
      }
    for (let type in prev)
      if (type != 'scroll' && !handlers2[type]) dom.removeEventListener(type, this.handleEvent)
    this.handlers = handlers2
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode
    this.lastKeyTime = Date.now()
    if (
      event.keyCode == 9 &&
      this.tabFocusMode > -1 &&
      (!this.tabFocusMode || Date.now() <= this.tabFocusMode)
    )
      return true
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1
    if (
      browser.android &&
      browser.chrome &&
      !event.synthetic &&
      (event.keyCode == 13 || event.keyCode == 8)
    ) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode)
      return true
    }
    let pending
    if (
      browser.ios &&
      !event.synthetic &&
      !event.altKey &&
      !event.metaKey &&
      (((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey) ||
        (EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey))
    ) {
      this.pendingIOSKey = pending || event
      setTimeout(() => this.flushIOSKey(), 250)
      return true
    }
    if (event.keyCode != 229) this.view.observer.forceFlush()
    return false
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey
    if (!key) return false
    if (
      key.key == 'Enter' &&
      change &&
      change.from < change.to &&
      /^\S+$/.test(change.insert.toString())
    )
      return false
    this.pendingIOSKey = void 0
    return dispatchKey(
      this.view.contentDOM,
      key.key,
      key.keyCode,
      key instanceof KeyboardEvent ? key : void 0
    )
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type)) return false
    if (this.composing > 0) return true
    if (
      browser.safari &&
      !browser.ios &&
      this.compositionPendingKey &&
      Date.now() - this.compositionEndedAt < 100
    ) {
      this.compositionPendingKey = false
      return true
    }
    return false
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection) this.mouseSelection.destroy()
    this.mouseSelection = mouseSelection
  }
  update(update) {
    this.view.observer.update(update)
    if (this.mouseSelection) this.mouseSelection.update(update)
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes)
    if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0
  }
  destroy() {
    if (this.mouseSelection) this.mouseSelection.destroy()
  }
}
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view)
    } catch (e2) {
      logException(view.state, e2)
    }
  }
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null)
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] })
  }
  for (let plugin of plugins) {
    let spec = plugin.spec,
      handlers2 = spec && spec.plugin.domEventHandlers,
      observers2 = spec && spec.plugin.domEventObservers
    if (handlers2)
      for (let type in handlers2) {
        let f = handlers2[type]
        if (f) record(type).handlers.push(bindHandler(plugin.value, f))
      }
    if (observers2)
      for (let type in observers2) {
        let f = observers2[type]
        if (f) record(type).observers.push(bindHandler(plugin.value, f))
      }
  }
  for (let type in handlers) record(type).handlers.push(handlers[type])
  for (let type in observers) record(type).observers.push(observers[type])
  return result
}
const PendingKeys = [
  { key: 'Backspace', keyCode: 8, inputType: 'deleteContentBackward' },
  { key: 'Enter', keyCode: 13, inputType: 'insertParagraph' },
  { key: 'Enter', keyCode: 13, inputType: 'insertLineBreak' },
  { key: 'Delete', keyCode: 46, inputType: 'deleteContentForward' }
]
const EmacsyPendingKeys = 'dthko'
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225]
const dragScrollMargin = 6
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY))
}
class MouseSelection {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view
    this.startEvent = startEvent
    this.style = style
    this.mustSelect = mustSelect
    this.scrollSpeed = { x: 0, y: 0 }
    this.scrolling = -1
    this.lastEvent = startEvent
    this.scrollParents = scrollableParents(view.contentDOM)
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view))
    let doc2 = view.contentDOM.ownerDocument
    doc2.addEventListener('mousemove', (this.move = this.move.bind(this)))
    doc2.addEventListener('mouseup', (this.up = this.up.bind(this)))
    this.extend = startEvent.shiftKey
    this.multiple =
      view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent)
    this.dragging =
      isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false
  }
  start(event) {
    if (this.dragging === false) this.select(event)
  }
  move(event) {
    if (event.buttons == 0) return this.destroy()
    if (this.dragging || (this.dragging == null && dist(this.startEvent, event) < 10)) return
    this.select((this.lastEvent = event))
    let sx = 0,
      sy = 0
    let left = 0,
      top2 = 0,
      right = this.view.win.innerWidth,
      bottom = this.view.win.innerHeight
    if (this.scrollParents.x) ({ left, right } = this.scrollParents.x.getBoundingClientRect())
    if (this.scrollParents.y) ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect())
    let margins = getScrollMargins(this.view)
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event.clientX)
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - right)
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY)
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom)
    this.setScrollSpeed(sx, sy)
  }
  up(event) {
    if (this.dragging == null) this.select(this.lastEvent)
    if (!this.dragging) event.preventDefault()
    this.destroy()
  }
  destroy() {
    this.setScrollSpeed(0, 0)
    let doc2 = this.view.contentDOM.ownerDocument
    doc2.removeEventListener('mousemove', this.move)
    doc2.removeEventListener('mouseup', this.up)
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy }
    if (sx || sy) {
      if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50)
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling)
      this.scrolling = -1
    }
  }
  scroll() {
    let { x: x2, y: y2 } = this.scrollSpeed
    if (x2 && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x2
      x2 = 0
    }
    if (y2 && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y2
      y2 = 0
    }
    if (x2 || y2) this.view.win.scrollBy(x2, y2)
    if (this.dragging === false) this.select(this.lastEvent)
  }
  skipAtoms(sel) {
    let ranges = null
    for (let i = 0; i < sel.ranges.length; i++) {
      let range = sel.ranges[i],
        updated = null
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0)
        if (pos != range.from) updated = EditorSelection.cursor(pos, -1)
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1)
        let to = skipAtomicRanges(this.atoms, range.to, 1)
        if (from != range.from || to != range.to)
          updated = EditorSelection.range(
            range.from == range.anchor ? from : to,
            range.from == range.head ? from : to
          )
      }
      if (updated) {
        if (!ranges) ranges = sel.ranges.slice()
        ranges[i] = updated
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel
  }
  select(event) {
    let { view } = this,
      selection2 = this.skipAtoms(this.style.get(event, this.extend, this.multiple))
    if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection: selection2,
        userEvent: 'select.pointer'
      })
    this.mustSelect = false
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent('input.type'))) this.destroy()
    else if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20)
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange)
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1)
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection
  if (main.empty) return false
  let sel = getSelection(view.root)
  if (!sel || sel.rangeCount == 0) return true
  let rects = sel.getRangeAt(0).getClientRects()
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i]
    if (
      rect.left <= event.clientX &&
      rect.right >= event.clientX &&
      rect.top <= event.clientY &&
      rect.bottom >= event.clientY
    )
      return true
  }
  return false
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles) return true
  if (event.defaultPrevented) return false
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (
      !node ||
      node.nodeType == 11 ||
      ((cView = ContentView.get(node)) && cView.ignoreEvent(event))
    )
      return false
  return true
}
const handlers = /* @__PURE__ */ Object.create(null)
const observers = /* @__PURE__ */ Object.create(null)
const brokenClipboardAPI =
  (browser.ie && browser.ie_version < 15) || (browser.ios && browser.webkit_version < 604)
function capturePaste(view) {
  let parent = view.dom.parentNode
  if (!parent) return
  let target = parent.appendChild(document.createElement('textarea'))
  target.style.cssText = 'position: fixed; left: -10000px; top: 10px'
  target.focus()
  setTimeout(() => {
    view.focus()
    target.remove()
    doPaste(view, target.value)
  }, 50)
}
function textFilter(state, facet, text2) {
  for (let filter of state.facet(facet)) text2 = filter(text2, state)
  return text2
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input)
  let { state } = view,
    changes,
    i = 1,
    text2 = state.toText(input)
  let byLine = text2.lines == state.selection.ranges.length
  let linewise =
    lastLinewiseCopy != null &&
    state.selection.ranges.every((r2) => r2.empty) &&
    lastLinewiseCopy == text2.toString()
  if (linewise) {
    let lastLine = -1
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from)
      if (line.from == lastLine) return { range }
      lastLine = line.from
      let insert2 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak)
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      }
    })
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text2.line(i++)
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      }
    })
  } else {
    changes = state.replaceSelection(text2)
  }
  view.dispatch(changes, {
    userEvent: 'input.paste',
    scrollIntoView: true
  })
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft
}
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin('select')
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3
  return false
}
observers.touchstart = (view, e2) => {
  view.inputState.lastTouchTime = Date.now()
  view.inputState.setSelectionOrigin('select.pointer')
}
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin('select.pointer')
}
handlers.mousedown = (view, event) => {
  view.observer.flush()
  if (view.inputState.lastTouchTime > Date.now() - 2e3) return false
  let style = null
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event)
    if (style) break
  }
  if (!style && event.button == 0) style = basicMouseSelection(view, event)
  if (style) {
    let mustFocus = !view.hasFocus
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus))
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM)
        let active = view.root.activeElement
        if (active && !active.contains(view.contentDOM)) active.blur()
      })
    let mouseSel = view.inputState.mouseSelection
    if (mouseSel) {
      mouseSel.start(event)
      return mouseSel.dragging === false
    }
  }
  return false
}
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias)
  } else if (type == 2) {
    return groupAt(view.state, pos, bias)
  } else {
    let visual = LineView.find(view.docView, pos),
      line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos)
    let from = visual ? visual.posAtStart : line.from,
      to = visual ? visual.posAtEnd : line.to
    if (to < view.state.doc.length && to == line.to) to++
    return EditorSelection.range(from, to)
  }
}
let inside = (x2, y2, rect) =>
  y2 >= rect.top && y2 <= rect.bottom && x2 >= rect.left && x2 <= rect.right
function findPositionSide(view, pos, x2, y2) {
  let line = LineView.find(view.docView, pos)
  if (!line) return 1
  let off = pos - line.posAtStart
  if (off == 0) return 1
  if (off == line.length) return -1
  let before = line.coordsAt(off, -1)
  if (before && inside(x2, y2, before)) return -1
  let after = line.coordsAt(off, 1)
  if (after && inside(x2, y2, after)) return 1
  return before && before.bottom >= y2 ? -1 : 1
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false)
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) }
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11
let lastMouseDown = null,
  lastMouseDownCount = 0,
  lastMouseDownTime = 0
function getClickType(event) {
  if (!BadMouseDetail) return event.detail
  let last = lastMouseDown,
    lastTime = lastMouseDownTime
  lastMouseDown = event
  lastMouseDownTime = Date.now()
  return (lastMouseDownCount =
    !last ||
    (lastTime > Date.now() - 400 &&
      Math.abs(last.clientX - event.clientX) < 2 &&
      Math.abs(last.clientY - event.clientY) < 2)
      ? (lastMouseDownCount + 1) % 3
      : 1)
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event),
    type = getClickType(event)
  let startSel = view.state.selection
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos)
        startSel = startSel.map(update.changes)
      }
    },
    get(event2, extend, multiple) {
      let cur2 = queryPos(view, event2),
        removed
      let range = rangeForClick(view, cur2.pos, cur2.bias, type)
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type)
        let from = Math.min(startRange.from, range.from),
          to = Math.max(startRange.to, range.to)
        range =
          from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from)
      }
      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to))
      else if (
        multiple &&
        type == 1 &&
        startSel.ranges.length > 1 &&
        (removed = removeRangeAround(startSel, cur2.pos))
      )
        return removed
      else if (multiple) return startSel.addRange(range)
      else return EditorSelection.create([range])
    }
  }
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let { from, to } = sel.ranges[i]
    if (from <= pos && to >= pos)
      return EditorSelection.create(
        sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)),
        sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0)
      )
  }
  return null
}
handlers.dragstart = (view, event) => {
  let {
    selection: { main: range }
  } = view.state
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target)
    if (cView && cView.isWidget) {
      let from = cView.posAtStart,
        to = from + cView.length
      if (from >= range.to || to <= range.from) range = EditorSelection.range(from, to)
    }
  }
  let { inputState } = view
  if (inputState.mouseSelection) inputState.mouseSelection.dragging = true
  inputState.draggedContent = range
  if (event.dataTransfer) {
    event.dataTransfer.setData(
      'Text',
      textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to))
    )
    event.dataTransfer.effectAllowed = 'copyMove'
  }
  return false
}
handlers.dragend = (view) => {
  view.inputState.draggedContent = null
  return false
}
function dropText(view, event, text2, direct) {
  text2 = textFilter(view.state, clipboardInputFilter, text2)
  if (!text2) return
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false)
  let { draggedContent } = view.inputState
  let del =
    direct && draggedContent && dragMovesSelection(view, event)
      ? { from: draggedContent.from, to: draggedContent.to }
      : null
  let ins = { from: dropPos, insert: text2 }
  let changes = view.state.changes(del ? [del, ins] : ins)
  view.focus()
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? 'move.drop' : 'input.drop'
  })
  view.inputState.draggedContent = null
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer) return false
  if (view.state.readOnly) return true
  let files = event.dataTransfer.files
  if (files && files.length) {
    let text2 = Array(files.length),
      read = 0
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text2.filter((s) => s != null).join(view.state.lineBreak), false)
    }
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader()
      reader.onerror = finishFile
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text2[i] = reader.result
        finishFile()
      }
      reader.readAsText(files[i])
    }
    return true
  } else {
    let text2 = event.dataTransfer.getData('Text')
    if (text2) {
      dropText(view, event, text2, true)
      return true
    }
  }
  return false
}
handlers.paste = (view, event) => {
  if (view.state.readOnly) return true
  view.observer.flush()
  let data2 = brokenClipboardAPI ? null : event.clipboardData
  if (data2) {
    doPaste(view, data2.getData('text/plain') || data2.getData('text/uri-list'))
    return true
  } else {
    capturePaste(view)
    return false
  }
}
function captureCopy(view, text2) {
  let parent = view.dom.parentNode
  if (!parent) return
  let target = parent.appendChild(document.createElement('textarea'))
  target.style.cssText = 'position: fixed; left: -10000px; top: 10px'
  target.value = text2
  target.focus()
  target.selectionEnd = text2.length
  target.selectionStart = 0
  setTimeout(() => {
    target.remove()
    view.focus()
  }, 50)
}
function copiedRange(state) {
  let content2 = [],
    ranges = [],
    linewise = false
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to))
      ranges.push(range)
    }
  if (!content2.length) {
    let upto = -1
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from)
      if (line.number > upto) {
        content2.push(line.text)
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) })
      }
      upto = line.number
    }
    linewise = true
  }
  return {
    text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)),
    ranges,
    linewise
  }
}
let lastLinewiseCopy = null
handlers.copy = handlers.cut = (view, event) => {
  let { text: text2, ranges, linewise } = copiedRange(view.state)
  if (!text2 && !linewise) return false
  lastLinewiseCopy = linewise ? text2 : null
  if (event.type == 'cut' && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: 'delete.cut'
    })
  let data2 = brokenClipboardAPI ? null : event.clipboardData
  if (data2) {
    data2.clearData()
    data2.setData('text/plain', text2)
    return true
  } else {
    captureCopy(view, text2)
    return false
  }
}
const isFocusChange = /* @__PURE__ */ Annotation.define()
function focusChangeTransaction(state, focus) {
  let effects = []
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus)
    if (effect) effects.push(effect)
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus)
      if (tr) view.dispatch(tr)
      else view.update([])
    }
  }, 10)
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now()
  if (
    !view.scrollDOM.scrollTop &&
    (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)
  ) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft
  }
  updateForFocusChange(view)
}
observers.blur = (view) => {
  view.observer.clearSelectionRange()
  updateForFocusChange(view)
}
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext) return
  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0
  }
}
observers.compositionend = (view) => {
  if (view.observer.editContext) return
  view.inputState.composing = -1
  view.inputState.compositionEndedAt = Date.now()
  view.inputState.compositionPendingKey = true
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0
  view.inputState.compositionFirstChange = null
  if (browser.chrome && browser.android) {
    view.observer.flushSoon()
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush())
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([])
    }, 50)
  }
}
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now()
}
handlers.beforeinput = (view, event) => {
  var _a2, _b
  if (event.inputType == 'insertReplacementText' && view.observer.editContext) {
    let text2 =
        (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData('text/plain'),
      ranges = event.getTargetRanges()
    if (text2 && ranges.length) {
      let r2 = ranges[0]
      let from = view.posAtDOM(r2.startContainer, r2.startOffset),
        to = view.posAtDOM(r2.endContainer, r2.endOffset)
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text2) }, null)
      return true
    }
  }
  let pending
  if (
    browser.chrome &&
    browser.android &&
    (pending = PendingKeys.find((key) => key.inputType == event.inputType))
  ) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode)
    if (pending.key == 'Backspace' || pending.key == 'Delete') {
      let startViewHeight =
        ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0
      setTimeout(() => {
        var _a3
        if (
          (((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) >
            startViewHeight + 10 &&
          view.hasFocus
        ) {
          view.contentDOM.blur()
          view.focus()
        }
      }, 100)
    }
  }
  if (browser.ios && event.inputType == 'deleteContentForward') {
    view.observer.flushSoon()
  }
  if (browser.safari && event.inputType == 'insertText' && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20)
  }
  return false
}
const appliedFirefoxHack = /* @__PURE__ */ new Set()
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2)
    doc2.addEventListener('copy', () => {})
    doc2.addEventListener('cut', () => {})
  }
}
const wrappingWhiteSpace = ['pre-wrap', 'normal', 'pre-line', 'break-spaces']
let heightChangeFlag = false
function clearHeightChangeFlag() {
  heightChangeFlag = false
}
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping
    this.doc = Text.empty
    this.heightSamples = {}
    this.lineHeight = 14
    this.charWidth = 7
    this.textHeight = 14
    this.lineLength = 30
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength))
    return this.lineHeight * lines
  }
  heightForLine(length) {
    if (!this.lineWrapping) return this.lineHeight
    let lines =
      1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)))
    return lines * this.lineHeight
  }
  setDoc(doc2) {
    this.doc = doc2
    return this
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false
    for (let i = 0; i < lineHeights.length; i++) {
      let h2 = lineHeights[i]
      if (h2 < 0) {
        i++
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true
        this.heightSamples[Math.floor(h2 * 10)] = true
      }
    }
    return newHeight
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1
    let changed =
      Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping
    this.lineWrapping = lineWrapping
    this.lineHeight = lineHeight
    this.charWidth = charWidth
    this.textHeight = textHeight
    this.lineLength = lineLength
    if (changed) {
      this.heightSamples = {}
      for (let i = 0; i < knownHeights.length; i++) {
        let h2 = knownHeights[i]
        if (h2 < 0) i++
        else this.heightSamples[Math.floor(h2 * 10)] = true
      }
    }
    return changed
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from
    this.heights = heights
    this.index = 0
  }
  get more() {
    return this.index < this.heights.length
  }
}
class BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from
    this.length = length
    this.top = top2
    this.height = height
    this._content = _content
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == 'number'
      ? BlockType.Text
      : Array.isArray(this._content)
        ? this._content
        : this._content.type
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == 'number' ? this._content : 0
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(
      Array.isArray(other._content) ? other._content : [other]
    )
    return new BlockInfo(
      this.from,
      this.length + other.length,
      this.top,
      this.height + other.height,
      content2
    )
  }
}
var QueryType$1 = /* @__PURE__ */ (function (QueryType2) {
  QueryType2[(QueryType2['ByPos'] = 0)] = 'ByPos'
  QueryType2[(QueryType2['ByHeight'] = 1)] = 'ByHeight'
  QueryType2[(QueryType2['ByPosNoHeight'] = 2)] = 'ByPosNoHeight'
  return QueryType2
})(QueryType$1 || (QueryType$1 = {}))
const Epsilon = 1e-3
class HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length
    this.height = height
    this.flags = flags
  }
  get outdated() {
    return (this.flags & 2) > 0
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | (this.flags & -3)
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true
      this.height = height
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes)
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this)
  }
  decomposeRight(_from, result) {
    result.push(this)
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this,
      doc2 = oracle.doc
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i]
      let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0)
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oracle, 0, 0)
      toB += end.to - toA
      toA = end.to
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA
        fromB = changes[i - 1].fromB
        i--
        if (fromA < start.from) start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle, 0, 0)
      }
      fromB += start.from - fromA
      fromA = start.from
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB)
      me = replace(me, me.replace(fromA, toA, nodes))
    }
    return me.updateHeight(oracle, 0)
  }
  static empty() {
    return new HeightMapText(0, 0)
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1) return nodes[0]
    let i = 0,
      j = nodes.length,
      before = 0,
      after = 0
    for (;;) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1]
          if (split.break) nodes.splice(--i, 1, split.left, null, split.right)
          else nodes.splice(--i, 1, split.left, split.right)
          j += 1 + split.break
          before -= split.size
        } else if (after > before * 2) {
          let split = nodes[j]
          if (split.break) nodes.splice(j, 1, split.left, null, split.right)
          else nodes.splice(j, 1, split.left, split.right)
          j += 2 + split.break
          after -= split.size
        } else {
          break
        }
      } else if (before < after) {
        let next = nodes[i++]
        if (next) before += next.size
      } else {
        let next = nodes[--j]
        if (next) after += next.size
      }
    }
    let brk = 0
    if (nodes[i - 1] == null) {
      brk = 1
      i--
    } else if (nodes[i] == null) {
      brk = 1
      j++
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)))
  }
}
function replace(old, val) {
  if (old == val) return old
  if (old.constructor != val.constructor) heightChangeFlag = true
  return val
}
HeightMap.prototype.size = 1
class HeightMapBlock extends HeightMap {
  constructor(length, height, deco) {
    super(length, height)
    this.deco = deco
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0)
  }
  lineAt(_value, _type, oracle, top2, offset) {
    return this.blockAt(0, oracle, top2, offset)
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top2, offset))
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++])
    this.outdated = false
    return this
  }
  toString() {
    return `block(${this.length})`
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null)
    this.collapsed = 0
    this.widgetHeight = 0
    this.breaks = 0
  }
  blockAt(_height, _oracle, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.breaks)
  }
  replace(_from, _to, nodes) {
    let node = nodes[0]
    if (
      nodes.length == 1 &&
      (node instanceof HeightMapText || (node instanceof HeightMapGap && node.flags & 4)) &&
      Math.abs(this.length - node.length) < 10
    ) {
      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height)
      else node.height = this.height
      if (!this.outdated) node.outdated = false
      return node
    } else {
      return HeightMap.of(nodes)
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(measured.heights[measured.index++])
    else if (force || this.outdated)
      this.setHeight(
        Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
          this.breaks * oracle.lineHeight
      )
    this.outdated = false
    return this
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ''}${this.widgetHeight ? ':' + this.widgetHeight : ''})`
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0)
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number,
      lastLine = oracle.doc.lineAt(offset + this.length).number
    let lines = lastLine - firstLine + 1
    let perLine,
      perChar = 0
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines)
      perLine = totalPerLine / lines
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1)
    } else {
      perLine = this.height / lines
    }
    return { firstLine, lastLine, perLine, perChar }
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset)
    if (oracle.lineWrapping) {
      let guess =
        offset +
        (height < oracle.lineHeight
          ? 0
          : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length))
      let line = oracle.doc.lineAt(guess),
        lineHeight = perLine + line.length * perChar
      let lineTop = Math.max(top2, height - lineHeight / 2)
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0)
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)))
      let { from, length } = oracle.doc.line(firstLine + line)
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0)
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType$1.ByHeight) return this.blockAt(value, oracle, top2, offset)
    if (type == QueryType$1.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value)
      return new BlockInfo(from, to - from, 0, 0, 0)
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset)
    let line = oracle.doc.lineAt(value),
      lineHeight = perLine + line.length * perChar
    let linesAbove = line.number - firstLine
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove)
    return new BlockInfo(
      line.from,
      line.length,
      Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)),
      lineHeight,
      0
    )
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    from = Math.max(from, offset)
    to = Math.min(to, offset + this.length)
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset)
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos)
      if (pos == from) {
        let linesAbove = line.number - firstLine
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove)
      }
      let lineHeight = perLine + perChar * line.length
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0))
      lineTop += lineHeight
      pos = line.to + 1
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to
    if (after > 0) {
      let last = nodes[nodes.length - 1]
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after)
      else nodes.push(null, new HeightMapGap(after - 1))
    }
    if (from > 0) {
      let first = nodes[0]
      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length)
      else nodes.unshift(new HeightMapGap(from - 1), null)
    }
    return HeightMap.of(nodes)
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null)
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1))
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [],
        pos = Math.max(offset, measured.from),
        singleHeight = -1
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset))
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length
        if (nodes.length) nodes.push(null)
        let height = measured.heights[measured.index++]
        if (singleHeight == -1) singleHeight = height
        else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2
        let line = new HeightMapText(len, height)
        line.outdated = false
        nodes.push(line)
        pos += len + 1
      }
      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos))
      let result = HeightMap.of(nodes)
      if (
        singleHeight < 0 ||
        Math.abs(result.height - this.height) >= Epsilon ||
        Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon
      )
        heightChangeFlag = true
      return replace(this, result)
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length))
      this.outdated = false
    }
    return this
  }
  toString() {
    return `gap(${this.length})`
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(
      left.length + brk + right.length,
      left.height + right.height,
      brk | (left.outdated || right.outdated ? 2 : 0)
    )
    this.left = left
    this.right = right
    this.size = left.size + right.size
  }
  get break() {
    return this.flags & 1
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height
    return height < mid
      ? this.left.blockAt(height, oracle, top2, offset)
      : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break)
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height,
      rightOffset = offset + this.left.length + this.break
    let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset
    let base2 = left
      ? this.left.lineAt(value, type, oracle, top2, offset)
      : this.right.lineAt(value, type, oracle, rightTop, rightOffset)
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset)) return base2
    let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset))
    else return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2)
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height,
      rightOffset = offset + this.left.length + this.break
    if (this.break) {
      if (from < rightOffset) this.left.forEachLine(from, to, oracle, top2, offset, f)
      if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f)
    } else {
      let mid = this.lineAt(rightOffset, QueryType$1.ByPos, oracle, top2, offset)
      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f)
      if (mid.to >= from && mid.from <= to) f(mid)
      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f)
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break
    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right)
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes))
    let result = []
    if (from > 0) this.decomposeLeft(from, result)
    let left = result.length
    for (let node of nodes) result.push(node)
    if (from > 0) mergeGaps(result, left - 1)
    if (to < this.length) {
      let right = result.length
      this.decomposeRight(to, result)
      mergeGaps(result, right)
    }
    return HeightMap.of(result)
  }
  decomposeLeft(to, result) {
    let left = this.left.length
    if (to <= left) return this.left.decomposeLeft(to, result)
    result.push(this.left)
    if (this.break) {
      left++
      if (to >= left) result.push(null)
    }
    if (to > left) this.right.decomposeLeft(to - left, result)
  }
  decomposeRight(from, result) {
    let left = this.left.length,
      right = left + this.break
    if (from >= right) return this.right.decomposeRight(from - right, result)
    if (from < left) this.left.decomposeRight(from, result)
    if (this.break && from < right) result.push(null)
    result.push(this.right)
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right])
    this.left = replace(this.left, left)
    this.right = replace(this.right, right)
    this.setHeight(left.height + right.height)
    this.outdated = left.outdated || right.outdated
    this.size = left.size + right.size
    this.length = left.length + this.break + right.length
    return this
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this,
      rightStart = offset + left.length + this.break,
      rebalance = null
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured)
    else left.updateHeight(oracle, offset, force)
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured)
    else right.updateHeight(oracle, rightStart, force)
    if (rebalance) return this.balanced(left, right)
    this.height = this.left.height + this.right.height
    this.outdated = false
    return this
  }
  toString() {
    return this.left + (this.break ? ' ' : '-') + this.right
  }
}
function mergeGaps(nodes, around) {
  let before, after
  if (
    nodes[around] == null &&
    (before = nodes[around - 1]) instanceof HeightMapGap &&
    (after = nodes[around + 1]) instanceof HeightMapGap
  )
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length))
}
const relevantWidgetHeight = 5
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos
    this.oracle = oracle
    this.nodes = []
    this.lineStart = -1
    this.lineEnd = -1
    this.covering = null
    this.writtenTo = pos
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd),
        last = this.nodes[this.nodes.length - 1]
      if (last instanceof HeightMapText) last.length += end - this.pos
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1))
      this.writtenTo = end
      if (to > end) {
        this.nodes.push(null)
        this.writtenTo++
        this.lineStart = -1
      }
    }
    this.pos = to
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0
      let breaks = deco.widget ? deco.widget.lineBreaks : 0
      if (height < 0) height = this.oracle.lineHeight
      let len = to - from
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco))
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len)
      }
    } else if (to > from) {
      this.span(from, to)
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to
  }
  enterLine() {
    if (this.lineStart > -1) return
    let { from, to } = this.oracle.doc.lineAt(this.pos)
    this.lineStart = from
    this.lineEnd = to
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1))
      this.nodes.push(null)
    }
    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1))
    this.writtenTo = this.pos
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from)
    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4
    return gap
  }
  ensureLine() {
    this.enterLine()
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null
    if (last instanceof HeightMapText) return last
    let line = new HeightMapText(0, -1)
    this.nodes.push(line)
    return line
  }
  addBlock(block2) {
    this.enterLine()
    let deco = block2.deco
    if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine()
    this.nodes.push(block2)
    this.writtenTo = this.pos = this.pos + block2.length
    if (deco && deco.endSide > 0) this.covering = block2
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine()
    line.length += length
    line.collapsed += length
    line.widgetHeight = Math.max(line.widgetHeight, height)
    line.breaks += breaks
    this.writtenTo = this.pos = this.pos + length
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1]
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1))
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos))
    let pos = from
    for (let node of this.nodes) {
      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos)
      pos += node ? node.length : 1
    }
    return this.nodes
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle)
    RangeSet.spans(decorations2, from, to, builder, 0)
    return builder.finish(from)
  }
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator2()
  RangeSet.compare(a, b, diff, comp, 0)
  return comp.changes
}
class DecorationComparator2 {
  constructor() {
    this.changes = []
  }
  compareRange() {}
  comparePoint(from, to, a, b) {
    if (from < to || (a && a.heightRelevant) || (b && b.heightRelevant))
      addRange(from, to, this.changes, 5)
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect()
  let doc2 = dom.ownerDocument,
    win = doc2.defaultView || window
  let left = Math.max(0, rect.left),
    right = Math.min(win.innerWidth, rect.right)
  let top2 = Math.max(0, rect.top),
    bottom = Math.min(win.innerHeight, rect.bottom)
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent
      let style = window.getComputedStyle(elt2)
      if (
        (elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) &&
        style.overflow != 'visible'
      ) {
        let parentRect = elt2.getBoundingClientRect()
        left = Math.max(left, parentRect.left)
        right = Math.min(right, parentRect.right)
        top2 = Math.max(top2, parentRect.top)
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom)
      }
      parent =
        style.position == 'absolute' || style.position == 'fixed'
          ? elt2.offsetParent
          : elt2.parentNode
    } else if (parent.nodeType == 11) {
      parent = parent.host
    } else {
      break
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  }
}
function inWindow(elt2) {
  let rect = elt2.getBoundingClientRect(),
    win = elt2.ownerDocument.defaultView || window
  return (
    rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0
  )
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect()
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  }
}
class LineGap {
  constructor(from, to, size, displaySize) {
    this.from = from
    this.to = to
    this.size = size
    this.displaySize = displaySize
  }
  static same(a, b) {
    if (a.length != b.length) return false
    for (let i = 0; i < a.length; i++) {
      let gA = a[i],
        gB = b[i]
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false
    }
    return true
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(
        this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX),
        wrapping
      )
    }).range(this.from, this.to)
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super()
    this.size = size
    this.vertical = vertical
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical
  }
  toDOM() {
    let elt2 = document.createElement('div')
    if (this.vertical) {
      elt2.style.height = this.size + 'px'
    } else {
      elt2.style.width = this.size + 'px'
      elt2.style.height = '2px'
      elt2.style.display = 'inline-block'
    }
    return elt2
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1
  }
}
class ViewState {
  constructor(state) {
    this.state = state
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }
    this.inView = true
    this.paddingTop = 0
    this.paddingBottom = 0
    this.contentDOMWidth = 0
    this.contentDOMHeight = 0
    this.editorHeight = 0
    this.editorWidth = 0
    this.scrollTop = 0
    this.scrolledToBottom = false
    this.scaleX = 1
    this.scaleY = 1
    this.scrollAnchorPos = 0
    this.scrollAnchorHeight = -1
    this.scaler = IdScaler
    this.scrollTarget = null
    this.printing = false
    this.mustMeasureContent = true
    this.defaultTextDirection = Direction.LTR
    this.visibleRanges = []
    this.mustEnforceCursorAssoc = false
    let guessWrapping = state
      .facet(contentAttributes)
      .some((v) => typeof v != 'function' && v.class == 'cm-lineWrapping')
    this.heightOracle = new HeightOracle(guessWrapping)
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != 'function')
    this.heightMap = HeightMap.empty().applyChanges(
      this.stateDeco,
      Text.empty,
      this.heightOracle.setDoc(state.doc),
      [new ChangedRange(0, 0, 0, state.doc.length)]
    )
    for (let i = 0; i < 2; i++) {
      this.viewport = this.getViewport(0, null)
      if (!this.updateForViewport()) break
    }
    this.updateViewportLines()
    this.lineGaps = this.ensureLineGaps([])
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)))
    this.computeVisibleRanges()
  }
  updateForViewport() {
    let viewports = [this.viewport],
      { main } = this.state.selection
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos)
        viewports.push(new Viewport(from, to))
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from)
    return this.updateScaler()
  }
  updateScaler() {
    let scaler = this.scaler
    this.scaler =
      this.heightMap.height <= 7e6
        ? IdScaler
        : new BigScaler(this.heightOracle, this.heightMap, this.viewports)
    return scaler.eq(this.scaler) ? 0 : 2
  }
  updateViewportLines() {
    this.viewportLines = []
    this.heightMap.forEachLine(
      this.viewport.from,
      this.viewport.to,
      this.heightOracle.setDoc(this.state.doc),
      0,
      0,
      (block2) => {
        this.viewportLines.push(scaleBlock(block2, this.scaler))
      }
    )
  }
  update(update, scrollTarget = null) {
    this.state = update.state
    let prevDeco = this.stateDeco
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != 'function')
    let contentChanges = update.changedRanges
    let heightChanges = ChangedRange.extendWithRanges(
      contentChanges,
      heightRelevantDecoChanges(
        prevDeco,
        this.stateDeco,
        update ? update.changes : ChangeSet.empty(this.state.doc.length)
      )
    )
    let prevHeight = this.heightMap.height
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop)
    clearHeightChangeFlag()
    this.heightMap = this.heightMap.applyChanges(
      this.stateDeco,
      update.startState.doc,
      this.heightOracle.setDoc(this.state.doc),
      heightChanges
    )
    if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1)
      this.scrollAnchorHeight = scrollAnchor.top
    } else {
      this.scrollAnchorPos = -1
      this.scrollAnchorHeight = prevHeight
    }
    let viewport = heightChanges.length
      ? this.mapViewport(this.viewport, update.changes)
      : this.viewport
    if (
      (scrollTarget &&
        (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to)) ||
      !this.viewportIsAppropriate(viewport)
    )
      viewport = this.getViewport(0, scrollTarget)
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to
    this.viewport = viewport
    update.flags |= this.updateForViewport()
    if (viewportChange || !update.changes.empty || update.flags & 2) this.updateViewportLines()
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)))
    update.flags |= this.computeVisibleRanges(update.changes)
    if (scrollTarget) this.scrollTarget = scrollTarget
    if (
      !this.mustEnforceCursorAssoc &&
      update.selectionSet &&
      update.view.lineWrapping &&
      update.state.selection.main.empty &&
      update.state.selection.main.assoc &&
      !update.state.facet(nativeSelectionHidden)
    )
      this.mustEnforceCursorAssoc = true
  }
  measure(view) {
    let dom = view.contentDOM,
      style = window.getComputedStyle(dom)
    let oracle = this.heightOracle
    let whiteSpace = style.whiteSpace
    this.defaultTextDirection = style.direction == 'rtl' ? Direction.RTL : Direction.LTR
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace)
    let domRect = dom.getBoundingClientRect()
    let measureContent =
      refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height
    this.contentDOMHeight = domRect.height
    this.mustMeasureContent = false
    let result = 0,
      bias = 0
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect)
      if (
        (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3) ||
        (scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3)
      ) {
        this.scaleX = scaleX
        this.scaleY = scaleY
        result |= 16
        refresh = measureContent = true
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop
      this.paddingBottom = paddingBottom
      result |= 16 | 2
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping) measureContent = true
      this.editorWidth = view.scrollDOM.clientWidth
      result |= 16
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1
      this.scrollTop = scrollTop
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM)
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop)
    let dTop = pixelViewport.top - this.pixelViewport.top,
      dBottom = pixelViewport.bottom - this.pixelViewport.bottom
    this.pixelViewport = pixelViewport
    let inView =
      this.pixelViewport.bottom > this.pixelViewport.top &&
      this.pixelViewport.right > this.pixelViewport.left
    if (inView != this.inView) {
      this.inView = inView
      if (inView) measureContent = true
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0
    let contentWidth = domRect.width
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width
      this.editorHeight = view.scrollDOM.clientHeight
      result |= 16
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport)
      if (oracle.mustRefreshForHeights(lineHeights)) refresh = true
      if (
        refresh ||
        (oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth)
      ) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize()
        refresh =
          lineHeight > 0 &&
          oracle.refresh(
            whiteSpace,
            lineHeight,
            charWidth,
            textHeight,
            Math.max(5, contentWidth / charWidth),
            lineHeights
          )
        if (refresh) {
          view.docView.minWidth = 0
          result |= 16
        }
      }
      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom)
      else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom)
      clearHeightChangeFlag()
      for (let vp of this.viewports) {
        let heights =
          vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp)
        this.heightMap = (
          refresh
            ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [
                new ChangedRange(0, 0, 0, view.state.doc.length)
              ])
            : this.heightMap
        ).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights))
      }
      if (heightChangeFlag) result |= 2
    }
    let viewportChange =
      !this.viewportIsAppropriate(this.viewport, bias) ||
      (this.scrollTarget &&
        (this.scrollTarget.range.head < this.viewport.from ||
          this.scrollTarget.range.head > this.viewport.to))
    if (viewportChange) {
      if (result & 2) result |= this.updateScaler()
      this.viewport = this.getViewport(bias, this.scrollTarget)
      result |= this.updateForViewport()
    }
    if (result & 2 || viewportChange) this.updateViewportLines()
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view))
    result |= this.computeVisibleRanges()
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false
      view.docView.enforceCursorAssoc()
    }
    return result
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top)
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom)
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2))
    let map2 = this.heightMap,
      oracle = this.heightOracle
    let { visibleTop, visibleBottom } = this
    let viewport = new Viewport(
      map2.lineAt(visibleTop - marginTop * 1e3, QueryType$1.ByHeight, oracle, 0, 0).from,
      map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType$1.ByHeight, oracle, 0, 0).to
    )
    if (scrollTarget) {
      let { head } = scrollTarget.range
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(
          this.editorHeight,
          this.pixelViewport.bottom - this.pixelViewport.top
        )
        let block2 = map2.lineAt(head, QueryType$1.ByPos, oracle, 0, 0),
          topPos
        if (scrollTarget.y == 'center') topPos = (block2.top + block2.bottom) / 2 - viewHeight / 2
        else if (scrollTarget.y == 'start' || (scrollTarget.y == 'nearest' && head < viewport.from))
          topPos = block2.top
        else topPos = block2.bottom - viewHeight
        viewport = new Viewport(
          map2.lineAt(topPos - 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).from,
          map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).to
        )
      }
    }
    return viewport
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1),
      to = changes.mapPos(viewport.to, 1)
    return new Viewport(
      this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0).to
    )
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView) return true
    let { top: top2 } = this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0)
    let { bottom } = this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0)
    let { visibleTop, visibleBottom } = this
    return (
      (from == 0 ||
        top2 <=
          visibleTop -
            Math.max(
              10,
              Math.min(
                -bias,
                250
                /* VP.MaxCoverMargin */
              )
            )) &&
      (to == this.state.doc.length ||
        bottom >=
          visibleBottom +
            Math.max(
              10,
              Math.min(
                bias,
                250
                /* VP.MaxCoverMargin */
              )
            )) &&
      top2 > visibleTop - 2 * 1e3 &&
      bottom < visibleBottom + 2 * 1e3
    )
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty) return gaps
    let mapped = []
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(
          new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize)
        )
    return mapped
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping
    let margin = wrapping ? 1e4 : 2e3,
      halfMargin = margin >> 1,
      doubleMargin = margin << 1
    if (this.defaultTextDirection != Direction.LTR && !wrapping) return []
    let gaps = []
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin) return
      let sel = this.state.selection.main,
        avoid = [sel.from]
      if (!sel.empty) avoid.push(sel.to)
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure)
          addGap(pos + 10, to, line, structure)
          return
        }
      }
      let gap = find(
        current,
        (gap2) =>
          gap2.from >= line.from &&
          gap2.to <= line.to &&
          Math.abs(gap2.from - from) < halfMargin &&
          Math.abs(gap2.to - to) < halfMargin &&
          !avoid.some((pos) => gap2.from < pos && gap2.to > pos)
      )
      if (!gap) {
        if (
          to < line.to &&
          mayMeasure &&
          wrapping &&
          mayMeasure.visibleRanges.some((r2) => r2.from <= to && r2.to >= to)
        ) {
          let lineStart = mayMeasure.moveToLineBoundary(
            EditorSelection.cursor(to),
            false,
            true
          ).head
          if (lineStart > from) to = lineStart
        }
        let size = this.gapSize(line, from, to, structure)
        let displaySize = wrapping || size < 2e6 ? size : 2e6
        gap = new LineGap(from, to, size, displaySize)
      }
      gaps.push(gap)
    }
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text) return
      let structure = lineStructure(line.from, line.to, this.stateDeco)
      if (structure.total < doubleMargin) return
      let target = this.scrollTarget ? this.scrollTarget.range.head : null
      let viewFrom, viewTo
      if (wrapping) {
        let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight
        let top2, bot
        if (target != null) {
          let targetFrac = findFraction(structure, target)
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height
          top2 = targetFrac - spaceFrac
          bot = targetFrac + spaceFrac
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height
          bot = (this.visibleBottom - line.top + marginHeight) / line.height
        }
        viewFrom = findPosition(structure, top2)
        viewTo = findPosition(structure, bot)
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth
        let marginWidth = margin * this.heightOracle.charWidth
        let horizOffset = 0
        if (totalWidth > 2e6)
          for (let old of current) {
            if (
              old.from >= line.from &&
              old.from < line.to &&
              old.size != old.displaySize &&
              old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left
            )
              horizOffset = old.size - old.displaySize
          }
        let pxLeft = this.pixelViewport.left + horizOffset,
          pxRight = this.pixelViewport.right + horizOffset
        let left, right
        if (target != null) {
          let targetFrac = findFraction(structure, target)
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth
          left = targetFrac - spaceFrac
          right = targetFrac + spaceFrac
        } else {
          left = (pxLeft - marginWidth) / totalWidth
          right = (pxRight + marginWidth) / totalWidth
        }
        viewFrom = findPosition(structure, left)
        viewTo = findPosition(structure, right)
      }
      if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure)
      if (viewTo < line.to) addGap(viewTo, line.to, line, structure)
    }
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type)) line.type.forEach(checkLine)
      else checkLine(line)
    }
    return gaps
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from)
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction
    } else {
      return structure.total * this.heightOracle.charWidth * fraction
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps
      this.lineGapDeco = Decoration.set(
        gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping))
      )
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco
    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco)
    let ranges = []
    RangeSet.spans(
      deco,
      this.viewport.from,
      this.viewport.to,
      {
        span(from, to) {
          ranges.push({ from, to })
        },
        point() {}
      },
      20
    )
    let changed = 0
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4
    } else {
      for (let i = 0; i < ranges.length && !(changed & 8); i++) {
        let old = this.visibleRanges[i],
          nw = ranges[i]
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4
          if (
            !(
              changes &&
              changes.mapPos(old.from, -1) == nw.from &&
              changes.mapPos(old.to, 1) == nw.to
            )
          )
            changed |= 8
        }
      }
    }
    this.visibleRanges = ranges
    return changed
  }
  lineBlockAt(pos) {
    return (
      (pos >= this.viewport.from &&
        pos <= this.viewport.to &&
        this.viewportLines.find((b) => b.from <= pos && b.to >= pos)) ||
      scaleBlock(
        this.heightMap.lineAt(pos, QueryType$1.ByPos, this.heightOracle, 0, 0),
        this.scaler
      )
    )
  }
  lineBlockAtHeight(height) {
    return (
      (height >= this.viewportLines[0].top &&
        height <= this.viewportLines[this.viewportLines.length - 1].bottom &&
        this.viewportLines.find((l) => l.top <= height && l.bottom >= height)) ||
      scaleBlock(
        this.heightMap.lineAt(
          this.scaler.fromDOM(height),
          QueryType$1.ByHeight,
          this.heightOracle,
          0,
          0
        ),
        this.scaler
      )
    )
  }
  scrollAnchorAt(scrollTop) {
    let block2 = this.lineBlockAtHeight(scrollTop + 8)
    return block2.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200
      ? block2
      : this.viewportLines[0]
  }
  elementAtHeight(height) {
    return scaleBlock(
      this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0),
      this.scaler
    )
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height)
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom
  }
}
class Viewport {
  constructor(from, to) {
    this.from = from
    this.to = to
  }
}
function lineStructure(from, to, stateDeco) {
  let ranges = [],
    pos = from,
    total = 0
  RangeSet.spans(
    stateDeco,
    from,
    to,
    {
      span() {},
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 })
          total += from2 - pos
        }
        pos = to2
      }
    },
    20
  )
  if (pos < to) {
    ranges.push({ from: pos, to })
    total += to - pos
  }
  return { total, ranges }
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0) return ranges[0].from
  if (ratio >= 1) return ranges[ranges.length - 1].to
  let dist2 = Math.floor(total * ratio)
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i],
      size = to - from
    if (dist2 <= size) return from + dist2
    dist2 -= size
  }
}
function findFraction(structure, pos) {
  let counted = 0
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from
      break
    }
    counted += to - from
  }
  return counted / structure.total
}
function find(array, f) {
  for (let val of array) if (f(val)) return val
  return void 0
}
const IdScaler = {
  toDOM(n2) {
    return n2
  },
  fromDOM(n2) {
    return n2
  },
  scale: 1,
  eq(other) {
    return other == this
  }
}
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0,
      base2 = 0,
      domBase = 0
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType$1.ByPos, oracle, 0, 0).top
      let bottom = heightMap.lineAt(to, QueryType$1.ByPos, oracle, 0, 0).bottom
      vpHeight += bottom - top2
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 }
    })
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight)
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top)
      base2 = obj.bottom
    }
  }
  toDOM(n2) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null
      if (!vp || n2 < vp.top) return domBase + (n2 - base2) * this.scale
      if (n2 <= vp.bottom) return vp.domTop + (n2 - vp.top)
      base2 = vp.bottom
      domBase = vp.domBottom
    }
  }
  fromDOM(n2) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null
      if (!vp || n2 < vp.domTop) return base2 + (n2 - domBase) / this.scale
      if (n2 <= vp.domBottom) return vp.top + (n2 - vp.domTop)
      base2 = vp.bottom
      domBase = vp.domBottom
    }
  }
  eq(other) {
    if (!(other instanceof BigScaler)) return false
    return (
      this.scale == other.scale &&
      this.viewports.length == other.viewports.length &&
      this.viewports.every(
        (vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to
      )
    )
  }
}
function scaleBlock(block2, scaler) {
  if (scaler.scale == 1) return block2
  let bTop = scaler.toDOM(block2.top),
    bBottom = scaler.toDOM(block2.bottom)
  return new BlockInfo(
    block2.from,
    block2.length,
    bTop,
    bBottom - bTop,
    Array.isArray(block2._content)
      ? block2._content.map((b) => scaleBlock(b, scaler))
      : block2._content
  )
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(' ') })
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 })
const baseThemeID = /* @__PURE__ */ StyleModule.newName(),
  baseLightID = /* @__PURE__ */ StyleModule.newName(),
  baseDarkID = /* @__PURE__ */ StyleModule.newName()
const lightDarkIDs = { '&light': '.' + baseLightID, '&dark': '.' + baseDarkID }
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel)
        ? sel.replace(/&\w*/, (m) => {
            if (m == '&') return main
            if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`)
            return scopes[m]
          })
        : main + ' ' + sel
    }
  })
}
const baseTheme$1$1 = /* @__PURE__ */ buildTheme(
  '.' + baseThemeID,
  {
    '&': {
      position: 'relative !important',
      boxSizing: 'border-box',
      '&.cm-focused': {
        // Provide a simple default outline to make sure a focused
        // editor is visually distinct. Can't leave the default behavior
        // because that will apply to the content element, which is
        // inside the scrollable container and doesn't include the
        // gutters. We also can't use an 'auto' outline, since those
        // are, for some reason, drawn behind the element content, which
        // will cause things like the active line background to cover
        // the outline (#297).
        outline: '1px dotted #212121'
      },
      display: 'flex !important',
      flexDirection: 'column'
    },
    '.cm-scroller': {
      display: 'flex !important',
      alignItems: 'flex-start !important',
      fontFamily: 'monospace',
      lineHeight: 1.4,
      height: '100%',
      overflowX: 'auto',
      position: 'relative',
      zIndex: 0,
      overflowAnchor: 'none'
    },
    '.cm-content': {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: 'block',
      whiteSpace: 'pre',
      wordWrap: 'normal',
      // https://github.com/codemirror/dev/issues/456
      boxSizing: 'border-box',
      minHeight: '100%',
      padding: '4px 0',
      outline: 'none',
      '&[contenteditable=true]': {
        WebkitUserModify: 'read-write-plaintext-only'
      }
    },
    '.cm-lineWrapping': {
      whiteSpace_fallback: 'pre-wrap',
      // For IE
      whiteSpace: 'break-spaces',
      wordBreak: 'break-word',
      // For Safari, which doesn't support overflow-wrap: anywhere
      overflowWrap: 'anywhere',
      flexShrink: 1
    },
    '&light .cm-content': { caretColor: 'black' },
    '&dark .cm-content': { caretColor: 'white' },
    '.cm-line': {
      display: 'block',
      padding: '0 2px 0 6px'
    },
    '.cm-layer': {
      position: 'absolute',
      left: 0,
      top: 0,
      contain: 'size style',
      '& > *': {
        position: 'absolute'
      }
    },
    '&light .cm-selectionBackground': {
      background: '#d9d9d9'
    },
    '&dark .cm-selectionBackground': {
      background: '#222'
    },
    '&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': {
      background: '#d7d4f0'
    },
    '&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground': {
      background: '#233'
    },
    '.cm-cursorLayer': {
      pointerEvents: 'none'
    },
    '&.cm-focused > .cm-scroller > .cm-cursorLayer': {
      animation: 'steps(1) cm-blink 1.2s infinite'
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    '@keyframes cm-blink': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
    '@keyframes cm-blink2': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
    '.cm-cursor, .cm-dropCursor': {
      borderLeft: '1.2px solid black',
      marginLeft: '-0.6px',
      pointerEvents: 'none'
    },
    '.cm-cursor': {
      display: 'none'
    },
    '&dark .cm-cursor': {
      borderLeftColor: '#ddd'
    },
    '.cm-dropCursor': {
      position: 'absolute'
    },
    '&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor': {
      display: 'block'
    },
    '.cm-iso': {
      unicodeBidi: 'isolate'
    },
    '.cm-announced': {
      position: 'fixed',
      top: '-10000px'
    },
    '@media print': {
      '.cm-announced': { display: 'none' }
    },
    '&light .cm-activeLine': { backgroundColor: '#cceeff44' },
    '&dark .cm-activeLine': { backgroundColor: '#99eeff33' },
    '&light .cm-specialChar': { color: 'red' },
    '&dark .cm-specialChar': { color: '#f78' },
    '.cm-gutters': {
      flexShrink: 0,
      display: 'flex',
      height: '100%',
      boxSizing: 'border-box',
      zIndex: 200
    },
    '.cm-gutters-before': { insetInlineStart: 0 },
    '.cm-gutters-after': { insetInlineEnd: 0 },
    '&light .cm-gutters': {
      backgroundColor: '#f5f5f5',
      color: '#6c6c6c',
      border: '0px solid #ddd',
      '&.cm-gutters-before': { borderRightWidth: '1px' },
      '&.cm-gutters-after': { borderLeftWidth: '1px' }
    },
    '&dark .cm-gutters': {
      backgroundColor: '#333338',
      color: '#ccc'
    },
    '.cm-gutter': {
      display: 'flex !important',
      // Necessary -- prevents margin collapsing
      flexDirection: 'column',
      flexShrink: 0,
      boxSizing: 'border-box',
      minHeight: '100%',
      overflow: 'hidden'
    },
    '.cm-gutterElement': {
      boxSizing: 'border-box'
    },
    '.cm-lineNumbers .cm-gutterElement': {
      padding: '0 3px 0 5px',
      minWidth: '20px',
      textAlign: 'right',
      whiteSpace: 'nowrap'
    },
    '&light .cm-activeLineGutter': {
      backgroundColor: '#e2f2ff'
    },
    '&dark .cm-activeLineGutter': {
      backgroundColor: '#222227'
    },
    '.cm-panels': {
      boxSizing: 'border-box',
      position: 'sticky',
      left: 0,
      right: 0,
      zIndex: 300
    },
    '&light .cm-panels': {
      backgroundColor: '#f5f5f5',
      color: 'black'
    },
    '&light .cm-panels-top': {
      borderBottom: '1px solid #ddd'
    },
    '&light .cm-panels-bottom': {
      borderTop: '1px solid #ddd'
    },
    '&dark .cm-panels': {
      backgroundColor: '#333338',
      color: 'white'
    },
    '.cm-dialog': {
      padding: '2px 19px 4px 6px',
      position: 'relative',
      '& label': { fontSize: '80%' }
    },
    '.cm-dialog-close': {
      position: 'absolute',
      top: '3px',
      right: '4px',
      backgroundColor: 'inherit',
      border: 'none',
      font: 'inherit',
      fontSize: '14px',
      padding: '0'
    },
    '.cm-tab': {
      display: 'inline-block',
      overflow: 'hidden',
      verticalAlign: 'bottom'
    },
    '.cm-widgetBuffer': {
      verticalAlign: 'text-top',
      height: '1em',
      width: 0,
      display: 'inline'
    },
    '.cm-placeholder': {
      color: '#888',
      display: 'inline-block',
      verticalAlign: 'top',
      userSelect: 'none'
    },
    '.cm-highlightSpace': {
      backgroundImage: 'radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)',
      backgroundPosition: 'center'
    },
    '.cm-highlightTab': {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: 'auto 100%',
      backgroundPosition: 'right 90%',
      backgroundRepeat: 'no-repeat'
    },
    '.cm-trailingSpace': {
      backgroundColor: '#ff332255'
    },
    '.cm-button': {
      verticalAlign: 'middle',
      color: 'inherit',
      fontSize: '70%',
      padding: '.2em 1em',
      borderRadius: '1px'
    },
    '&light .cm-button': {
      backgroundImage: 'linear-gradient(#eff1f5, #d9d9df)',
      border: '1px solid #888',
      '&:active': {
        backgroundImage: 'linear-gradient(#b4b4b4, #d0d3d6)'
      }
    },
    '&dark .cm-button': {
      backgroundImage: 'linear-gradient(#393939, #111)',
      border: '1px solid #888',
      '&:active': {
        backgroundImage: 'linear-gradient(#111, #333)'
      }
    },
    '.cm-textfield': {
      verticalAlign: 'middle',
      color: 'inherit',
      fontSize: '70%',
      border: '1px solid silver',
      padding: '.2em .5em'
    },
    '&light .cm-textfield': {
      backgroundColor: 'white'
    },
    '&dark .cm-textfield': {
      border: '1px solid #555',
      backgroundColor: 'inherit'
    }
  },
  lightDarkIDs
)
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
}
const useCharData = browser.ie && browser.ie_version <= 11
class DOMObserver {
  constructor(view) {
    this.view = view
    this.active = false
    this.editContext = null
    this.selectionRange = new DOMSelectionState()
    this.selectionChanged = false
    this.delayedFlush = -1
    this.resizeTimeout = -1
    this.queue = []
    this.delayedAndroidKey = null
    this.flushingAndroidKey = -1
    this.lastChange = 0
    this.scrollTargets = []
    this.intersection = null
    this.resizeScroll = null
    this.intersecting = false
    this.gapIntersection = null
    this.gaps = []
    this.printQuery = null
    this.parentCheck = -1
    this.dom = view.contentDOM
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations) this.queue.push(mut)
      if (
        ((browser.ie && browser.ie_version <= 11) || (browser.ios && view.composing)) &&
        mutations.some(
          (m) =>
            (m.type == 'childList' && m.removedNodes.length) ||
            (m.type == 'characterData' && m.oldValue.length > m.target.nodeValue.length)
        )
      )
        this.flushSoon()
      else this.flush()
    })
    if (
      window.EditContext &&
      browser.android &&
      view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
      !(browser.chrome && browser.chrome_version < 126)
    ) {
      this.editContext = new EditContextManager(view)
      if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: 'characterData',
          oldValue: event.prevValue
        })
        this.flushSoon()
      }
    this.onSelectionChange = this.onSelectionChange.bind(this)
    this.onResize = this.onResize.bind(this)
    this.onPrint = this.onPrint.bind(this)
    this.onScroll = this.onScroll.bind(this)
    if (window.matchMedia) this.printQuery = window.matchMedia('print')
    if (typeof ResizeObserver == 'function') {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2
        if (
          ((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) <
          Date.now() - 75
        )
          this.onResize()
      })
      this.resizeScroll.observe(view.scrollDOM)
    }
    this.addWindowListeners((this.win = view.win))
    this.start()
    if (typeof IntersectionObserver == 'function') {
      this.intersection = new IntersectionObserver(
        (entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)
          if (
            entries.length > 0 &&
            entries[entries.length - 1].intersectionRatio > 0 != this.intersecting
          ) {
            this.intersecting = !this.intersecting
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent('Event'))
          }
        },
        { threshold: [0, 1e-3] }
      )
      this.intersection.observe(this.dom)
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent('Event'))
      }, {})
    }
    this.listenForScroll()
    this.readSelectionRange()
  }
  onScrollChanged(e2) {
    this.view.inputState.runHandlers('scroll', e2)
    if (this.intersecting) this.view.measure()
  }
  onScroll(e2) {
    if (this.intersecting) this.flush(false)
    if (this.editContext) this.view.requestMeasure(this.editContext.measureReq)
    this.onScrollChanged(e2)
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1
        this.view.requestMeasure()
      }, 50)
  }
  onPrint(event) {
    if ((event.type == 'change' || !event.type) && !event.matches) return
    this.view.viewState.printing = true
    this.view.measure()
    setTimeout(() => {
      this.view.viewState.printing = false
      this.view.requestMeasure()
    }, 500)
  }
  updateGaps(gaps) {
    if (
      this.gapIntersection &&
      (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))
    ) {
      this.gapIntersection.disconnect()
      for (let gap of gaps) this.gapIntersection.observe(gap)
      this.gaps = gaps
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged
    if (!this.readSelectionRange() || this.delayedAndroidKey) return
    let { view } = this,
      sel = this.selectionRange
    if (
      view.state.facet(editable)
        ? view.root.activeElement != this.dom
        : !hasSelection(this.dom, sel)
    )
      return
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode)
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged) this.selectionChanged = false
      return
    }
    if (
      ((browser.ie && browser.ie_version <= 11) || (browser.android && browser.chrome)) &&
      !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
      sel.focusNode &&
      isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)
    )
      this.flushSoon()
    else this.flush(false)
  }
  readSelectionRange() {
    let { view } = this
    let selection2 = getSelection(view.root)
    if (!selection2) return false
    let range =
      (browser.safari &&
        view.root.nodeType == 11 &&
        view.root.activeElement == this.dom &&
        safariSelectionRangeHack(this.view, selection2)) ||
      selection2
    if (!range || this.selectionRange.eq(range)) return false
    let local = hasSelection(this.dom, range)
    if (
      local &&
      !this.selectionChanged &&
      view.inputState.lastFocusTime > Date.now() - 200 &&
      view.inputState.lastTouchTime < Date.now() - 300 &&
      atElementStart(this.dom, range)
    ) {
      this.view.inputState.lastFocusTime = 0
      view.docView.updateSelection()
      return false
    }
    this.selectionRange.setRange(range)
    if (local) this.selectionChanged = true
    return true
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset)
    this.selectionChanged = false
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0)
  }
  listenForScroll() {
    this.parentCheck = -1
    let i = 0,
      changed = null
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++
        else if (!changed) changed = this.scrollTargets.slice(0, i)
        if (changed) changed.push(dom)
        dom = dom.assignedSlot || dom.parentNode
      } else if (dom.nodeType == 11) {
        dom = dom.host
      } else {
        break
      }
    }
    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i)
    if (changed) {
      for (let dom of this.scrollTargets) dom.removeEventListener('scroll', this.onScroll)
      for (let dom of (this.scrollTargets = changed)) dom.addEventListener('scroll', this.onScroll)
    }
  }
  ignore(f) {
    if (!this.active) return f()
    try {
      this.stop()
      return f()
    } finally {
      this.start()
      this.clear()
    }
  }
  start() {
    if (this.active) return
    this.observer.observe(this.dom, observeOptions)
    if (useCharData) this.dom.addEventListener('DOMCharacterDataModified', this.onCharData)
    this.active = true
  }
  stop() {
    if (!this.active) return
    this.active = false
    this.observer.disconnect()
    if (useCharData) this.dom.removeEventListener('DOMCharacterDataModified', this.onCharData)
  }
  // Throw away any pending changes
  clear() {
    this.processRecords()
    this.queue.length = 0
    this.selectionChanged = false
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey
        if (key2) {
          this.clearDelayedAndroidKey()
          this.view.inputState.lastKeyCode = key2.keyCode
          this.view.inputState.lastKeyTime = Date.now()
          let flushed = this.flush()
          if (!flushed && key2.force) dispatchKey(this.dom, key2.key, key2.keyCode)
        }
      }
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush)
    }
    if (!this.delayedAndroidKey || key == 'Enter')
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force:
          this.lastChange < Date.now() - 50 ||
          !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      }
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey)
    this.delayedAndroidKey = null
    this.flushingAndroidKey = -1
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1
        this.flush()
      })
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush)
      this.delayedFlush = -1
    }
    this.flush()
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords()) this.queue.push(mut)
    return this.queue
  }
  processRecords() {
    let records = this.pendingRecords()
    if (records.length) this.queue = []
    let from = -1,
      to = -1,
      typeOver = false
    for (let record of records) {
      let range = this.readMutation(record)
      if (!range) continue
      if (range.typeOver) typeOver = true
      if (from == -1) {
        ;({ from, to } = range)
      } else {
        from = Math.min(range.from, from)
        to = Math.max(range.to, to)
      }
    }
    return { from, to, typeOver }
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords()
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange)
    if (from < 0 && !newSel) return null
    if (from > -1) this.lastChange = Date.now()
    this.view.inputState.lastFocusTime = 0
    this.selectionChanged = false
    let change = new DOMChange(this.view, from, to, typeOver)
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null }
    return change
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false
    if (readSelection) this.readSelectionRange()
    let domChange = this.readChange()
    if (!domChange) {
      this.view.requestMeasure()
      return false
    }
    let startState = this.view.state
    let handled = applyDOMChange(this.view, domChange)
    if (
      this.view.state == startState &&
      (domChange.domChanged ||
        (domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
    )
      this.view.update([])
    return handled
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target)
    if (!cView || cView.ignoreMutation(rec)) return null
    cView.markDirty(rec.type == 'attributes')
    if (rec.type == 'attributes') cView.flags |= 4
    if (rec.type == 'childList') {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1)
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1)
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      }
    } else if (rec.type == 'characterData') {
      return {
        from: cView.posAtStart,
        to: cView.posAtEnd,
        typeOver: rec.target.nodeValue == rec.oldValue
      }
    } else {
      return null
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win)
      this.win = win
      this.addWindowListeners(this.win)
    }
  }
  addWindowListeners(win) {
    win.addEventListener('resize', this.onResize)
    if (this.printQuery) {
      if (this.printQuery.addEventListener) this.printQuery.addEventListener('change', this.onPrint)
      else this.printQuery.addListener(this.onPrint)
    } else win.addEventListener('beforeprint', this.onPrint)
    win.addEventListener('scroll', this.onScroll)
    win.document.addEventListener('selectionchange', this.onSelectionChange)
  }
  removeWindowListeners(win) {
    win.removeEventListener('scroll', this.onScroll)
    win.removeEventListener('resize', this.onResize)
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener('change', this.onPrint)
      else this.printQuery.removeListener(this.onPrint)
    } else win.removeEventListener('beforeprint', this.onPrint)
    win.document.removeEventListener('selectionchange', this.onSelectionChange)
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update)
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable)
          ? this.editContext.editContext
          : null
    }
  }
  destroy() {
    var _a2, _b, _c
    this.stop()
    ;(_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect()
    ;(_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect()
    ;(_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect()
    for (let dom of this.scrollTargets) dom.removeEventListener('scroll', this.onScroll)
    this.removeWindowListeners(this.win)
    clearTimeout(this.parentCheck)
    clearTimeout(this.resizeTimeout)
    this.win.cancelAnimationFrame(this.delayedFlush)
    this.win.cancelAnimationFrame(this.flushingAndroidKey)
    if (this.editContext) {
      this.view.contentDOM.editContext = null
      this.editContext.destroy()
    }
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom)
    if (curView && curView.parent == cView) return curView
    let parent = dom.parentNode
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling
  }
  return null
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer,
    anchorOffset = range.startOffset
  let focusNode = range.endContainer,
    focusOffset = range.endOffset
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor)
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [
      focusNode,
      focusOffset,
      anchorNode,
      anchorOffset
    ]
  return { anchorNode, anchorOffset, focusNode, focusOffset }
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0]
    if (range) return buildSelectionRangeFromRange(view, range)
  }
  let found = null
  function read(event) {
    event.preventDefault()
    event.stopImmediatePropagation()
    found = event.getTargetRanges()[0]
  }
  view.contentDOM.addEventListener('beforeinput', read, true)
  view.dom.ownerDocument.execCommand('indent')
  view.contentDOM.removeEventListener('beforeinput', read, true)
  return found ? buildSelectionRangeFromRange(view, found) : null
}
class EditContextManager {
  constructor(view) {
    this.from = 0
    this.to = 0
    this.pendingContextChange = null
    this.handlers = /* @__PURE__ */ Object.create(null)
    this.composing = null
    this.resetRange(view.state)
    let context = (this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(
        Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))
      ),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    }))
    this.handlers.textupdate = (e2) => {
      let main = view.state.selection.main,
        { anchor, head } = main
      let from = this.toEditorPos(e2.updateRangeStart),
        to = this.toEditorPos(e2.updateRangeEnd)
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e2.updateRangeStart, editorBase: from, drifted: false }
      let change = { from, to, insert: Text.of(e2.text.split('\n')) }
      if (change.from == this.from && anchor < this.from) change.from = anchor
      else if (change.to == this.to && anchor > this.to) change.to = anchor
      if (change.from == change.to && !change.insert.length) {
        let newSel = EditorSelection.single(
          this.toEditorPos(e2.selectionStart),
          this.toEditorPos(e2.selectionEnd)
        )
        if (!newSel.main.eq(main)) view.dispatch({ selection: newSel, userEvent: 'select' })
        return
      }
      if (
        (browser.mac || browser.android) &&
        change.from == head - 1 &&
        /^\. ?$/.test(e2.text) &&
        view.contentDOM.getAttribute('autocorrect') == 'off'
      )
        change = { from, to, insert: Text.of([e2.text.replace('.', ' ')]) }
      this.pendingContextChange = change
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length)
        applyDOMChangeInner(
          view,
          change,
          EditorSelection.single(
            this.toEditorPos(e2.selectionStart, newLen),
            this.toEditorPos(e2.selectionEnd, newLen)
          )
        )
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state)
        this.setSelection(view.state)
      }
    }
    this.handlers.characterboundsupdate = (e2) => {
      let rects = [],
        prev = null
      for (
        let i = this.toEditorPos(e2.rangeStart), end = this.toEditorPos(e2.rangeEnd);
        i < end;
        i++
      ) {
        let rect = view.coordsForChar(i)
        prev =
          (rect &&
            new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top)) ||
          prev ||
          new DOMRect()
        rects.push(prev)
      }
      context.updateCharacterBounds(e2.rangeStart, rects)
    }
    this.handlers.textformatupdate = (e2) => {
      let deco = []
      for (let format2 of e2.getTextFormats()) {
        let lineStyle = format2.underlineStyle,
          thickness = format2.underlineThickness
        if (lineStyle != 'None' && thickness != 'None') {
          let from = this.toEditorPos(format2.rangeStart),
            to = this.toEditorPos(format2.rangeEnd)
          if (from < to) {
            let style = `text-decoration: underline ${lineStyle == 'Dashed' ? 'dashed ' : lineStyle == 'Squiggle' ? 'wavy ' : ''}${thickness == 'Thin' ? 1 : 2}px`
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to))
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) })
    }
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0
        view.inputState.compositionFirstChange = true
      }
    }
    this.handlers.compositionend = () => {
      view.inputState.composing = -1
      view.inputState.compositionFirstChange = null
      if (this.composing) {
        let { drifted } = this.composing
        this.composing = null
        if (drifted) this.reset(view.state)
      }
    }
    for (let event in this.handlers) context.addEventListener(event, this.handlers[event])
    this.measureReq = {
      read: (view2) => {
        this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect())
        let sel = getSelection(view2.root)
        if (sel && sel.rangeCount)
          this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect())
      }
    }
  }
  applyEdits(update) {
    let off = 0,
      abort = false,
      pending = this.pendingContextChange
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort) return
      let dLen = insert2.length - (toA - fromA)
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null
          off += dLen
          this.to += dLen
          return
        } else {
          pending = null
          this.revertPending(update.state)
        }
      }
      fromA += off
      toA += off
      if (toA <= this.from) {
        this.from += dLen
        this.to += dLen
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true
          return
        }
        this.editContext.updateText(
          this.toContextPos(fromA),
          this.toContextPos(toA),
          insert2.toString()
        )
        this.to += dLen
      }
      off += dLen
    })
    if (pending && !abort) this.revertPending(update.state)
    return !abort
  }
  update(update) {
    let reverted = this.pendingContextChange,
      startSel = update.startState.selection.main
    if (
      this.composing &&
      (this.composing.drifted ||
        (!update.changes.touchesRange(startSel.from, startSel.to) &&
          update.transactions.some(
            (tr) => !tr.isUserEvent('input.type') && tr.changes.touchesRange(this.from, this.to)
          )))
    ) {
      this.composing.drifted = true
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase)
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null
      this.reset(update.state)
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state)
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq)
  }
  resetRange(state) {
    let { head } = state.selection.main
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    )
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    )
  }
  reset(state) {
    this.resetRange(state)
    this.editContext.updateText(
      0,
      this.editContext.text.length,
      state.doc.sliceString(this.from, this.to)
    )
    this.setSelection(state)
  }
  revertPending(state) {
    let pending = this.pendingContextChange
    this.pendingContextChange = null
    this.editContext.updateText(
      this.toContextPos(pending.from),
      this.toContextPos(pending.from + pending.insert.length),
      state.doc.sliceString(pending.from, pending.to)
    )
  }
  setSelection(state) {
    let { main } = state.selection
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)))
    let end = this.toContextPos(main.head)
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end)
  }
  rangeIsValid(state) {
    let { head } = state.selection.main
    return !(
      (this.from > 0 && head - this.from < 500) ||
      (this.to < state.doc.length && this.to - head < 500) ||
      this.to - this.from > 1e4 * 3
    )
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen)
    let c = this.composing
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from
  }
  toContextPos(editorPos) {
    let c = this.composing
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event])
  }
}
class EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a2
    this.plugins = []
    this.pluginMap = /* @__PURE__ */ new Map()
    this.editorAttrs = {}
    this.contentAttrs = {}
    this.bidiCache = []
    this.destroyed = false
    this.updateState = 2
    this.measureScheduled = -1
    this.measureRequests = []
    this.contentDOM = document.createElement('div')
    this.scrollDOM = document.createElement('div')
    this.scrollDOM.tabIndex = -1
    this.scrollDOM.className = 'cm-scroller'
    this.scrollDOM.appendChild(this.contentDOM)
    this.announceDOM = document.createElement('div')
    this.announceDOM.className = 'cm-announced'
    this.announceDOM.setAttribute('aria-live', 'polite')
    this.dom = document.createElement('div')
    this.dom.appendChild(this.announceDOM)
    this.dom.appendChild(this.scrollDOM)
    if (config2.parent) config2.parent.appendChild(this.dom)
    let { dispatch } = config2
    this.dispatchTransactions =
      config2.dispatchTransactions ||
      (dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this)))) ||
      ((trs) => this.update(trs))
    this.dispatch = this.dispatch.bind(this)
    this._root = config2.root || getRoot(config2.parent) || document
    this.viewState = new ViewState(config2.state || EditorState.create(config2))
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView$1))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state)
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec))
    for (let plugin of this.plugins) plugin.update(this)
    this.observer = new DOMObserver(this)
    this.inputState = new InputState(this)
    this.inputState.ensureHandlers(this.plugins)
    this.docView = new DocView(this)
    this.mountStyles()
    this.updateAttrs()
    this.updateState = 0
    this.requestMeasure()
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => this.requestMeasure())
  }
  dispatch(...input) {
    let trs =
      input.length == 1 && input[0] instanceof Transaction
        ? input
        : input.length == 1 && Array.isArray(input[0])
          ? input[0]
          : [this.state.update(...input)]
    this.dispatchTransactions(trs, this)
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.update are not allowed while an update is in progress')
    let redrawn = false,
      attrsChanged = false,
      update
    let state = this.state
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError(
          "Trying to update state with a transaction that doesn't start from the previous state."
        )
      state = tr.state
    }
    if (this.destroyed) {
      this.viewState.state = state
      return
    }
    let focus = this.hasFocus,
      focusFlag = 0,
      dispatchFocus = null
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus
      focusFlag = 1
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus
      dispatchFocus = focusChangeTransaction(state, focus)
      if (!dispatchFocus) focusFlag = 1
    }
    let pendingKey = this.observer.delayedAndroidKey,
      domChange = null
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey()
      domChange = this.observer.readChange()
      if ((domChange && !this.state.doc.eq(state.doc)) || !this.state.selection.eq(state.selection))
        domChange = null
    } else {
      this.observer.clear()
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state)
    update = ViewUpdate.create(this, state, transactions)
    update.flags |= focusFlag
    let scrollTarget = this.viewState.scrollTarget
    try {
      this.updateState = 2
      for (let tr of transactions) {
        if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes)
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection
          scrollTarget = new ScrollTarget(
            main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1)
          )
        }
        for (let e2 of tr.effects)
          if (e2.is(scrollIntoView$1)) scrollTarget = e2.value.clip(this.state)
      }
      this.viewState.update(update, scrollTarget)
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes)
      if (!update.empty) {
        this.updatePlugins(update)
        this.inputState.update(update)
      }
      redrawn = this.docView.update(update)
      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles()
      attrsChanged = this.updateAttrs()
      this.showAnnouncements(transactions)
      this.docView.updateSelection(
        redrawn,
        transactions.some((tr) => tr.isUserEvent('select.pointer'))
      )
    } finally {
      this.updateState = 0
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true
    if (
      redrawn ||
      attrsChanged ||
      scrollTarget ||
      this.viewState.mustEnforceCursorAssoc ||
      this.viewState.mustMeasureContent
    )
      this.requestMeasure()
    if (redrawn) this.docViewUpdate()
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update)
        } catch (e2) {
          logException(this.state, e2, 'update listener')
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus)
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode)
        }
      })
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error('Calls to EditorView.setState are not allowed while an update is in progress')
    if (this.destroyed) {
      this.viewState.state = newState
      return
    }
    this.updateState = 2
    let hadFocus = this.hasFocus
    try {
      for (let plugin of this.plugins) plugin.destroy(this)
      this.viewState = new ViewState(newState)
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec))
      this.pluginMap.clear()
      for (let plugin of this.plugins) plugin.update(this)
      this.docView.destroy()
      this.docView = new DocView(this)
      this.inputState.ensureHandlers(this.plugins)
      this.mountStyles()
      this.updateAttrs()
      this.bidiCache = []
    } finally {
      this.updateState = 0
    }
    if (hadFocus) this.focus()
    this.requestMeasure()
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin),
      specs = update.state.facet(viewPlugin)
    if (prevSpecs != specs) {
      let newPlugins = []
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec)
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec))
        } else {
          let plugin = this.plugins[found]
          plugin.mustUpdate = update
          newPlugins.push(plugin)
        }
      }
      for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this)
      this.plugins = newPlugins
      this.pluginMap.clear()
    } else {
      for (let p of this.plugins) p.mustUpdate = update
    }
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this)
    if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins)
  }
  docViewUpdate() {
    for (let plugin of this.plugins) {
      let val = plugin.value
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this)
        } catch (e2) {
          logException(this.state, e2, 'doc view update listener')
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed) return
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled)
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1
      this.requestMeasure()
      return
    }
    this.measureScheduled = 0
    if (flush) this.observer.forceFlush()
    let updated = null
    let sDOM = this.scrollDOM,
      scrollTop = sDOM.scrollTop * this.scaleY
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1
    this.viewState.scrollAnchorHeight = -1
    try {
      for (let i = 0; ; i++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1
            scrollAnchorHeight = this.viewState.heightMap.height
          } else {
            let block2 = this.viewState.scrollAnchorAt(scrollTop)
            scrollAnchorPos = block2.from
            scrollAnchorHeight = block2.top
          }
        }
        this.updateState = 1
        let changed = this.viewState.measure(this)
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break
        if (i > 5) {
          console.warn(
            this.measureRequests.length
              ? 'Measure loop restarted more than 5 times'
              : 'Viewport failed to stabilize'
          )
          break
        }
        let measuring = []
        if (!(changed & 4)) [this.measureRequests, measuring] = [measuring, this.measureRequests]
        let measured = measuring.map((m) => {
          try {
            return m.read(this)
          } catch (e2) {
            logException(this.state, e2)
            return BadMeasure
          }
        })
        let update = ViewUpdate.create(this, this.state, []),
          redrawn = false
        update.flags |= changed
        if (!updated) updated = update
        else updated.flags |= changed
        this.updateState = 2
        if (!update.empty) {
          this.updatePlugins(update)
          this.inputState.update(update)
          this.updateAttrs()
          redrawn = this.docView.update(update)
          if (redrawn) this.docViewUpdate()
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2]
              if (m.write) m.write(measured[i2], this)
            } catch (e2) {
              logException(this.state, e2)
            }
          }
        if (redrawn) this.docView.updateSelection(true)
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget)
              this.viewState.scrollTarget = null
              scrollAnchorHeight = -1
              continue
            } else {
              let newAnchorHeight =
                scrollAnchorPos < 0
                  ? this.viewState.heightMap.height
                  : this.viewState.lineBlockAt(scrollAnchorPos).top
              let diff = newAnchorHeight - scrollAnchorHeight
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff
                sDOM.scrollTop = scrollTop / this.scaleY
                scrollAnchorHeight = -1
                continue
              }
            }
          }
          break
        }
      }
    } finally {
      this.updateState = 0
      this.measureScheduled = -1
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener)) listener(updated)
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return (
      baseThemeID +
      ' ' +
      (this.state.facet(darkTheme) ? baseDarkID : baseLightID) +
      ' ' +
      this.state.facet(theme)
    )
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: 'cm-editor' + (this.hasFocus ? ' cm-focused ' : ' ') + this.themeClasses
    })
    let contentAttrs = {
      spellcheck: 'false',
      autocorrect: 'off',
      autocapitalize: 'off',
      writingsuggestions: 'false',
      translate: 'no',
      contenteditable: !this.state.facet(editable) ? 'false' : 'true',
      class: 'cm-content',
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: 'textbox',
      'aria-multiline': 'true'
    }
    if (this.state.readOnly) contentAttrs['aria-readonly'] = 'true'
    attrsFromFacet(this, contentAttributes, contentAttrs)
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs)
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs)
      return changedContent || changedEditor
    })
    this.editorAttrs = editorAttrs
    this.contentAttrs = contentAttrs
    return changed
  }
  showAnnouncements(trs) {
    let first = true
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first) this.announceDOM.textContent = ''
          first = false
          let div = this.announceDOM.appendChild(document.createElement('div'))
          div.textContent = effect.value
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule)
    let nonce = this.state.facet(EditorView.cspNonce)
    StyleModule.mount(
      this.root,
      this.styleModules.concat(baseTheme$1$1).reverse(),
      nonce ? { nonce } : void 0
    )
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update")
    if (this.updateState == 0 && this.measureScheduled > -1) this.measure(false)
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())
    if (request) {
      if (this.measureRequests.indexOf(request) > -1) return
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request
            return
          }
        }
      this.measureRequests.push(request)
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin)
    if (known === void 0 || (known && known.plugin != plugin))
      this.pluginMap.set(plugin, (known = this.plugins.find((p) => p.plugin == plugin) || null))
    return known && known.update(this).value
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom }
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured()
    return this.viewState.elementAtHeight(height)
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured()
    return this.viewState.lineBlockAtHeight(height)
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos)
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by))
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(
      this,
      start,
      moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial))
    )
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line),
      dir = this.textDirectionAt(line.from)
    let span = order[end ? order.length - 1 : 0]
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1)
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap)
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance))
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos)
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset)
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured()
    return posAtCoords(this, coords, precise)
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured()
    let rect = this.docView.coordsAt(pos, side)
    if (!rect || rect.left == rect.right) return rect
    let line = this.state.doc.lineAt(pos),
      order = this.bidiSpans(line)
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)]
    return flattenRect(rect, (span.dir == Direction.LTR) == side > 0)
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured()
    return this.docView.coordsForChar(pos)
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection)
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection
    this.readMeasured()
    return this.docView.textDirectionAt(pos)
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine) return trivialOrder(line.length)
    let dir = this.textDirectionAt(line.from),
      isolates
    for (let entry of this.bidiCache) {
      if (
        entry.from == line.from &&
        entry.dir == dir &&
        (entry.fresh || isolatesEq(entry.isolates, (isolates = getIsolatedRanges(this, line))))
      )
        return entry.order
    }
    if (!isolates) isolates = getIsolatedRanges(this, line)
    let order = computeOrder(line.text, dir, isolates)
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order))
    return order
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (browser.safari &&
          ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) >
            Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    )
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM)
      this.docView.updateSelection()
    })
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root
      this.observer.setWindow(
        (root.nodeType == 9 ? root : root.ownerDocument).defaultView || window
      )
      this.mountStyles()
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM) this.contentDOM.blur()
    for (let plugin of this.plugins) plugin.destroy(this)
    this.plugins = []
    this.inputState.destroy()
    this.docView.destroy()
    this.dom.remove()
    this.observer.destroy()
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled)
    this.destroyed = true
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView$1.of(
      new ScrollTarget(
        typeof pos == 'number' ? EditorSelection.cursor(pos) : pos,
        options.y,
        options.x,
        options.yMargin,
        options.xMargin
      )
    )
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM
    let ref2 = this.viewState.scrollAnchorAt(scrollTop)
    return scrollIntoView$1.of(
      new ScrollTarget(
        EditorSelection.cursor(ref2.from),
        'start',
        'start',
        ref2.top - scrollTop,
        scrollLeft,
        true
      )
    )
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1
    else if (typeof to == 'boolean') this.inputState.tabFocusMode = to ? 0 : -1
    else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 })
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 })
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix2 = StyleModule.newName()
    let result = [theme.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))]
    if (options && options.dark) result.push(darkTheme.of(true))
    return result
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme('.' + baseThemeID, spec, lightDarkIDs)))
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2
    let content2 = dom.querySelector('.cm-content')
    let cView = (content2 && ContentView.get(content2)) || ContentView.get(dom)
    return (
      ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null ||
      _a2 === void 0
        ? void 0
        : _a2.view) || null
    )
  }
}
EditorView.styleModule = styleModule
EditorView.inputHandler = inputHandler
EditorView.clipboardInputFilter = clipboardInputFilter
EditorView.clipboardOutputFilter = clipboardOutputFilter
EditorView.scrollHandler = scrollHandler
EditorView.focusChangeEffect = focusChangeEffect
EditorView.perLineTextDirection = perLineTextDirection
EditorView.exceptionSink = exceptionSink
EditorView.updateListener = updateListener
EditorView.editable = editable
EditorView.mouseSelectionStyle = mouseSelectionStyle
EditorView.dragMovesSelection = dragMovesSelection$1
EditorView.clickAddsSelectionRange = clickAddsSelectionRange
EditorView.decorations = decorations
EditorView.outerDecorations = outerDecorations
EditorView.atomicRanges = atomicRanges
EditorView.bidiIsolatedRanges = bidiIsolatedRanges
EditorView.scrollMargins = scrollMargins
EditorView.darkTheme = darkTheme
EditorView.cspNonce = /* @__PURE__ */ Facet.define({
  combine: (values2) => (values2.length ? values2[0] : '')
})
EditorView.contentAttributes = contentAttributes
EditorView.editorAttributes = editorAttributes
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({
  class: 'cm-lineWrapping'
})
EditorView.announce = /* @__PURE__ */ StateEffect.define()
const MaxBidiLine = 4096
const BadMeasure = {}
class CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from
    this.to = to
    this.dir = dir
    this.isolates = isolates
    this.fresh = fresh
    this.order = order
  }
  static update(cache2, changes) {
    if (changes.empty && !cache2.some((c) => c.fresh)) return cache2
    let result = [],
      lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR
    for (let i = Math.max(0, cache2.length - 10); i < cache2.length; i++) {
      let entry = cache2[i]
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(
          new CachedOrder(
            changes.mapPos(entry.from, 1),
            changes.mapPos(entry.to, -1),
            entry.dir,
            entry.isolates,
            false,
            entry.order
          )
        )
    }
    return result
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i],
      value = typeof source == 'function' ? source(view) : source
    if (value) combineAttrs(value, base2)
  }
  return base2
}
const currentPlatform = browser.mac
  ? 'mac'
  : browser.windows
    ? 'win'
    : browser.linux
      ? 'linux'
      : 'key'
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/)
  let result = parts[parts.length - 1]
  if (result == 'Space') result = ' '
  let alt, ctrl, shift2, meta2
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i]
    if (/^(cmd|meta|m)$/i.test(mod)) meta2 = true
    else if (/^a(lt)?$/i.test(mod)) alt = true
    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true
    else if (/^s(hift)?$/i.test(mod)) shift2 = true
    else if (/^mod$/i.test(mod)) {
      if (platform == 'mac') meta2 = true
      else ctrl = true
    } else throw new Error('Unrecognized modifier name: ' + mod)
  }
  if (alt) result = 'Alt-' + result
  if (ctrl) result = 'Ctrl-' + result
  if (meta2) result = 'Meta-' + result
  if (shift2) result = 'Shift-' + result
  return result
}
function modifiers(name2, event, shift2) {
  if (event.altKey) name2 = 'Alt-' + name2
  if (event.ctrlKey) name2 = 'Ctrl-' + name2
  if (event.metaKey) name2 = 'Meta-' + name2
  if (shift2 !== false && event.shiftKey) name2 = 'Shift-' + name2
  return name2
}
const handleKeyEvents = /* @__PURE__ */ Prec.default(
  /* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, 'editor')
    }
  })
)
const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents })
const Keymaps = /* @__PURE__ */ new WeakMap()
function getKeymap(state) {
  let bindings = state.facet(keymap)
  let map2 = Keymaps.get(bindings)
  if (!map2) Keymaps.set(bindings, (map2 = buildKeymap(bindings.reduce((a, b) => a.concat(b), []))))
  return map2
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope)
}
let storedPrefix = null
const PrefixTimeout = 4e3
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null)
  let isPrefix = /* @__PURE__ */ Object.create(null)
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2]
    if (current == null) isPrefix[name2] = is
    else if (current != is)
      throw new Error(
        'Key binding ' + name2 + ' is used both as a regular binding and as a multi-stroke prefix'
      )
  }
  let add3 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null))
    let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform))
    for (let i = 1; i < parts.length; i++) {
      let prefix2 = parts.slice(0, i).join(' ')
      checkPrefix(prefix2, true)
      if (!scopeObj[prefix2])
        scopeObj[prefix2] = {
          preventDefault: true,
          stopPropagation: false,
          run: [
            (view) => {
              let ourObj = (storedPrefix = { view, prefix: prefix2, scope })
              setTimeout(() => {
                if (storedPrefix == ourObj) storedPrefix = null
              }, PrefixTimeout)
              return true
            }
          ]
        }
    }
    let full = parts.join(' ')
    checkPrefix(full, false)
    let binding =
      scopeObj[full] ||
      (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run:
          ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null ||
          _b === void 0
            ? void 0
            : _b.slice()) || []
      })
    if (command2) binding.run.push(command2)
    if (preventDefault) binding.preventDefault = true
    if (stopPropagation) binding.stopPropagation = true
  }
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(' ') : ['editor']
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null))
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] }
        let { any } = b
        for (let key in scopeObj) scopeObj[key].run.push((view) => any(view, currentKeyEvent))
      }
    let name2 = b[platform] || b.key
    if (!name2) continue
    for (let scope of scopes) {
      add3(scope, name2, b.run, b.preventDefault, b.stopPropagation)
      if (b.shift) add3(scope, 'Shift-' + name2, b.shift, b.preventDefault, b.stopPropagation)
    }
  }
  return bound
}
let currentKeyEvent = null
function runHandlers(map2, event, view, scope) {
  currentKeyEvent = event
  let name2 = keyName(event)
  let charCode = codePointAt(name2, 0),
    isChar = codePointSize(charCode) == name2.length && name2 != ' '
  let prefix2 = '',
    handled = false,
    prevented = false,
    stopPropagation = false
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix2 = storedPrefix.prefix + ' '
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true
      storedPrefix = null
    }
  }
  let ran = /* @__PURE__ */ new Set()
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2)
          if (cmd2(view)) {
            if (binding.stopPropagation) stopPropagation = true
            return true
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation) stopPropagation = true
        prevented = true
      }
    }
    return false
  }
  let scopeObj = map2[scope],
    baseName,
    shiftName
  if (scopeObj) {
    if (runFor(scopeObj[prefix2 + modifiers(name2, event, !isChar)])) {
      handled = true
    } else if (
      isChar &&
      (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
      !(browser.mac && event.altKey && !event.ctrlKey) &&
      (baseName = base[event.keyCode]) &&
      baseName != name2
    ) {
      if (runFor(scopeObj[prefix2 + modifiers(baseName, event, true)])) {
        handled = true
      } else if (
        event.shiftKey &&
        (shiftName = shift[event.keyCode]) != name2 &&
        shiftName != baseName &&
        runFor(scopeObj[prefix2 + modifiers(shiftName, event, false)])
      ) {
        handled = true
      }
    } else if (
      isChar &&
      event.shiftKey &&
      runFor(scopeObj[prefix2 + modifiers(name2, event, true)])
    ) {
      handled = true
    }
    if (!handled && runFor(scopeObj._any)) handled = true
  }
  if (prevented) handled = true
  if (handled && stopPropagation) event.stopPropagation()
  currentKeyEvent = null
  return handled
}
class RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className
    this.left = left
    this.top = top2
    this.width = width
    this.height = height
  }
  draw() {
    let elt2 = document.createElement('div')
    elt2.className = this.className
    this.adjust(elt2)
    return elt2
  }
  update(elt2, prev) {
    if (prev.className != this.className) return false
    this.adjust(elt2)
    return true
  }
  adjust(elt2) {
    elt2.style.left = this.left + 'px'
    elt2.style.top = this.top + 'px'
    if (this.width != null) elt2.style.width = this.width + 'px'
    elt2.style.height = this.height + 'px'
  }
  eq(p) {
    return (
      this.left == p.left &&
      this.top == p.top &&
      this.width == p.width &&
      this.height == p.height &&
      this.className == p.className
    )
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1)
      if (!pos) return []
      let base2 = getBase(view)
      return [
        new RectangleMarker(
          className,
          pos.left - base2.left,
          pos.top - base2.top,
          null,
          pos.bottom - pos.top
        )
      ]
    } else {
      return rectanglesForRange(view, className, range)
    }
  }
}
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect()
  let left =
    view.textDirection == Direction.LTR
      ? rect.left
      : rect.right - view.scrollDOM.clientWidth * view.scaleX
  return {
    left: left - view.scrollDOM.scrollLeft * view.scaleX,
    top: rect.top - view.scrollDOM.scrollTop * view.scaleY
  }
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2)
  if (!coords) return inside2
  let editorRect = view.dom.getBoundingClientRect()
  let y2 = (coords.top + coords.bottom) / 2
  let left = view.posAtCoords({ x: editorRect.left + 1, y: y2 })
  let right = view.posAtCoords({ x: editorRect.right - 1, y: y2 })
  if (left == null || right == null) return inside2
  return {
    from: Math.max(inside2.from, Math.min(left, right)),
    to: Math.min(inside2.to, Math.max(left, right))
  }
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return []
  let from = Math.max(range.from, view.viewport.from),
    to = Math.min(range.to, view.viewport.to)
  let ltr = view.textDirection == Direction.LTR
  let content2 = view.contentDOM,
    contentRect = content2.getBoundingClientRect(),
    base2 = getBase(view)
  let lineElt = content2.querySelector('.cm-line'),
    lineStyle = lineElt && window.getComputedStyle(lineElt)
  let leftSide =
    contentRect.left +
    (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0)
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0)
  let startBlock = blockAt(view, from, 1),
    endBlock = blockAt(view, to, -1)
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart)
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd)
  if (
    visualStart &&
    visualEnd &&
    visualStart.from == visualEnd.from &&
    visualStart.to == visualEnd.to
  ) {
    return pieces(drawForLine(range.from, range.to, visualStart))
  } else {
    let top2 = visualStart
      ? drawForLine(range.from, null, visualStart)
      : drawForWidget(startBlock, false)
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true)
    let between = []
    if (
      (visualStart || startBlock).to <
        (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
      (startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
    )
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top))
    else if (
      top2.bottom < bottom.top &&
      view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text
    )
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2
    return pieces(top2).concat(between).concat(pieces(bottom))
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(
      className,
      left - base2.left,
      top2 - base2.top,
      right - left,
      bottom - top2
    )
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = []
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom))
    return pieces2
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9,
      bottom = -1e9,
      horizontal = []
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2)
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2)
      if (!fromCoords || !toCoords) return
      top2 = Math.min(fromCoords.top, toCoords.top, top2)
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom)
      if (dir == Direction.LTR)
        horizontal.push(
          ltr && fromOpen ? leftSide : fromCoords.left,
          ltr && toOpen ? rightSide : toCoords.right
        )
      else
        horizontal.push(
          !ltr && toOpen ? leftSide : toCoords.left,
          !ltr && fromOpen ? rightSide : fromCoords.right
        )
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from,
      end = to2 !== null && to2 !== void 0 ? to2 : line.to
    for (let r2 of view.visibleRanges)
      if (r2.to > start && r2.from < end) {
        for (let pos = Math.max(r2.from, start), endPos = Math.min(r2.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos)
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from,
              spanTo = span.to + docLine.from
            if (spanFrom >= endPos) break
            if (spanTo > pos)
              addSpan(
                Math.max(spanFrom, pos),
                from2 == null && spanFrom <= start,
                Math.min(spanTo, endPos),
                to2 == null && spanTo >= end,
                span.dir
              )
          }
          pos = docLine.to + 1
          if (pos >= endPos) break
        }
      }
    if (horizontal.length == 0) addSpan(start, from2 == null, end, to2 == null, view.textDirection)
    return { top: top2, bottom, horizontal }
  }
  function drawForWidget(block2, top2) {
    let y2 = contentRect.top + (top2 ? block2.top : block2.bottom)
    return { top: y2, bottom: y2, horizontal: [] }
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b)
}
class LayerView {
  constructor(view, layer2) {
    this.view = view
    this.layer = layer2
    this.drawn = []
    this.scaleX = 1
    this.scaleY = 1
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }
    this.dom = view.scrollDOM.appendChild(document.createElement('div'))
    this.dom.classList.add('cm-layer')
    if (layer2.above) this.dom.classList.add('cm-layer-above')
    if (layer2.class) this.dom.classList.add(layer2.class)
    this.scale()
    this.dom.setAttribute('aria-hidden', 'true')
    this.setOrder(view.state)
    view.requestMeasure(this.measureReq)
    if (layer2.mount) layer2.mount(this.dom, view)
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state)
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale()
      update.view.requestMeasure(this.measureReq)
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq)
  }
  setOrder(state) {
    let pos = 0,
      order = state.facet(layerOrder)
    while (pos < order.length && order[pos] != this.layer) pos++
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos)
  }
  measure() {
    return this.layer.markers(this.view)
  }
  scale() {
    let { scaleX, scaleY } = this.view
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX
      this.scaleY = scaleY
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`
    }
  }
  draw(markers) {
    if (
      markers.length != this.drawn.length ||
      markers.some((p, i) => !sameMarker(p, this.drawn[i]))
    ) {
      let old = this.dom.firstChild,
        oldI = 0
      for (let marker of markers) {
        if (
          marker.update &&
          old &&
          marker.constructor &&
          this.drawn[oldI].constructor &&
          marker.update(old, this.drawn[oldI])
        ) {
          old = old.nextSibling
          oldI++
        } else {
          this.dom.insertBefore(marker.draw(), old)
        }
      }
      while (old) {
        let next = old.nextSibling
        old.remove()
        old = next
      }
      this.drawn = markers
    }
  }
  destroy() {
    if (this.layer.destroy) this.layer.destroy(this.dom, this.view)
    this.dom.remove()
  }
}
const layerOrder = /* @__PURE__ */ Facet.define()
function layer(config2) {
  return [ViewPlugin.define((v) => new LayerView(v, config2)), layerOrder.of(config2)]
}
const selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(
      configs,
      {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      },
      {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      }
    )
  }
})
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ]
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig)
}
const cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view,
      conf = state.facet(selectionConfig)
    let cursors = []
    for (let r2 of state.selection.ranges) {
      let prim = r2 == state.selection.main
      if (r2.empty || conf.drawRangeCursor) {
        let className = prim ? 'cm-cursor cm-cursor-primary' : 'cm-cursor cm-cursor-secondary'
        let cursor2 = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1)
        for (let piece of RectangleMarker.forRange(view, className, cursor2)) cursors.push(piece)
      }
    }
    return cursors
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == 'cm-blink' ? 'cm-blink2' : 'cm-blink'
    let confChange = configChanged(update)
    if (confChange) setBlinkRate(update.state, dom)
    return update.docChanged || update.selectionSet || confChange
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom)
  },
  class: 'cm-cursorLayer'
})
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + 'ms'
}
const selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges
      .map((r2) => (r2.empty ? [] : RectangleMarker.forRange(view, 'cm-selectionBackground', r2)))
      .reduce((a, b) => a.concat(b))
  },
  update(update, dom) {
    return (
      update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update)
    )
  },
  class: 'cm-selectionLayer'
})
const hideNativeSelection = /* @__PURE__ */ Prec.highest(
  /* @__PURE__ */ EditorView.theme({
    '.cm-line': {
      '& ::selection, &::selection': { backgroundColor: 'transparent !important' },
      caretColor: 'transparent !important'
    },
    '.cm-content': {
      caretColor: 'transparent !important',
      '& :focus': {
        caretColor: 'initial !important',
        '&::selection, & ::selection': {
          backgroundColor: 'Highlight !important'
        }
      }
    }
  })
)
class Placeholder extends WidgetType {
  constructor(content2) {
    super()
    this.content = content2
  }
  toDOM(view) {
    let wrap = document.createElement('span')
    wrap.className = 'cm-placeholder'
    wrap.style.pointerEvents = 'none'
    wrap.appendChild(
      typeof this.content == 'string'
        ? document.createTextNode(this.content)
        : typeof this.content == 'function'
          ? this.content(view)
          : this.content.cloneNode(true)
    )
    wrap.setAttribute('aria-hidden', 'true')
    return wrap
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : []
    if (!rects.length) return null
    let style = window.getComputedStyle(dom.parentNode)
    let rect = flattenRect(rects[0], style.direction != 'rtl')
    let lineHeight = parseInt(style.lineHeight)
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight }
    return rect
  }
  ignoreEvent() {
    return false
  }
}
function placeholder(content2) {
  let plugin = ViewPlugin.fromClass(
    class {
      constructor(view) {
        this.view = view
        this.placeholder = content2
          ? Decoration.set([
              Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)
            ])
          : Decoration.none
      }
      get decorations() {
        return this.view.state.doc.length ? Decoration.none : this.placeholder
      }
    },
    { decorations: (v) => v.decorations }
  )
  return typeof content2 == 'string'
    ? [plugin, EditorView.contentAttributes.of({ 'aria-placeholder': content2 })]
    : plugin
}
const Outside = '-10000px'
class TooltipViewManager {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet
    this.createTooltipView = createTooltipView
    this.removeTooltipView = removeTooltipView
    this.input = view.state.facet(facet)
    this.tooltips = this.input.filter((t2) => t2)
    let prev = null
    this.tooltipViews = this.tooltips.map((t2) => (prev = createTooltipView(t2, prev)))
  }
  update(update, above) {
    var _a2
    let input = update.state.facet(this.facet)
    let tooltips = input.filter((x2) => x2)
    if (input === this.input) {
      for (let t2 of this.tooltipViews) if (t2.update) t2.update(update)
      return false
    }
    let tooltipViews = [],
      newAbove = above ? [] : null
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i],
        known = -1
      if (!tip) continue
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2]
        if (other && other.create == tip.create) known = i2
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null)
        if (newAbove) newAbove[i] = !!tip.above
      } else {
        let tooltipView = (tooltipViews[i] = this.tooltipViews[known])
        if (newAbove) newAbove[i] = above[known]
        if (tooltipView.update) tooltipView.update(update)
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0) {
        this.removeTooltipView(t2)
        ;(_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2)
      }
    if (above) {
      newAbove.forEach((val, i) => (above[i] = val))
      above.length = newAbove.length
    }
    this.input = input
    this.tooltips = tooltips
    this.tooltipViews = tooltipViews
    return true
  }
}
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth }
}
const tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    var _a2, _b, _c
    return {
      position: browser.ios
        ? 'absolute'
        : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0
            ? void 0
            : _a2.position) || 'fixed',
      parent:
        ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0
          ? void 0
          : _b.parent) || null,
      tooltipSpace:
        ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0
          ? void 0
          : _c.tooltipSpace) || windowSpace
    }
  }
})
const knownHeight = /* @__PURE__ */ new WeakMap()
const tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.view = view
      this.above = []
      this.inView = true
      this.madeAbsolute = false
      this.lastTransaction = 0
      this.measureTimeout = -1
      let config2 = view.state.facet(tooltipConfig)
      this.position = config2.position
      this.parent = config2.parent
      this.classes = view.themeClasses
      this.createContainer()
      this.measureReq = {
        read: this.readMeasure.bind(this),
        write: this.writeMeasure.bind(this),
        key: this
      }
      this.resizeObserver =
        typeof ResizeObserver == 'function' ? new ResizeObserver(() => this.measureSoon()) : null
      this.manager = new TooltipViewManager(
        view,
        showTooltip,
        (t2, p) => this.createTooltip(t2, p),
        (t2) => {
          if (this.resizeObserver) this.resizeObserver.unobserve(t2.dom)
          t2.dom.remove()
        }
      )
      this.above = this.manager.tooltips.map((t2) => !!t2.above)
      this.intersectionObserver =
        typeof IntersectionObserver == 'function'
          ? new IntersectionObserver(
              (entries) => {
                if (
                  Date.now() > this.lastTransaction - 50 &&
                  entries.length > 0 &&
                  entries[entries.length - 1].intersectionRatio < 1
                )
                  this.measureSoon()
              },
              { threshold: [1] }
            )
          : null
      this.observeIntersection()
      view.win.addEventListener('resize', (this.measureSoon = this.measureSoon.bind(this)))
      this.maybeMeasure()
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement('div')
        this.container.style.position = 'relative'
        this.container.className = this.view.themeClasses
        this.parent.appendChild(this.container)
      } else {
        this.container = this.view.dom
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect()
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom)
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1
          this.maybeMeasure()
        }, 50)
    }
    update(update) {
      if (update.transactions.length) this.lastTransaction = Date.now()
      let updated = this.manager.update(update, this.above)
      if (updated) this.observeIntersection()
      let shouldMeasure = updated || update.geometryChanged
      let newConfig = update.state.facet(tooltipConfig)
      if (newConfig.position != this.position && !this.madeAbsolute) {
        this.position = newConfig.position
        for (let t2 of this.manager.tooltipViews) t2.dom.style.position = this.position
        shouldMeasure = true
      }
      if (newConfig.parent != this.parent) {
        if (this.parent) this.container.remove()
        this.parent = newConfig.parent
        this.createContainer()
        for (let t2 of this.manager.tooltipViews) this.container.appendChild(t2.dom)
        shouldMeasure = true
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses
      }
      if (shouldMeasure) this.maybeMeasure()
    }
    createTooltip(tooltip, prev) {
      let tooltipView = tooltip.create(this.view)
      let before = prev ? prev.dom : null
      tooltipView.dom.classList.add('cm-tooltip')
      if (tooltip.arrow && !tooltipView.dom.querySelector('.cm-tooltip > .cm-tooltip-arrow')) {
        let arrow = document.createElement('div')
        arrow.className = 'cm-tooltip-arrow'
        tooltipView.dom.appendChild(arrow)
      }
      tooltipView.dom.style.position = this.position
      tooltipView.dom.style.top = Outside
      tooltipView.dom.style.left = '0px'
      this.container.insertBefore(tooltipView.dom, before)
      if (tooltipView.mount) tooltipView.mount(this.view)
      if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom)
      return tooltipView
    }
    destroy() {
      var _a2, _b, _c
      this.view.win.removeEventListener('resize', this.measureSoon)
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove()
        ;(_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView)
      }
      if (this.parent) this.container.remove()
      ;(_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect()
      ;(_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect()
      clearTimeout(this.measureTimeout)
    }
    readMeasure() {
      let scaleX = 1,
        scaleY = 1,
        makeAbsolute = false
      if (this.position == 'fixed' && this.manager.tooltipViews.length) {
        let { dom } = this.manager.tooltipViews[0]
        if (browser.gecko) {
          makeAbsolute = dom.offsetParent != this.container.ownerDocument.body
        } else if (dom.style.top == Outside && dom.style.left == '0px') {
          let rect = dom.getBoundingClientRect()
          makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1
        }
      }
      if (makeAbsolute || this.position == 'absolute') {
        if (this.parent) {
          let rect = this.parent.getBoundingClientRect()
          if (rect.width && rect.height) {
            scaleX = rect.width / this.parent.offsetWidth
            scaleY = rect.height / this.parent.offsetHeight
          }
        } else {
          ;({ scaleX, scaleY } = this.view.viewState)
        }
      }
      let visible = this.view.scrollDOM.getBoundingClientRect(),
        margins = getScrollMargins(this.view)
      return {
        visible: {
          left: visible.left + margins.left,
          top: visible.top + margins.top,
          right: visible.right - margins.right,
          bottom: visible.bottom - margins.bottom
        },
        parent: this.parent
          ? this.container.getBoundingClientRect()
          : this.view.dom.getBoundingClientRect(),
        pos: this.manager.tooltips.map((t2, i) => {
          let tv = this.manager.tooltipViews[i]
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos)
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        scaleX,
        scaleY,
        makeAbsolute
      }
    }
    writeMeasure(measured) {
      var _a2
      if (measured.makeAbsolute) {
        this.madeAbsolute = true
        this.position = 'absolute'
        for (let t2 of this.manager.tooltipViews) t2.dom.style.position = 'absolute'
      }
      let { visible, space: space2, scaleX, scaleY } = measured
      let others = []
      for (let i = 0; i < this.manager.tooltips.length; i++) {
        let tooltip = this.manager.tooltips[i],
          tView = this.manager.tooltipViews[i],
          { dom } = tView
        let pos = measured.pos[i],
          size = measured.size[i]
        if (
          !pos ||
          (tooltip.clip !== false &&
            (pos.bottom <= Math.max(visible.top, space2.top) ||
              pos.top >= Math.min(visible.bottom, space2.bottom) ||
              pos.right < Math.max(visible.left, space2.left) - 0.1 ||
              pos.left > Math.min(visible.right, space2.right) + 0.1))
        ) {
          dom.style.top = Outside
          continue
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector('.cm-tooltip-arrow') : null
        let arrowHeight = arrow ? 7 : 0
        let width = size.right - size.left,
          height =
            (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top
        let offset = tView.offset || noOffset,
          ltr = this.view.textDirection == Direction.LTR
        let left =
          size.width > space2.right - space2.left
            ? ltr
              ? space2.left
              : space2.right - size.width
            : ltr
              ? Math.max(
                  space2.left,
                  Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width)
                )
              : Math.min(
                  Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset.x),
                  space2.right - width
                )
        let above = this.above[i]
        if (
          !tooltip.strictSide &&
          (above
            ? pos.top - height - arrowHeight - offset.y < space2.top
            : pos.bottom + height + arrowHeight + offset.y > space2.bottom) &&
          above == space2.bottom - pos.bottom > pos.top - space2.top
        )
          above = this.above[i] = !above
        let spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight
        if (spaceVert < height && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside
            continue
          }
          knownHeight.set(tView, height)
          dom.style.height = (height = spaceVert) / scaleY + 'px'
        } else if (dom.style.height) {
          dom.style.height = ''
        }
        let top2 = above
          ? pos.top - height - arrowHeight - offset.y
          : pos.bottom + arrowHeight + offset.y
        let right = left + width
        if (tView.overlap !== true) {
          for (let r2 of others)
            if (r2.left < right && r2.right > left && r2.top < top2 + height && r2.bottom > top2)
              top2 = above ? r2.top - height - 2 - arrowHeight : r2.bottom + arrowHeight + 2
        }
        if (this.position == 'absolute') {
          dom.style.top = (top2 - measured.parent.top) / scaleY + 'px'
          setLeftStyle(dom, (left - measured.parent.left) / scaleX)
        } else {
          dom.style.top = top2 / scaleY + 'px'
          setLeftStyle(dom, left / scaleX)
        }
        if (arrow) {
          let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)
          arrow.style.left = arrowLeft / scaleX + 'px'
        }
        if (tView.overlap !== true) others.push({ left, top: top2, right, bottom: top2 + height })
        dom.classList.toggle('cm-tooltip-above', above)
        dom.classList.toggle('cm-tooltip-below', !above)
        if (tView.positioned) tView.positioned(measured.space)
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView) this.view.requestMeasure(this.measureReq)
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView
          if (!this.inView) for (let tv of this.manager.tooltipViews) tv.dom.style.top = Outside
        }
      }
    }
  },
  {
    eventObservers: {
      scroll() {
        this.maybeMeasure()
      }
    }
  }
)
function setLeftStyle(elt2, value) {
  let current = parseInt(elt2.style.left, 10)
  if (isNaN(current) || Math.abs(value - current) > 1) elt2.style.left = value + 'px'
}
const baseTheme$3 = /* @__PURE__ */ EditorView.baseTheme({
  '.cm-tooltip': {
    zIndex: 500,
    boxSizing: 'border-box'
  },
  '&light .cm-tooltip': {
    border: '1px solid #bbb',
    backgroundColor: '#f5f5f5'
  },
  '&light .cm-tooltip-section:not(:first-child)': {
    borderTop: '1px solid #bbb'
  },
  '&dark .cm-tooltip': {
    backgroundColor: '#333338',
    color: 'white'
  },
  '.cm-tooltip-arrow': {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: 'absolute',
    zIndex: -1,
    overflow: 'hidden',
    '&:before, &:after': {
      content: "''",
      position: 'absolute',
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    '.cm-tooltip-above &': {
      bottom: `-${7}px`,
      '&:before': {
        borderTop: `${7}px solid #bbb`
      },
      '&:after': {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: '1px'
      }
    },
    '.cm-tooltip-below &': {
      top: `-${7}px`,
      '&:before': {
        borderBottom: `${7}px solid #bbb`
      },
      '&:after': {
        borderBottom: `${7}px solid #f5f5f5`,
        top: '1px'
      }
    }
  },
  '&dark .cm-tooltip .cm-tooltip-arrow': {
    '&:before': {
      borderTopColor: '#333338',
      borderBottomColor: '#333338'
    },
    '&:after': {
      borderTopColor: 'transparent',
      borderBottomColor: 'transparent'
    }
  }
})
const noOffset = { x: 0, y: 0 }
const showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme$3]
})
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin)
  if (!plugin) return null
  let found = plugin.manager.tooltips.indexOf(tooltip)
  return found < 0 ? null : plugin.manager.tooltipViews[found]
}
const panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer
    for (let c of configs) {
      topContainer = topContainer || c.topContainer
      bottomContainer = bottomContainer || c.bottomContainer
    }
    return { topContainer, bottomContainer }
  }
})
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin)
  let index2 = plugin ? plugin.specs.indexOf(panel) : -1
  return index2 > -1 ? plugin.panels[index2] : null
}
const panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.input = view.state.facet(showPanel)
      this.specs = this.input.filter((s) => s)
      this.panels = this.specs.map((spec) => spec(view))
      let conf = view.state.facet(panelConfig)
      this.top = new PanelGroup(view, true, conf.topContainer)
      this.bottom = new PanelGroup(view, false, conf.bottomContainer)
      this.top.sync(this.panels.filter((p) => p.top))
      this.bottom.sync(this.panels.filter((p) => !p.top))
      for (let p of this.panels) {
        p.dom.classList.add('cm-panel')
        if (p.mount) p.mount()
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig)
      if (this.top.container != conf.topContainer) {
        this.top.sync([])
        this.top = new PanelGroup(update.view, true, conf.topContainer)
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([])
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer)
      }
      this.top.syncClasses()
      this.bottom.syncClasses()
      let input = update.state.facet(showPanel)
      if (input != this.input) {
        let specs = input.filter((x2) => x2)
        let panels = [],
          top2 = [],
          bottom = [],
          mount = []
        for (let spec of specs) {
          let known = this.specs.indexOf(spec),
            panel
          if (known < 0) {
            panel = spec(update.view)
            mount.push(panel)
          } else {
            panel = this.panels[known]
            if (panel.update) panel.update(update)
          }
          panels.push(panel)
          ;(panel.top ? top2 : bottom).push(panel)
        }
        this.specs = specs
        this.panels = panels
        this.top.sync(top2)
        this.bottom.sync(bottom)
        for (let p of mount) {
          p.dom.classList.add('cm-panel')
          if (p.mount) p.mount()
        }
      } else {
        for (let p of this.panels) if (p.update) p.update(update)
      }
    }
    destroy() {
      this.top.sync([])
      this.bottom.sync([])
    }
  },
  {
    provide: (plugin) =>
      EditorView.scrollMargins.of((view) => {
        let value = view.plugin(plugin)
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }
      })
  }
)
class PanelGroup {
  constructor(view, top2, container) {
    this.view = view
    this.top = top2
    this.container = container
    this.dom = void 0
    this.classes = ''
    this.panels = []
    this.syncClasses()
  }
  sync(panels) {
    for (let p of this.panels) if (p.destroy && panels.indexOf(p) < 0) p.destroy()
    this.panels = panels
    this.syncDOM()
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove()
        this.dom = void 0
      }
      return
    }
    if (!this.dom) {
      this.dom = document.createElement('div')
      this.dom.className = this.top ? 'cm-panels cm-panels-top' : 'cm-panels cm-panels-bottom'
      this.dom.style[this.top ? 'top' : 'bottom'] = '0'
      let parent = this.container || this.view.dom
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null)
    }
    let curDOM = this.dom.firstChild
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom) curDOM = rm(curDOM)
        curDOM = curDOM.nextSibling
      } else {
        this.dom.insertBefore(panel.dom, curDOM)
      }
    }
    while (curDOM) curDOM = rm(curDOM)
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom -
                Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) -
                this.dom.getBoundingClientRect().top
        )
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses) return
    for (let cls of this.classes.split(' ')) if (cls) this.container.classList.remove(cls)
    for (let cls of (this.classes = this.view.themeClasses).split(' '))
      if (cls) this.container.classList.add(cls)
  }
}
function rm(node) {
  let next = node.nextSibling
  node.remove()
  return next
}
const showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
})
class GutterMarker extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || (this.constructor == other.constructor && this.eq(other))
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {}
}
GutterMarker.prototype.elementClass = ''
GutterMarker.prototype.toDOM = void 0
GutterMarker.prototype.mapMode = MapMode.TrackBefore
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1
GutterMarker.prototype.point = true
const DefaultBufferLength = 1024
let nextPropID = 0
class Range2 {
  constructor(from, to) {
    this.from = from
    this.to = to
  }
}
class NodeProp {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++
    this.perNode = !!config2.perNode
    this.deserialize =
      config2.deserialize ||
      (() => {
        throw new Error("This node type doesn't define a deserialize function")
      })
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match2) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types")
    if (typeof match2 != 'function') match2 = NodeType.match(match2)
    return (type) => {
      let result = match2(type)
      return result === void 0 ? null : [this, result]
    }
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(' ') })
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(' ') })
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(' ') })
NodeProp.isolate = new NodeProp({
  deserialize: (value) => {
    if (value && value != 'rtl' && value != 'ltr' && value != 'auto')
      throw new RangeError('Invalid value for isolate: ' + value)
    return value || 'auto'
  }
})
NodeProp.contextHash = new NodeProp({ perNode: true })
NodeProp.lookAhead = new NodeProp({ perNode: true })
NodeProp.mounted = new NodeProp({ perNode: true })
class MountedTree {
  constructor(tree, overlay, parser2) {
    this.tree = tree
    this.overlay = overlay
    this.parser = parser2
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id]
  }
}
const noProps = /* @__PURE__ */ Object.create(null)
class NodeType {
  /**
  @internal
  */
  constructor(name2, props2, id2, flags = 0) {
    this.name = name2
    this.props = props2
    this.id = id2
    this.flags = flags
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props2 = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps
    let flags =
      (spec.top ? 1 : 0) |
      (spec.skipped ? 2 : 0) |
      (spec.error ? 4 : 0) |
      (spec.name == null ? 8 : 0)
    let type = new NodeType(spec.name || '', props2, spec.id, flags)
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src)) src = src(type)
        if (src) {
          if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type")
          props2[src[0].id] = src[1]
        }
      }
    return type
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id]
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == 'string') {
      if (this.name == name2) return true
      let group = this.prop(NodeProp.group)
      return group ? group.indexOf(name2) > -1 : false
    }
    return this.id == name2
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map2) {
    let direct = /* @__PURE__ */ Object.create(null)
    for (let prop in map2) for (let name2 of prop.split(' ')) direct[name2] = map2[prop]
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]]
        if (found) return found
      }
    }
  }
}
NodeType.none = new NodeType(
  '',
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
)
class NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError(
          'Node type ids should correspond to array positions when creating a node set'
        )
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props2) {
    let newTypes = []
    for (let type of this.types) {
      let newProps = null
      for (let source of props2) {
        let add3 = source(type)
        if (add3) {
          if (!newProps) newProps = Object.assign({}, type.props)
          newProps[add3[0].id] = add3[1]
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)
    }
    return new NodeSet(newTypes)
  }
}
const CachedNode = /* @__PURE__ */ new WeakMap(),
  CachedInnerNode = /* @__PURE__ */ new WeakMap()
var IterMode
;(function (IterMode2) {
  IterMode2[(IterMode2['ExcludeBuffers'] = 1)] = 'ExcludeBuffers'
  IterMode2[(IterMode2['IncludeAnonymous'] = 2)] = 'IncludeAnonymous'
  IterMode2[(IterMode2['IgnoreMounts'] = 4)] = 'IgnoreMounts'
  IterMode2[(IterMode2['IgnoreOverlays'] = 8)] = 'IgnoreOverlays'
})(IterMode || (IterMode = {}))
class Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props2) {
    this.type = type
    this.children = children
    this.positions = positions
    this.length = length
    this.props = null
    if (props2 && props2.length) {
      this.props = /* @__PURE__ */ Object.create(null)
      for (let [prop, value] of props2) this.props[typeof prop == 'number' ? prop : prop.id] = value
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this)
    if (mounted && !mounted.overlay) return mounted.tree.toString()
    let children = ''
    for (let ch of this.children) {
      let str = ch.toString()
      if (str) {
        if (children) children += ','
        children += str
      }
    }
    return !this.type.name
      ? children
      : (/\W/.test(this.type.name) && !this.type.isError
          ? JSON.stringify(this.type.name)
          : this.type.name) + (children.length ? '(' + children + ')' : '')
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode)
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode
    let cursor2 = new TreeCursor(scope)
    cursor2.moveTo(pos, side)
    CachedNode.set(this, cursor2._tree)
    return cursor2
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null)
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false)
    CachedNode.set(this, node)
    return node
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true)
    CachedInnerNode.set(this, node)
    return node
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side)
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec
    let mode = spec.mode || 0,
      anon = (mode & IterMode.IncludeAnonymous) > 0
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false
      if (c.from <= to && c.to >= from && ((!anon && c.type.isAnonymous) || enter(c) !== false)) {
        if (c.firstChild()) continue
        entered = true
      }
      for (;;) {
        if (entered && leave && (anon || !c.type.isAnonymous)) leave(c)
        if (c.nextSibling()) break
        if (!c.parent()) return
        entered = true
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = []
    if (this.props) for (let id2 in this.props) result.push([+id2, this.props[id2]])
    return result
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8
      ? this
      : balanceRange(
          NodeType.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (children, positions, length) =>
            new Tree(this.type, children, positions, length, this.propValues),
          config2.makeTree ||
            ((children, positions, length) => new Tree(NodeType.none, children, positions, length))
        )
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data2) {
    return buildTree(data2)
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0)
class FlatBufferCursor {
  constructor(buffer, index2) {
    this.buffer = buffer
    this.index = index2
  }
  get id() {
    return this.buffer[this.index - 4]
  }
  get start() {
    return this.buffer[this.index - 3]
  }
  get end() {
    return this.buffer[this.index - 2]
  }
  get size() {
    return this.buffer[this.index - 1]
  }
  get pos() {
    return this.index
  }
  next() {
    this.index -= 4
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index)
  }
}
class TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set2) {
    this.buffer = buffer
    this.length = length
    this.set = set2
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none
  }
  /**
  @internal
  */
  toString() {
    let result = []
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2))
      index2 = this.buffer[index2 + 3]
    }
    return result.join(',')
  }
  /**
  @internal
  */
  childString(index2) {
    let id2 = this.buffer[index2],
      endIndex = this.buffer[index2 + 3]
    let type = this.set.types[id2],
      result = type.name
    if (/\W/.test(result) && !type.isError) result = JSON.stringify(result)
    index2 += 4
    if (endIndex == index2) return result
    let children = []
    while (index2 < endIndex) {
      children.push(this.childString(index2))
      index2 = this.buffer[index2 + 3]
    }
    return result + '(' + children.join(',') + ')'
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this,
      pick = -1
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i
        if (dir > 0) break
      }
    }
    return pick
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer
    let copy = new Uint16Array(endI - startI),
      len = 0
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++]
      copy[j++] = b[i++] - from
      let to = (copy[j++] = b[i++] - from)
      copy[j++] = b[i++] - startI
      len = Math.max(len, to)
    }
    return new TreeBuffer(copy, len, this.set)
  }
}
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos
    case -1:
      return to >= pos && from < pos
    case 0:
      return from < pos && to > pos
    case 1:
      return from <= pos && to > pos
    case 2:
      return to > pos
    case 4:
      return true
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a2
  while (
    node.from == node.to ||
    (side < 1 ? node.from >= pos : node.from > pos) ||
    (side > -1 ? node.to <= pos : node.to < pos)
  ) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent
    if (!parent) return node
    node = parent
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (
        scan instanceof TreeNode &&
        scan.index < 0 &&
        ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) !=
          scan.from
      )
        node = parent
    }
  for (;;) {
    let inner = node.enter(pos, side, mode)
    if (!inner) return node
    node = inner
  }
}
class BaseNode {
  cursor(mode = 0) {
    return new TreeCursor(this, mode)
  }
  getChild(type, before = null, after = null) {
    let r2 = getChildren(this, type, before, after)
    return r2.length ? r2[0] : null
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after)
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false)
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true)
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context)
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos),
      node = this
    while (scan) {
      let last = scan.lastChild
      if (!last || last.to != scan.to) break
      if (last.type.isError && last.from == last.to) {
        node = scan
        scan = last.prevSibling
      } else {
        scan = last
      }
    }
    return node
  }
  get node() {
    return this
  }
  get next() {
    return this.parent
  }
}
class TreeNode extends BaseNode {
  constructor(_tree, from, index2, _parent) {
    super()
    this._tree = _tree
    this.from = from
    this.index = index2
    this._parent = _parent
  }
  get type() {
    return this._tree.type
  }
  get name() {
    return this._tree.type.name
  }
  get to() {
    return this.from + this._tree.length
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (
        let { children, positions } = parent._tree, e2 = dir > 0 ? children.length : -1;
        i != e2;
        i += dir
      ) {
        let next = children[i],
          start = positions[i] + parent.from
        if (!checkSide(side, pos, start, start + next.length)) continue
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers) continue
          let index2 = next.findChild(0, next.buffer.length, dir, pos - start, side)
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index2)
        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
          let mounted
          if (
            !(mode & IterMode.IgnoreMounts) &&
            (mounted = MountedTree.get(next)) &&
            !mounted.overlay
          )
            return new TreeNode(mounted.tree, start, i, parent)
          let inner = new TreeNode(next, start, i, parent)
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous
            ? inner
            : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side)
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null
      if (parent.index >= 0) i = parent.index + dir
      else i = dir < 0 ? -1 : parent._parent._tree.children.length
      parent = parent._parent
      if (!parent) return null
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    )
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    )
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    )
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    )
  }
  enter(pos, side, mode = 0) {
    let mounted
    if (
      !(mode & IterMode.IgnoreOverlays) &&
      (mounted = MountedTree.get(this._tree)) &&
      mounted.overlay
    ) {
      let rPos = pos - this.from
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this)
      }
    }
    return this.nextChild(0, 1, pos, side, mode)
  }
  nextSignificantParent() {
    let val = this
    while (val.type.isAnonymous && val._parent) val = val._parent
    return val
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null
  }
  get nextSibling() {
    return this._parent && this.index >= 0
      ? this._parent.nextChild(
          this.index + 1,
          1,
          0,
          4
          /* Side.DontCare */
        )
      : null
  }
  get prevSibling() {
    return this._parent && this.index >= 0
      ? this._parent.nextChild(
          this.index - 1,
          -1,
          0,
          4
          /* Side.DontCare */
        )
      : null
  }
  get tree() {
    return this._tree
  }
  toTree() {
    return this._tree
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString()
  }
}
function getChildren(node, type, before, after) {
  let cur2 = node.cursor(),
    result = []
  if (!cur2.firstChild()) return result
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before)
      if (!cur2.nextSibling()) return result
    }
  for (;;) {
    if (after != null && cur2.type.is(after)) return result
    if (cur2.type.is(type)) result.push(cur2.node)
    if (!cur2.nextSibling()) return after == null ? result : []
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p) return false
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name) return false
      i--
    }
  }
  return true
}
class BufferContext {
  constructor(parent, buffer, index2, start) {
    this.parent = parent
    this.buffer = buffer
    this.index = index2
    this.start = start
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1]
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2]
  }
  constructor(context, _parent, index2) {
    super()
    this.context = context
    this._parent = _parent
    this.index = index2
    this.type = context.buffer.set.types[context.buffer.buffer[index2]]
  }
  child(dir, pos, side) {
    let { buffer } = this.context
    let index2 = buffer.findChild(
      this.index + 4,
      buffer.buffer[this.index + 3],
      dir,
      pos - this.context.start,
      side
    )
    return index2 < 0 ? null : new BufferNode(this.context, this, index2)
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    )
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    )
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    )
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    )
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers) return null
    let { buffer } = this.context
    let index2 = buffer.findChild(
      this.index + 4,
      buffer.buffer[this.index + 3],
      side > 0 ? 1 : -1,
      pos - this.context.start,
      side
    )
    return index2 < 0 ? null : new BufferNode(this.context, this, index2)
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent()
  }
  externalSibling(dir) {
    return this._parent
      ? null
      : this.context.parent.nextChild(
          this.context.index + dir,
          dir,
          0,
          4
          /* Side.DontCare */
        )
  }
  get nextSibling() {
    let { buffer } = this.context
    let after = buffer.buffer[this.index + 3]
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after)
    return this.externalSibling(1)
  }
  get prevSibling() {
    let { buffer } = this.context
    let parentStart = this._parent ? this._parent.index + 4 : 0
    if (this.index == parentStart) return this.externalSibling(-1)
    return new BufferNode(
      this.context,
      this._parent,
      buffer.findChild(
        parentStart,
        this.index,
        -1,
        0,
        4
        /* Side.DontCare */
      )
    )
  }
  get tree() {
    return null
  }
  toTree() {
    let children = [],
      positions = []
    let { buffer } = this.context
    let startI = this.index + 4,
      endI = buffer.buffer[this.index + 3]
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1]
      children.push(buffer.slice(startI, endI, from))
      positions.push(0)
    }
    return new Tree(this.type, children, positions, this.to - this.from)
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index)
  }
}
function iterStack(heads) {
  if (!heads.length) return null
  let pick = 0,
    picked = heads[0]
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i]
    if (node.from > picked.from || node.to < picked.to) {
      picked = node
      pick = i
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent
  let newHeads = heads.slice()
  if (next) newHeads[pick] = next
  else newHeads.splice(pick, 1)
  return new StackIterator(newHeads, picked)
}
class StackIterator {
  constructor(heads, node) {
    this.heads = heads
    this.node = node
  }
  get next() {
    return iterStack(this.heads)
  }
}
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side),
    layers = null
  for (
    let scan = inner instanceof TreeNode ? inner : inner.context.parent;
    scan;
    scan = scan.parent
  ) {
    if (scan.index < 0) {
      let parent = scan.parent
      ;(layers || (layers = [inner])).push(parent.resolve(pos, side))
      scan = parent
    } else {
      let mount = MountedTree.get(scan.tree)
      if (
        mount &&
        mount.overlay &&
        mount.overlay[0].from <= pos &&
        mount.overlay[mount.overlay.length - 1].to >= pos
      ) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan)
        ;(layers || (layers = [inner])).push(resolveNode(root, pos, side, false))
      }
    }
  }
  return layers ? iterStack(layers) : inner
}
class TreeCursor {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode
    this.buffer = null
    this.stack = []
    this.index = 0
    this.bufferNode = null
    if (node instanceof TreeNode) {
      this.yieldNode(node)
    } else {
      this._tree = node.context.parent
      this.buffer = node.context
      for (let n2 = node._parent; n2; n2 = n2._parent) this.stack.unshift(n2.index)
      this.bufferNode = node
      this.yieldBuf(node.index)
    }
  }
  yieldNode(node) {
    if (!node) return false
    this._tree = node
    this.type = node.type
    this.from = node.from
    this.to = node.to
    return true
  }
  yieldBuf(index2, type) {
    this.index = index2
    let { start, buffer } = this.buffer
    this.type = type || buffer.set.types[buffer.buffer[index2]]
    this.from = start + buffer.buffer[index2 + 1]
    this.to = start + buffer.buffer[index2 + 2]
    return true
  }
  /**
  @internal
  */
  yield(node) {
    if (!node) return false
    if (node instanceof TreeNode) {
      this.buffer = null
      return this.yieldNode(node)
    }
    this.buffer = node.context
    return this.yieldBuf(node.index, node.type)
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(
        this._tree.nextChild(
          dir < 0 ? this._tree._tree.children.length - 1 : 0,
          dir,
          pos,
          side,
          this.mode
        )
      )
    let { buffer } = this.buffer
    let index2 = buffer.findChild(
      this.index + 4,
      buffer.buffer[this.index + 3],
      dir,
      pos - this.buffer.start,
      side
    )
    if (index2 < 0) return false
    this.stack.push(this.index)
    return this.yieldBuf(index2)
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    )
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    )
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    )
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    )
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode))
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side)
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(
        this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent
      )
    if (this.stack.length) return this.yieldBuf(this.stack.pop())
    let parent =
      this.mode & IterMode.IncludeAnonymous
        ? this.buffer.parent
        : this.buffer.parent.nextSignificantParent()
    this.buffer = null
    return this.yieldNode(parent)
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent
        ? false
        : this.yield(
            this._tree.index < 0
              ? null
              : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode)
          )
    let { buffer } = this.buffer,
      d = this.stack.length - 1
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4
      if (this.index != parentStart)
        return this.yieldBuf(
          buffer.findChild(
            parentStart,
            this.index,
            -1,
            0,
            4
            /* Side.DontCare */
          )
        )
    } else {
      let after = buffer.buffer[this.index + 3]
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after)
    }
    return d < 0
      ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode))
      : false
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1)
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1)
  }
  atLastNode(dir) {
    let index2,
      parent,
      { buffer } = this
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length) return false
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index) return false
      }
      ;({ index: index2, parent } = buffer)
    } else {
      ;({ index: index2, _parent: parent } = this._tree)
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (
          let i = index2 + dir, e2 = dir < 0 ? -1 : parent._tree.children.length;
          i != e2;
          i += dir
        ) {
          let child = parent._tree.children[i]
          if (
            this.mode & IterMode.IncludeAnonymous ||
            child instanceof TreeBuffer ||
            !child.type.isAnonymous ||
            hasChild(child)
          )
            return false
        }
    }
    return true
  }
  move(dir, enter) {
    if (
      enter &&
      this.enterChild(
        dir,
        0,
        4
        /* Side.DontCare */
      )
    )
      return true
    for (;;) {
      if (this.sibling(dir)) return true
      if (this.atLastNode(dir) || !this.parent()) return false
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter)
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter)
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (
      this.from == this.to ||
      (side < 1 ? this.from >= pos : this.from > pos) ||
      (side > -1 ? this.to <= pos : this.to < pos)
    )
      if (!this.parent()) break
    while (this.enterChild(1, pos, side)) {}
    return this
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer) return this._tree
    let cache2 = this.bufferNode,
      result = null,
      depth = 0
    if (cache2 && cache2.context == this.buffer) {
      scan: for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache2; c; c = c._parent)
          if (c.index == index2) {
            if (index2 == this.index) return c
            result = c
            depth = d + 1
            break scan
          }
        index2 = this.stack[--d]
      }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i])
    return (this.bufferNode = new BufferNode(this.buffer, result, this.index))
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++
          continue
        }
        if (!this.type.isAnonymous) mustLeave = true
      }
      for (;;) {
        if (mustLeave && leave) leave(this)
        mustLeave = this.type.isAnonymous
        if (!depth) return
        if (this.nextSibling()) break
        this.parent()
        depth--
        mustLeave = true
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer) return matchNodeContext(this.node.parent, context)
    let { buffer } = this.buffer,
      { types: types2 } = buffer.set
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0) return matchNodeContext(this._tree, context, i)
      let type = types2[buffer.buffer[this.stack[d]]]
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name) return false
        i--
      }
    }
    return true
  }
}
function hasChild(tree) {
  return tree.children.some(
    (ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch)
  )
}
function buildTree(data2) {
  var _a2
  let {
    buffer,
    nodeSet: nodeSet2,
    maxBufferLength = DefaultBufferLength,
    reused = [],
    minRepeatType = nodeSet2.types.length
  } = data2
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer
  let types2 = nodeSet2.types
  let contextHash = 0,
    lookAhead = 0
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor2
    let lookAheadAtStart = lookAhead,
      contextAtStart = contextHash
    while (size < 0) {
      cursor2.next()
      if (size == -1) {
        let node2 = reused[id2]
        children2.push(node2)
        positions2.push(start - parentStart)
        return
      } else if (size == -3) {
        contextHash = id2
        return
      } else if (size == -4) {
        lookAhead = id2
        return
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`)
      }
    }
    let type = types2[id2],
      node,
      buffer2
    let startPos = start - parentStart
    if (
      end - start <= maxBufferLength &&
      (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))
    ) {
      let data3 = new Uint16Array(buffer2.size - buffer2.skip)
      let endPos = cursor2.pos - buffer2.size,
        index2 = data3.length
      while (cursor2.pos > endPos) index2 = copyToBuffer(buffer2.start, data3, index2)
      node = new TreeBuffer(data3, end - buffer2.start, nodeSet2)
      startPos = buffer2.start - parentStart
    } else {
      let endPos = cursor2.pos - size
      cursor2.next()
      let localChildren = [],
        localPositions = []
      let localInRepeat = id2 >= minRepeatType ? id2 : -1
      let lastGroup = 0,
        lastEnd = end
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(
              localChildren,
              localPositions,
              start,
              lastGroup,
              cursor2.end,
              lastEnd,
              localInRepeat,
              lookAheadAtStart,
              contextAtStart
            )
            lastGroup = localChildren.length
            lastEnd = cursor2.end
          }
          cursor2.next()
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions)
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1)
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(
          localChildren,
          localPositions,
          start,
          lastGroup,
          start,
          lastEnd,
          localInRepeat,
          lookAheadAtStart,
          contextAtStart
        )
      localChildren.reverse()
      localPositions.reverse()
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart)
        node = balanceRange(
          type,
          localChildren,
          localPositions,
          0,
          localChildren.length,
          0,
          end - start,
          make,
          make
        )
      } else {
        node = makeTree(
          type,
          localChildren,
          localPositions,
          end - start,
          lookAheadAtStart - end,
          contextAtStart
        )
      }
    }
    children2.push(node)
    positions2.push(startPos)
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = []
    let nodeCount = 0,
      stopAt = -1
    while (cursor2.pos > minPos) {
      let { id: id2, start, end, size } = cursor2
      if (size > 4) {
        cursor2.next()
      } else if (stopAt > -1 && start < stopAt) {
        break
      } else {
        if (stopAt < 0) stopAt = end - maxBufferLength
        nodes.push(id2, start, end)
        nodeCount++
        cursor2.next()
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4)
      let start = nodes[nodes.length - 2]
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i]
        buffer2[j++] = nodes[i + 1] - start
        buffer2[j++] = nodes[i + 2] - start
        buffer2[j++] = j
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet2))
      positions2.push(start - parentStart)
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0,
        lastI = children2.length - 1,
        last,
        lookAheadProp
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2) return last
        if ((lookAheadProp = last.prop(NodeProp.lookAhead)))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2)
    }
  }
  function makeRepeatLeaf(
    children2,
    positions2,
    base2,
    i,
    from,
    to,
    type,
    lookAhead2,
    contextHash2
  ) {
    let localChildren = [],
      localPositions = []
    while (children2.length > i) {
      localChildren.push(children2.pop())
      localPositions.push(positions2.pop() + base2 - from)
    }
    children2.push(
      makeTree(
        nodeSet2.types[type],
        localChildren,
        localPositions,
        to - from,
        lookAhead2 - to,
        contextHash2
      )
    )
    positions2.push(from - base2)
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props2) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2]
      props2 = props2 ? [pair2].concat(props2) : [pair2]
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2]
      props2 = props2 ? [pair2].concat(props2) : [pair2]
    }
    return new Tree(type, children2, positions2, length2, props2)
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork()
    let size = 0,
      start = 0,
      skip = 0,
      minStart = fork.end - maxBufferLength
    let result = { size: 0, start: 0, skip: 0 }
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size
        result.start = start
        result.skip = skip
        skip += 4
        size += 4
        fork.next()
        continue
      }
      let startPos = fork.pos - nodeSize2
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart) break
      let localSkipped = fork.id >= minRepeatType ? 4 : 0
      let nodeStart = fork.start
      fork.next()
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3) localSkipped += 4
          else break scan
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4
        }
        fork.next()
      }
      start = nodeStart
      size += nodeSize2
      skip += localSkipped
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size
      result.start = start
      result.skip = skip
    }
    return result.size > 4 ? result : void 0
  }
  function copyToBuffer(bufferStart, buffer2, index2) {
    let { id: id2, start, end, size } = cursor2
    cursor2.next()
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index2
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4)
        while (cursor2.pos > endPos) index2 = copyToBuffer(bufferStart, buffer2, index2)
      }
      buffer2[--index2] = startIndex
      buffer2[--index2] = end - bufferStart
      buffer2[--index2] = start - bufferStart
      buffer2[--index2] = id2
    } else if (size == -3) {
      contextHash = id2
    } else if (size == -4) {
      lookAhead = id2
    }
    return index2
  }
  let children = [],
    positions = []
  while (cursor2.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1, 0)
  let length =
    (_a2 = data2.length) !== null && _a2 !== void 0
      ? _a2
      : children.length
        ? positions[0] + children[0].length
        : 0
  return new Tree(types2[data2.topID], children.reverse(), positions.reverse(), length)
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap()
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1
  let size = nodeSizeCache.get(node)
  if (size == null) {
    size = 1
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1
        break
      }
      size += nodeSize(balanceType, child)
    }
    nodeSizeCache.set(node, size)
  }
  return size
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0
  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i])
  let maxChild = Math.ceil(
    (total * 1.5) / 8
    /* Balance.BranchFactor */
  )
  let localChildren = [],
    localPositions = []
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i,
        groupStart = positions2[i],
        groupSize = nodeSize(balanceType, children2[i])
      i++
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i])
        if (groupSize + nextSize >= maxChild) break
        groupSize += nextSize
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom]
          divide(
            only.children,
            only.positions,
            0,
            only.children.length,
            positions2[groupFrom] + offset
          )
          continue
        }
        localChildren.push(children2[groupFrom])
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart
        localChildren.push(
          balanceRange(
            balanceType,
            children2,
            positions2,
            groupFrom,
            i,
            groupStart,
            length2,
            null,
            mkTree
          )
        )
      }
      localPositions.push(groupStart + offset - start)
    }
  }
  divide(children, positions, from, to, 0)
  return (mkTop || mkTree)(localChildren, localPositions, length)
}
class NodeWeakMap {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap()
  }
  setBuffer(buffer, index2, value) {
    let inner = this.map.get(buffer)
    if (!inner) this.map.set(buffer, (inner = /* @__PURE__ */ new Map()))
    inner.set(index2, value)
  }
  getBuffer(buffer, index2) {
    let inner = this.map.get(buffer)
    return inner && inner.get(index2)
  }
  /**
  Set the value for this syntax node.
  */
  set(node, value) {
    if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value)
    else if (node instanceof TreeNode) this.map.set(node.tree, value)
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(node) {
    return node instanceof BufferNode
      ? this.getBuffer(node.context.buffer, node.index)
      : node instanceof TreeNode
        ? this.map.get(node.tree)
        : void 0
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(cursor2, value) {
    if (cursor2.buffer) this.setBuffer(cursor2.buffer.buffer, cursor2.index, value)
    else this.map.set(cursor2.tree, value)
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(cursor2) {
    return cursor2.buffer
      ? this.getBuffer(cursor2.buffer.buffer, cursor2.index)
      : this.map.get(cursor2.tree)
  }
}
class TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from
    this.to = to
    this.tree = tree
    this.offset = offset
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0)
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)]
    for (let f of fragments) if (f.to > tree.length) result.push(f)
    return result
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length) return fragments
    let result = []
    let fI = 1,
      nextF = fragments.length ? fragments[0] : null
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null
      let nextPos = nextC ? nextC.fromA : 1e9
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off,
              fTo = Math.min(cut.to, nextPos) - off
            cut =
              fFrom >= fTo
                ? null
                : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC)
          }
          if (cut) result.push(cut)
          if (nextF.to > nextPos) break
          nextF = fI < fragments.length ? fragments[fI++] : null
        }
      if (!nextC) break
      pos = nextC.toA
      off = nextC.toA - nextC.toB
    }
    return result
  }
}
class Parser {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == 'string') input = new StringInput(input)
    ranges = !ranges
      ? [new Range2(0, input.length)]
      : ranges.length
        ? ranges.map((r2) => new Range2(r2.from, r2.to))
        : [new Range2(0, 0)]
    return this.createParse(input, fragments || [], ranges)
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges)
    for (;;) {
      let done = parse.advance()
      if (done) return done
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2
  }
  get length() {
    return this.string.length
  }
  chunk(from) {
    return this.string.slice(from)
  }
  get lineChunks() {
    return false
  }
  read(from, to) {
    return this.string.slice(from, to)
  }
}
function parseMixed(nest) {
  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges)
}
class InnerParse {
  constructor(parser2, parse, overlay, target, from) {
    this.parser = parser2
    this.parse = parse
    this.overlay = overlay
    this.target = target
    this.from = from
  }
}
function checkRanges(ranges) {
  if (!ranges.length || ranges.some((r2) => r2.from >= r2.to))
    throw new RangeError('Invalid inner parse ranges given: ' + JSON.stringify(ranges))
}
class ActiveOverlay {
  constructor(parser2, predicate, mounts, index2, start, target, prev) {
    this.parser = parser2
    this.predicate = predicate
    this.mounts = mounts
    this.index = index2
    this.start = start
    this.target = target
    this.prev = prev
    this.depth = 0
    this.ranges = []
  }
}
const stoppedInner = new NodeProp({ perNode: true })
class MixedParse {
  constructor(base2, nest, input, fragments, ranges) {
    this.nest = nest
    this.input = input
    this.fragments = fragments
    this.ranges = ranges
    this.inner = []
    this.innerDone = 0
    this.baseTree = null
    this.stoppedAt = null
    this.baseParse = base2
  }
  advance() {
    if (this.baseParse) {
      let done2 = this.baseParse.advance()
      if (!done2) return null
      this.baseParse = null
      this.baseTree = done2
      this.startInner()
      if (this.stoppedAt != null) for (let inner2 of this.inner) inner2.parse.stopAt(this.stoppedAt)
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree
      if (this.stoppedAt != null)
        result = new Tree(
          result.type,
          result.children,
          result.positions,
          result.length,
          result.propValues.concat([[stoppedInner, this.stoppedAt]])
        )
      return result
    }
    let inner = this.inner[this.innerDone],
      done = inner.parse.advance()
    if (done) {
      this.innerDone++
      let props2 = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props)
      props2[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser)
      inner.target.props = props2
    }
    return null
  }
  get parsedPos() {
    if (this.baseParse) return 0
    let pos = this.input.length
    for (let i = this.innerDone; i < this.inner.length; i++) {
      if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos)
    }
    return pos
  }
  stopAt(pos) {
    this.stoppedAt = pos
    if (this.baseParse) this.baseParse.stopAt(pos)
    else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos)
  }
  startInner() {
    let fragmentCursor = new FragmentCursor$2(this.fragments)
    let overlay = null
    let covered = null
    let cursor2 = new TreeCursor(
      new TreeNode(this.baseTree, this.ranges[0].from, 0, null),
      IterMode.IncludeAnonymous | IterMode.IgnoreMounts
    )
    scan: for (let nest, isCovered; ; ) {
      let enter = true,
        range
      if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
        enter = false
      } else if (fragmentCursor.hasNode(cursor2)) {
        if (overlay) {
          let match2 = overlay.mounts.find(
            (m) => m.frag.from <= cursor2.from && m.frag.to >= cursor2.to && m.mount.overlay
          )
          if (match2)
            for (let r2 of match2.mount.overlay) {
              let from = r2.from + match2.pos,
                to = r2.to + match2.pos
              if (
                from >= cursor2.from &&
                to <= cursor2.to &&
                !overlay.ranges.some((r3) => r3.from < to && r3.to > from)
              )
                overlay.ranges.push({ from, to })
            }
        }
        enter = false
      } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
        enter = isCovered != 2
      } else if (
        !cursor2.type.isAnonymous &&
        (nest = this.nest(cursor2, this.input)) &&
        (cursor2.from < cursor2.to || !nest.overlay)
      ) {
        if (!cursor2.tree) materialize(cursor2)
        let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser)
        if (typeof nest.overlay == 'function') {
          overlay = new ActiveOverlay(
            nest.parser,
            nest.overlay,
            oldMounts,
            this.inner.length,
            cursor2.from,
            cursor2.tree,
            overlay
          )
        } else {
          let ranges = punchRanges(
            this.ranges,
            nest.overlay ||
              (cursor2.from < cursor2.to ? [new Range2(cursor2.from, cursor2.to)] : [])
          )
          if (ranges.length) checkRanges(ranges)
          if (ranges.length || !nest.overlay)
            this.inner.push(
              new InnerParse(
                nest.parser,
                ranges.length
                  ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)
                  : nest.parser.startParse(''),
                nest.overlay
                  ? nest.overlay.map(
                      (r2) => new Range2(r2.from - cursor2.from, r2.to - cursor2.from)
                    )
                  : null,
                cursor2.tree,
                ranges.length ? ranges[0].from : cursor2.from
              )
            )
          if (!nest.overlay) enter = false
          else if (ranges.length) covered = { ranges, depth: 0, prev: covered }
        }
      } else if (overlay && (range = overlay.predicate(cursor2))) {
        if (range === true) range = new Range2(cursor2.from, cursor2.to)
        if (range.from < range.to) {
          let last = overlay.ranges.length - 1
          if (last >= 0 && overlay.ranges[last].to == range.from)
            overlay.ranges[last] = { from: overlay.ranges[last].from, to: range.to }
          else overlay.ranges.push(range)
        }
      }
      if (enter && cursor2.firstChild()) {
        if (overlay) overlay.depth++
        if (covered) covered.depth++
      } else {
        for (;;) {
          if (cursor2.nextSibling()) break
          if (!cursor2.parent()) break scan
          if (overlay && !--overlay.depth) {
            let ranges = punchRanges(this.ranges, overlay.ranges)
            if (ranges.length) {
              checkRanges(ranges)
              this.inner.splice(
                overlay.index,
                0,
                new InnerParse(
                  overlay.parser,
                  overlay.parser.startParse(
                    this.input,
                    enterFragments(overlay.mounts, ranges),
                    ranges
                  ),
                  overlay.ranges.map(
                    (r2) => new Range2(r2.from - overlay.start, r2.to - overlay.start)
                  ),
                  overlay.target,
                  ranges[0].from
                )
              )
            }
            overlay = overlay.prev
          }
          if (covered && !--covered.depth) covered = covered.prev
        }
      }
    }
  }
}
function checkCover(covered, from, to) {
  for (let range of covered) {
    if (range.from >= to) break
    if (range.to > from) return range.from <= from && range.to >= to ? 2 : 1
  }
  return 0
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1]
    nodes.push(buf.slice(startI, endI, from))
    positions.push(from - off)
  }
}
function materialize(cursor2) {
  let { node } = cursor2,
    stack = []
  let buffer = node.context.buffer
  do {
    stack.push(cursor2.index)
    cursor2.parent()
  } while (!cursor2.tree)
  let base2 = cursor2.tree,
    i = base2.children.indexOf(buffer)
  let buf = base2.children[i],
    b = buf.buffer,
    newStack = [i]
  function split(startI, endI, type, innerOffset, length, stackPos) {
    let targetI = stack[stackPos]
    let children = [],
      positions = []
    sliceBuf(buf, startI, targetI, children, positions, innerOffset)
    let from = b[targetI + 1],
      to = b[targetI + 2]
    newStack.push(children.length)
    let child = stackPos
      ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)
      : node.toTree()
    children.push(child)
    positions.push(from - innerOffset)
    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset)
    return new Tree(type, children, positions, length)
  }
  base2.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1)
  for (let index2 of newStack) {
    let tree = cursor2.tree.children[index2],
      pos = cursor2.tree.positions[index2]
    cursor2.yield(new TreeNode(tree, pos + cursor2.from, index2, cursor2._tree))
  }
}
class StructureCursor {
  constructor(root, offset) {
    this.offset = offset
    this.done = false
    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts)
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(pos) {
    let { cursor: cursor2 } = this,
      p = pos - this.offset
    while (!this.done && cursor2.from < p) {
      if (
        cursor2.to >= pos &&
        cursor2.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)
      );
      else if (!cursor2.next(false)) this.done = true
    }
  }
  hasNode(cursor2) {
    this.moveTo(cursor2.from)
    if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
      for (let tree = this.cursor.tree; ; ) {
        if (tree == cursor2.tree) return true
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
          tree = tree.children[0]
        else break
      }
    }
    return false
  }
}
let FragmentCursor$2 = class FragmentCursor {
  constructor(fragments) {
    var _a2
    this.fragments = fragments
    this.curTo = 0
    this.fragI = 0
    if (fragments.length) {
      let first = (this.curFrag = fragments[0])
      this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to
      this.inner = new StructureCursor(first.tree, -first.offset)
    } else {
      this.curFrag = this.inner = null
    }
  }
  hasNode(node) {
    while (this.curFrag && node.from >= this.curTo) this.nextFrag()
    return (
      this.curFrag &&
      this.curFrag.from <= node.from &&
      this.curTo >= node.to &&
      this.inner.hasNode(node)
    )
  }
  nextFrag() {
    var _a2
    this.fragI++
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null
    } else {
      let frag = (this.curFrag = this.fragments[this.fragI])
      this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to
      this.inner = new StructureCursor(frag.tree, -frag.offset)
    }
  }
  findMounts(pos, parser2) {
    var _a2
    let result = []
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1)
      for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
        let mount =
          (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted)
        if (mount && mount.parser == parser2) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i]
            if (frag.from >= pos2.to) break
            if (frag.tree == this.curFrag.tree)
              result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              })
          }
        }
      }
    }
    return result
  }
}
function punchRanges(outer, ranges) {
  let copy = null,
    current = ranges
  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to,
      gapTo = outer[i].from
    for (; j < current.length; j++) {
      let r2 = current[j]
      if (r2.from >= gapTo) break
      if (r2.to <= gapFrom) continue
      if (!copy) current = copy = ranges.slice()
      if (r2.from < gapFrom) {
        copy[j] = new Range2(r2.from, gapFrom)
        if (r2.to > gapTo) copy.splice(j + 1, 0, new Range2(gapTo, r2.to))
      } else if (r2.to > gapTo) {
        copy[j--] = new Range2(gapTo, r2.to)
      } else {
        copy.splice(j--, 1)
      }
    }
  }
  return current
}
function findCoverChanges(a, b, from, to) {
  let iA = 0,
    iB = 0,
    inA = false,
    inB = false,
    pos = -1e9
  let result = []
  for (;;) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from
    if (inA != inB) {
      let start = Math.max(pos, from),
        end = Math.min(nextA, nextB, to)
      if (start < end) result.push(new Range2(start, end))
    }
    pos = Math.min(nextA, nextB)
    if (pos == 1e9) break
    if (nextA == pos) {
      if (!inA) inA = true
      else {
        inA = false
        iA++
      }
    }
    if (nextB == pos) {
      if (!inB) inB = true
      else {
        inB = false
        iB++
      }
    }
  }
  return result
}
function enterFragments(mounts, ranges) {
  let result = []
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),
      endPos = startPos + mount.tree.length
    let from = Math.max(frag.from, startPos),
      to = Math.min(frag.to, endPos)
    if (mount.overlay) {
      let overlay = mount.overlay.map((r2) => new Range2(r2.from + pos, r2.to + pos))
      let changes = findCoverChanges(ranges, overlay, from, to)
      for (let i = 0, pos2 = from; ; i++) {
        let last = i == changes.length,
          end = last ? to : changes[i].from
        if (end > pos2)
          result.push(
            new TreeFragment(
              pos2,
              end,
              mount.tree,
              -startPos,
              frag.from >= pos2 || frag.openStart,
              frag.to <= end || frag.openEnd
            )
          )
        if (last) break
        pos2 = changes[i].to
      }
    } else {
      result.push(
        new TreeFragment(
          from,
          to,
          mount.tree,
          -startPos,
          frag.from >= startPos || frag.openStart,
          frag.to <= endPos || frag.openEnd
        )
      )
    }
  }
  return result
}
let nextTagID = 0
class Tag {
  /**
  @internal
  */
  constructor(name2, set2, base2, modified) {
    this.name = name2
    this.set = set2
    this.base = base2
    this.modified = modified
    this.id = nextTagID++
  }
  toString() {
    let { name: name2 } = this
    for (let mod of this.modified) if (mod.name) name2 = `${mod.name}(${name2})`
    return name2
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == 'string' ? nameOrParent : '?'
    if (nameOrParent instanceof Tag) parent = nameOrParent
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error('Can not derive from a modified tag')
    let tag = new Tag(name2, [], null, [])
    tag.set.push(tag)
    if (parent) for (let t2 of parent.set) tag.set.push(t2)
    return tag
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2)
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1) return tag
      return Modifier.get(
        tag.base || tag,
        tag.modified.concat(mod).sort((a, b) => a.id - b.id)
      )
    }
  }
}
let nextModifierID = 0
class Modifier {
  constructor(name2) {
    this.name = name2
    this.instances = []
    this.id = nextModifierID++
  }
  static get(base2, mods) {
    if (!mods.length) return base2
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified))
    if (exists) return exists
    let set2 = [],
      tag = new Tag(base2.name, set2, base2, mods)
    for (let m of mods) m.instances.push(tag)
    let configs = powerSet(mods)
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs) set2.push(Modifier.get(parent, config2))
    return tag
  }
}
function sameArray(a, b) {
  return a.length == b.length && a.every((x2, i) => x2 == b[i])
}
function powerSet(array) {
  let sets = [[]]
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e2 = sets.length; j < e2; j++) {
      sets.push(sets[j].concat(array[i]))
    }
  }
  return sets.sort((a, b) => b.length - a.length)
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null)
  for (let prop in spec) {
    let tags2 = spec[prop]
    if (!Array.isArray(tags2)) tags2 = [tags2]
    for (let part of prop.split(' '))
      if (part) {
        let pieces = [],
          mode = 2,
          rest = part
        for (let pos = 0; ; ) {
          if (rest == '...' && pos > 0 && pos + 3 == part.length) {
            mode = 1
            break
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest)
          if (!m) throw new RangeError('Invalid path: ' + part)
          pieces.push(m[0] == '*' ? '' : m[0][0] == '"' ? JSON.parse(m[0]) : m[0])
          pos += m[0].length
          if (pos == part.length) break
          let next = part[pos++]
          if (pos == part.length && next == '!') {
            mode = 0
            break
          }
          if (next != '/') throw new RangeError('Invalid path: ' + part)
          rest = part.slice(pos)
        }
        let last = pieces.length - 1,
          inner = pieces[last]
        if (!inner) throw new RangeError('Invalid path: ' + part)
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null)
        byName[inner] = rule.sort(byName[inner])
      }
  }
  return ruleNodeProp.add(byName)
}
const ruleNodeProp = new NodeProp()
class Rule {
  constructor(tags2, mode, context, next) {
    this.tags = tags2
    this.mode = mode
    this.context = context
    this.next = next
  }
  get opaque() {
    return this.mode == 0
  }
  get inherit() {
    return this.mode == 1
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other
      return this
    }
    other.next = this.sort(other.next)
    return other
  }
  get depth() {
    return this.context ? this.context.length : 0
  }
}
Rule.empty = new Rule([], 2, null)
function tagHighlighter(tags2, options) {
  let map2 = /* @__PURE__ */ Object.create(null)
  for (let style of tags2) {
    if (!Array.isArray(style.tag)) map2[style.tag.id] = style.class
    else for (let tag of style.tag) map2[tag.id] = style.class
  }
  let { scope, all = null } = options || {}
  return {
    style: (tags3) => {
      let cls = all
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map2[sub.id]
          if (tagClass) {
            cls = cls ? cls + ' ' + tagClass : tagClass
            break
          }
        }
      }
      return cls
    },
    scope
  }
}
function highlightTags(highlighters, tags2) {
  let result = null
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2)
    if (value) result = result ? result + ' ' + value : value
  }
  return result
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(
    from,
    Array.isArray(highlighter) ? highlighter : [highlighter],
    putStyle
  )
  builder.highlightRange(tree.cursor(), from, to, '', builder.highlighters)
  builder.flush(to)
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at
    this.highlighters = highlighters
    this.span = span
    this.class = ''
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at)
      if (at > this.at) this.at = at
      this.class = cls
    }
  }
  flush(to) {
    if (to > this.at && this.class) this.span(this.at, to, this.class)
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor2
    if (start >= to || end <= from) return
    if (type.isTop) highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type))
    let cls = inheritedClass
    let rule = getStyleTags(cursor2) || Rule.empty
    let tagCls = highlightTags(highlighters, rule.tags)
    if (tagCls) {
      if (cls) cls += ' '
      cls += tagCls
      if (rule.mode == 1) inheritedClass += (inheritedClass ? ' ' : '') + tagCls
    }
    this.startSpan(Math.max(from, start), cls)
    if (rule.opaque) return
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted)
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1)
      let innerHighlighters = this.highlighters.filter(
        (h2) => !h2.scope || h2.scope(mounted.tree.type)
      )
      let hasChild2 = cursor2.firstChild()
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null
        let nextPos = next ? next.from + start : end
        let rangeFrom2 = Math.max(from, pos),
          rangeTo2 = Math.min(to, nextPos)
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters)
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls)
            if (cursor2.to >= nextPos || !cursor2.nextSibling()) break
          }
        }
        if (!next || nextPos > to) break
        pos = next.to + start
        if (pos > from) {
          this.highlightRange(
            inner.cursor(),
            Math.max(from, next.from + start),
            Math.min(to, pos),
            '',
            innerHighlighters
          )
          this.startSpan(Math.min(to, pos), cls)
        }
      }
      if (hasChild2) cursor2.parent()
    } else if (cursor2.firstChild()) {
      if (mounted) inheritedClass = ''
      do {
        if (cursor2.to <= from) continue
        if (cursor2.from >= to) break
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters)
        this.startSpan(Math.min(to, cursor2.to), cls)
      } while (cursor2.nextSibling())
      cursor2.parent()
    }
  }
}
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp)
  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next
  return rule || null
}
const t = Tag.define
const comment = t(),
  name = t(),
  typeName = t(name),
  propertyName = t(name),
  literal = t(),
  string = t(literal),
  number = t(literal),
  content = t(),
  heading = t(content),
  keyword = t(),
  operator = t(),
  punctuation = t(),
  bracket = t(punctuation),
  meta = t()
const tags$1 = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier('definition'),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier('constant'),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier('function'),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier('standard'),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier('local'),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier('special')
}
for (let name2 in tags$1) {
  let val = tags$1[name2]
  if (val instanceof Tag) val.name = name2
}
tagHighlighter([
  { tag: tags$1.link, class: 'tok-link' },
  { tag: tags$1.heading, class: 'tok-heading' },
  { tag: tags$1.emphasis, class: 'tok-emphasis' },
  { tag: tags$1.strong, class: 'tok-strong' },
  { tag: tags$1.keyword, class: 'tok-keyword' },
  { tag: tags$1.atom, class: 'tok-atom' },
  { tag: tags$1.bool, class: 'tok-bool' },
  { tag: tags$1.url, class: 'tok-url' },
  { tag: tags$1.labelName, class: 'tok-labelName' },
  { tag: tags$1.inserted, class: 'tok-inserted' },
  { tag: tags$1.deleted, class: 'tok-deleted' },
  { tag: tags$1.literal, class: 'tok-literal' },
  { tag: tags$1.string, class: 'tok-string' },
  { tag: tags$1.number, class: 'tok-number' },
  { tag: [tags$1.regexp, tags$1.escape, tags$1.special(tags$1.string)], class: 'tok-string2' },
  { tag: tags$1.variableName, class: 'tok-variableName' },
  { tag: tags$1.local(tags$1.variableName), class: 'tok-variableName tok-local' },
  { tag: tags$1.definition(tags$1.variableName), class: 'tok-variableName tok-definition' },
  { tag: tags$1.special(tags$1.variableName), class: 'tok-variableName2' },
  { tag: tags$1.definition(tags$1.propertyName), class: 'tok-propertyName tok-definition' },
  { tag: tags$1.typeName, class: 'tok-typeName' },
  { tag: tags$1.namespace, class: 'tok-namespace' },
  { tag: tags$1.className, class: 'tok-className' },
  { tag: tags$1.macroName, class: 'tok-macroName' },
  { tag: tags$1.propertyName, class: 'tok-propertyName' },
  { tag: tags$1.operator, class: 'tok-operator' },
  { tag: tags$1.comment, class: 'tok-comment' },
  { tag: tags$1.meta, class: 'tok-meta' },
  { tag: tags$1.invalid, class: 'tok-invalid' },
  { tag: tags$1.punctuation, class: 'tok-punctuation' }
])
var _a
const languageDataProp = /* @__PURE__ */ new NodeProp()
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  })
}
const sublanguageProp = /* @__PURE__ */ new NodeProp()
class Language {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data2, parser2, extraExtensions = [], name2 = '') {
    this.data = data2
    this.name = name2
    if (!EditorState.prototype.hasOwnProperty('tree'))
      Object.defineProperty(EditorState.prototype, 'tree', {
        get() {
          return syntaxTree(this)
        }
      })
    this.parser = parser2
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side),
          data3 = top2.type.prop(languageDataProp)
        if (!data3) return []
        let base2 = state.facet(data3),
          sub = top2.type.prop(sublanguageProp)
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side)
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data4 = state.facet(sublang.facet)
              return sublang.type == 'replace' ? data4 : data4.concat(base2)
            }
        }
        return base2
      })
    ].concat(extraExtensions)
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language)
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }]
    if (!lang || !lang.allowsNesting) return []
    let result = []
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length })
        return
      }
      let mount = tree.prop(NodeProp.mounted)
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r2 of mount.overlay) result.push({ from: r2.from + from, to: r2.to + from })
          else result.push({ from, to: from + tree.length })
          return
        } else if (mount.overlay) {
          let size = result.length
          explore(mount.tree, mount.overlay[0].from + from)
          if (result.length > size) return
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i]
        if (ch instanceof Tree) explore(ch, tree.positions[i] + from)
      }
    }
    explore(syntaxTree(state), 0)
    return result
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define()
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language),
    tree = syntaxTree(state).topNode
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop) tree = node
  }
  return tree
}
class LRLanguage extends Language {
  constructor(data2, parser2, name2) {
    super(data2, parser2, [], name2)
    this.parser = parser2
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data2 = defineLanguageFacet(spec.languageData)
    return new LRLanguage(
      data2,
      spec.parser.configure({
        props: [languageDataProp.add((type) => (type.isTop ? data2 : void 0))]
      }),
      spec.name
    )
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name)
  }
  get allowsNesting() {
    return this.parser.hasWrappers()
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false)
  return field ? field.tree : Tree.empty
}
class DocInput {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2
    this.cursorPos = 0
    this.string = ''
    this.cursor = doc2.iter()
  }
  get length() {
    return this.doc.length
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value
    this.cursorPos = pos + this.string.length
    return this.cursorPos - this.string.length
  }
  chunk(pos) {
    this.syncTo(pos)
    return this.string
  }
  get lineChunks() {
    return true
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length
    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to)
    else return this.string.slice(from - stringStart, to - stringStart)
  }
}
let currentContext = null
class ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2
    this.state = state
    this.fragments = fragments
    this.tree = tree
    this.treeLen = treeLen
    this.viewport = viewport
    this.skipped = skipped
    this.scheduleOn = scheduleOn
    this.parse = null
    this.tempSkipped = []
  }
  /**
  @internal
  */
  static create(parser2, state, viewport) {
    return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null)
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments)
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length) upto = void 0
    if (
      this.tree != Tree.empty &&
      this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)
    ) {
      this.takeTree()
      return true
    }
    return this.withContext(() => {
      var _a2
      if (typeof until == 'number') {
        let endTime = Date.now() + until
        until = () => Date.now() > endTime
      }
      if (!this.parse) this.parse = this.startParse()
      if (
        upto != null &&
        (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
        upto < this.state.doc.length
      )
        this.parse.stopAt(upto)
      for (;;) {
        let done = this.parse.advance()
        if (done) {
          this.fragments = this.withoutTempSkipped(
            TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null)
          )
          this.treeLen =
            (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length
          this.tree = done
          this.parse = null
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse()
          else return true
        }
        if (until()) return false
      }
    })
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos)
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {}
      })
      this.treeLen = pos
      this.tree = tree
      this.fragments = this.withoutTempSkipped(
        TreeFragment.addTree(this.tree, this.fragments, true)
      )
      this.parse = null
    }
  }
  withContext(f) {
    let prev = currentContext
    currentContext = this
    try {
      return f()
    } finally {
      currentContext = prev
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; (r2 = this.tempSkipped.pop()); )
      fragments = cutFragments(fragments, r2.from, r2.to)
    return fragments
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this
    this.takeTree()
    if (!changes.empty) {
      let ranges = []
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }))
      fragments = TreeFragment.applyChanges(fragments, ranges)
      tree = Tree.empty
      treeLen = 0
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) }
      if (this.skipped.length) {
        skipped = []
        for (let r2 of this.skipped) {
          let from = changes.mapPos(r2.from, 1),
            to = changes.mapPos(r2.to, -1)
          if (from < to) skipped.push({ from, to })
        }
      }
    }
    return new ParseContext(
      this.parser,
      newState,
      fragments,
      tree,
      treeLen,
      viewport,
      skipped,
      this.scheduleOn
    )
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false
    this.viewport = viewport
    let startLen = this.skipped.length
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i]
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to)
        this.skipped.splice(i--, 1)
      }
    }
    if (this.skipped.length >= startLen) return false
    this.reset()
    return true
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree()
      this.parse = null
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to })
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new (class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from,
          to = ranges[ranges.length - 1].to
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx = currentContext
            if (cx) {
              for (let r2 of ranges) cx.tempSkipped.push(r2)
              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until
            }
            this.parsedPos = to
            return new Tree(NodeType.none, [], [], to - from)
          },
          stoppedAt: null,
          stopAt() {}
        }
        return parser2
      }
    })()
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length)
    let frags = this.fragments
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext
  }
}
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }])
}
class LanguageState {
  constructor(context) {
    this.context = context
    this.tree = context.tree
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree) return this
    let newCx = this.context.changes(tr.changes, tr.state)
    let upto =
      this.context.treeLen == tr.startState.doc.length
        ? void 0
        : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to)
    if (!newCx.work(20, upto)) newCx.takeTree()
    return new LanguageState(newCx)
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length)
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo })
    if (!parseState.work(20, vpTo)) parseState.takeTree()
    return new LanguageState(parseState)
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e2 of tr.effects) if (e2.is(Language.setState)) return e2.value
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state)
    return value.apply(tr)
  }
})
let requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  )
  return () => clearTimeout(timeout)
}
if (typeof requestIdleCallback != 'undefined')
  requestIdle = (callback) => {
    let idle = -1,
      timeout = setTimeout(
        () => {
          idle = requestIdleCallback(callback, {
            timeout: 500 - 100
            /* Work.MinPause */
          })
        },
        100
        /* Work.MinPause */
      )
    return () => (idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle))
  }
const isInputPending =
  typeof navigator != 'undefined' &&
  ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending()
    : null
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(
  class ParseWorker {
    constructor(view) {
      this.view = view
      this.working = null
      this.workScheduled = 0
      this.chunkEnd = -1
      this.chunkBudget = -1
      this.work = this.work.bind(this)
      this.scheduleWork()
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork()
      if (update.docChanged || update.selectionSet) {
        if (this.view.hasFocus) this.chunkBudget += 50
        this.scheduleWork()
      }
      this.checkAsyncSchedule(cx)
    }
    scheduleWork() {
      if (this.working) return
      let { state } = this.view,
        field = state.field(Language.state)
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work)
    }
    work(deadline) {
      this.working = null
      let now = Date.now()
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4
        this.chunkBudget = 3e3
      }
      if (this.chunkBudget <= 0) return
      let {
          state,
          viewport: { to: vpTo }
        } = this.view,
        field = state.field(Language.state)
      if (
        field.tree == field.context.tree &&
        field.context.isDone(
          vpTo + 1e5
          /* Work.MaxParseAhead */
        )
      )
        return
      let endTime =
        Date.now() +
        Math.min(
          this.chunkBudget,
          100,
          deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9
        )
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3
      let done = field.context.work(
        () => {
          return (isInputPending && isInputPending()) || Date.now() > endTime
        },
        vpTo + (viewportFirst ? 0 : 1e5)
      )
      this.chunkBudget -= Date.now() - now
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree()
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) })
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork()
      this.checkAsyncSchedule(field.context)
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++
        cx.scheduleOn
          .then(() => this.scheduleWork())
          .catch((err) => logException(this.view.state, err))
          .then(() => this.workScheduled--)
        cx.scheduleOn = null
      }
    }
    destroy() {
      if (this.working) this.working()
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0)
    }
  },
  {
    eventHandlers: {
      focus() {
        this.scheduleWork()
      }
    }
  }
)
const language = /* @__PURE__ */ Facet.define({
  combine(languages2) {
    return languages2.length ? languages2[0] : null
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2)
      return lang && lang.name ? { 'data-language': lang.name } : {}
    })
  ]
})
class LanguageSupport {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2
    this.support = support
    this.extension = [language2, support]
  }
}
class LanguageDescription {
  constructor(name2, alias, extensions, filename, loadFunc, support = void 0) {
    this.name = name2
    this.alias = alias
    this.extensions = extensions
    this.filename = filename
    this.loadFunc = loadFunc
    this.support = support
    this.loading = null
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return (
      this.loading ||
      (this.loading = this.loadFunc().then(
        (support) => (this.support = support),
        (err) => {
          this.loading = null
          throw err
        }
      ))
    )
  }
  /**
  Create a language description.
  */
  static of(spec) {
    let { load, support } = spec
    if (!load) {
      if (!support)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of")
      load = () => Promise.resolve(support)
    }
    return new LanguageDescription(
      spec.name,
      (spec.alias || []).concat(spec.name).map((s) => s.toLowerCase()),
      spec.extensions || [],
      spec.filename,
      load,
      support
    )
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(descs, filename) {
    for (let d of descs) if (d.filename && d.filename.test(filename)) return d
    let ext = /\.([^.]+)$/.exec(filename)
    if (ext) {
      for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d
    }
    return null
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(descs, name2, fuzzy = true) {
    name2 = name2.toLowerCase()
    for (let d of descs) if (d.alias.some((a) => a == name2)) return d
    if (fuzzy)
      for (let d of descs)
        for (let a of d.alias) {
          let found = name2.indexOf(a)
          if (
            found > -1 &&
            (a.length > 2 || (!/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a.length])))
          )
            return d
        }
    return null
  }
}
const indentService = /* @__PURE__ */ Facet.define()
const indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    if (!values2.length) return '  '
    let unit = values2[0]
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e2) => e2 != unit[0]))
      throw new Error('Invalid indent unit: ' + JSON.stringify(values2[0]))
    return unit
  }
})
function getIndentUnit(state) {
  let unit = state.facet(indentUnit)
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length
}
function indentString(state, cols) {
  let result = '',
    ts = state.tabSize,
    ch = state.facet(indentUnit)[0]
  if (ch == '	') {
    while (cols >= ts) {
      result += '	'
      cols -= ts
    }
    ch = ' '
  }
  for (let i = 0; i < cols; i++) result += ch
  return result
}
function getIndentation(context, pos) {
  if (context instanceof EditorState) context = new IndentContext(context)
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos)
    if (result !== void 0) return result
  }
  let tree = syntaxTree(context.state)
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null
}
class IndentContext {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state
    this.options = options
    this.unit = getIndentUnit(state)
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos)
    let { simulateBreak, simulateDoubleBreak } = this.options
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos) return { text: '', from: pos }
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak }
      else return { text: line.text.slice(0, simulateBreak - line.from), from: line.from }
    }
    return line
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return ''
    let { text: text2, from } = this.lineAt(pos, bias)
    return text2.slice(pos - from, Math.min(text2.length, pos + 100 - from))
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text: text2, from } = this.lineAt(pos, bias)
    let result = this.countColumn(text2, pos - from)
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1
    if (override > -1) result += override - this.countColumn(text2, text2.search(/\S|$/))
    return result
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos)
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text: text2, from } = this.lineAt(pos, bias)
    let override = this.options.overrideIndentation
    if (override) {
      let overriden = override(from)
      if (overriden > -1) return overriden
    }
    return this.countColumn(text2, text2.search(/\S|$/))
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null
  }
}
const indentNodeProp = /* @__PURE__ */ new NodeProp()
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos)
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos)
  if (inner != stack.node) {
    let add3 = []
    for (
      let cur2 = inner;
      cur2 &&
      !(
        cur2.from < stack.node.from ||
        cur2.to > stack.node.to ||
        (cur2.from == stack.node.from && cur2.type == stack.node.type)
      );
      cur2 = cur2.parent
    )
      add3.push(cur2)
    for (let i = add3.length - 1; i >= 0; i--) stack = { node: add3[i], next: stack }
  }
  return indentFor(stack, cx, pos)
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node)
    if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur2))
  }
  return 0
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp)
  if (strategy) return strategy
  let first = tree.firstChild,
    close
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild,
      closed = last && close.indexOf(last.name) > -1
    return (cx) =>
      delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0)
  }
  return tree.parent == null ? topIndent : null
}
function topIndent() {
  return 0
}
class TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options)
    this.base = base2
    this.pos = pos
    this.context = context
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new TreeIndentContext(base2, pos, context)
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos)
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node)
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from)
    for (;;) {
      let atBreak = node.resolve(line.from)
      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent
      if (isParent(atBreak, node)) break
      line = this.state.doc.lineAt(atBreak.from)
    }
    return this.lineIndent(line.from)
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos)
  }
}
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent) if (parent == cur2) return true
  return false
}
function bracketedAligned(context) {
  let tree = context.node
  let openToken = tree.childAfter(tree.from),
    last = tree.lastChild
  if (!openToken) return null
  let sim = context.options.simulateBreak
  let openLine = context.state.doc.lineAt(openToken.from)
  let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim)
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos)
    if (!next || next == last) return null
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd2) return null
      let space2 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length
      return { from: openToken.from, to: openToken.to + space2 }
    }
    pos = next.to
  }
}
function delimitedIndent({ closing, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing)
}
function delimitedStrategy(context, align, units, closing, closedAt) {
  let after = context.textAfter,
    space2 = after.match(/^\s*/)[0].length
  let closed =
    (closing && after.slice(space2, space2 + closing.length) == closing) ||
    closedAt == context.pos + space2
  let aligned = align ? bracketedAligned(context) : null
  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to)
  return context.baseIndent + (closed ? 0 : context.unit * units)
}
const flatIndent = (context) => context.baseIndent
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter)
    return context.baseIndent + (matchExcept ? 0 : units * context.unit)
  }
}
const foldService = /* @__PURE__ */ Facet.define()
const foldNodeProp = /* @__PURE__ */ new NodeProp()
function foldInside(node) {
  let first = node.firstChild,
    last = node.lastChild
  return first && first.to < last.from
    ? { from: first.to, to: last.type.isError ? node.to : last.from }
    : null
}
class HighlightStyle {
  constructor(specs, options) {
    this.specs = specs
    let modSpec
    function def(spec) {
      let cls = StyleModule.newName()
      ;(modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))['.' + cls] = spec
      return cls
    }
    const all =
      typeof options.all == 'string' ? options.all : options.all ? def(options.all) : void 0
    const scopeOpt = options.scope
    this.scope =
      scopeOpt instanceof Language
        ? (type) => type.prop(languageDataProp) == scopeOpt.data
        : scopeOpt
          ? (type) => type == scopeOpt
          : void 0
    this.style = tagHighlighter(
      specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })),
      {
        all
      }
    ).style
    this.module = modSpec ? new StyleModule(modSpec) : null
    this.themeType = options.themeType
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new HighlightStyle(specs, options || {})
  }
}
const highlighterFacet = /* @__PURE__ */ Facet.define()
const fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return values2.length ? [values2[0]] : null
  }
})
function getHighlighters(state) {
  let main = state.facet(highlighterFacet)
  return main.length ? main : state.facet(fallbackHighlighter)
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter],
    themeType
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module) ext.push(EditorView.styleModule.of(highlighter.module))
    themeType = highlighter.themeType
  }
  if (themeType)
    ext.push(
      highlighterFacet.computeN([EditorView.darkTheme], (state) => {
        return state.facet(EditorView.darkTheme) == (themeType == 'dark') ? [highlighter] : []
      })
    )
  else ext.push(highlighterFacet.of(highlighter))
  return ext
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null)
    this.tree = syntaxTree(view.state)
    this.decorations = this.buildDeco(view, getHighlighters(view.state))
    this.decoratedTo = view.viewport.to
  }
  update(update) {
    let tree = syntaxTree(update.state),
      highlighters = getHighlighters(update.state)
    let styleChange = highlighters != getHighlighters(update.startState)
    let { viewport } = update.view,
      decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1)
    if (
      tree.length < viewport.to &&
      !styleChange &&
      tree.type == this.tree.type &&
      decoratedToMapped >= viewport.to
    ) {
      this.decorations = this.decorations.map(update.changes)
      this.decoratedTo = decoratedToMapped
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree
      this.decorations = this.buildDeco(update.view, highlighters)
      this.decoratedTo = viewport.to
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length) return Decoration.none
    let builder = new RangeSetBuilder()
    for (let { from, to } of view.visibleRanges) {
      highlightTree(
        this.tree,
        highlighters,
        (from2, to2, style) => {
          builder.add(
            from2,
            to2,
            this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style }))
          )
        },
        from,
        to
      )
    }
    return builder.finish()
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(
  /* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  })
)
const DefaultScanDist = 1e4,
  DefaultBrackets = '()[]{}'
const bracketMatchingHandle = /* @__PURE__ */ new NodeProp()
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy)
  if (byProp) return byProp
  if (node.name.length == 1) {
    let index2 = brackets.indexOf(node.name)
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0)) return [brackets[index2 + dir]]
  }
  return null
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle)
  return hasHandle ? hasHandle(node.node) : node
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist,
    brackets = config2.brackets || DefaultBrackets
  let tree = syntaxTree(state),
    node = tree.resolveInner(pos, dir)
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets)
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2)
      if (
        handle &&
        (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)
      )
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets)
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets)
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent,
    firstToken = { from: handle.from, to: handle.to }
  let depth = 0,
    cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor()
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2)
          return {
            start: firstToken,
            end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0,
            matched: true
          }
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2)
            return {
              start: firstToken,
              end:
                endHandle && endHandle.from < endHandle.to
                  ? { from: endHandle.from, to: endHandle.to }
                  : void 0,
              matched: false
            }
          }
          depth--
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
  return { start: firstToken, matched: false }
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1)
  let bracket2 = brackets.indexOf(startCh)
  if (bracket2 < 0 || (bracket2 % 2 == 0) != dir > 0) return null
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos }
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
    depth = 0
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text2 = iter.value
    if (dir < 0) distance += text2.length
    let basePos = pos + distance * dir
    for (
      let pos2 = dir > 0 ? 0 : text2.length - 1, end = dir > 0 ? text2.length : -1;
      pos2 != end;
      pos2 += dir
    ) {
      let found = brackets.indexOf(text2[pos2])
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType) continue
      if ((found % 2 == 0) == dir > 0) {
        depth++
      } else if (depth == 1) {
        return {
          start: startToken,
          end: { from: basePos + pos2, to: basePos + pos2 + 1 },
          matched: found >> 1 == bracket2 >> 1
        }
      } else {
        depth--
      }
    }
    if (dir > 0) distance += text2.length
  }
  return iter.done ? { start: startToken, matched: false } : null
}
function countCol(string2, end, tabSize, startIndex = 0, startValue = 0) {
  if (end == null) {
    end = string2.search(/[^\s\u00a0]/)
    if (end == -1) end = string2.length
  }
  let n2 = startValue
  for (let i = startIndex; i < end; i++) {
    if (string2.charCodeAt(i) == 9) n2 += tabSize - (n2 % tabSize)
    else n2++
  }
  return n2
}
class StringStream {
  /**
  Create a stream.
  */
  constructor(string2, tabSize, indentUnit2, overrideIndent) {
    this.string = string2
    this.tabSize = tabSize
    this.indentUnit = indentUnit2
    this.overrideIndent = overrideIndent
    this.pos = 0
    this.start = 0
    this.lastColumnPos = 0
    this.lastColumnValue = 0
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length) return this.string.charAt(this.pos++)
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(match2) {
    let ch = this.string.charAt(this.pos)
    let ok
    if (typeof match2 == 'string') ok = ch == match2
    else ok = ch && (match2 instanceof RegExp ? match2.test(ch) : match2(ch))
    if (ok) {
      ++this.pos
      return ch
    }
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(match2) {
    let start = this.pos
    while (this.eat(match2)) {}
    return this.pos > start
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let start = this.pos
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos
    return this.pos > start
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(ch) {
    let found = this.string.indexOf(ch, this.pos)
    if (found > -1) {
      this.pos = found
      return true
    }
  }
  /**
  Move back `n` characters.
  */
  backUp(n2) {
    this.pos -= n2
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countCol(
        this.string,
        this.start,
        this.tabSize,
        this.lastColumnPos,
        this.lastColumnValue
      )
      this.lastColumnPos = this.start
    }
    return this.lastColumnValue
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var _a2
    return (_a2 = this.overrideIndent) !== null && _a2 !== void 0
      ? _a2
      : countCol(this.string, null, this.tabSize)
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(pattern, consume, caseInsensitive) {
    if (typeof pattern == 'string') {
      let cased = (str) => (caseInsensitive ? str.toLowerCase() : str)
      let substr = this.string.substr(this.pos, pattern.length)
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) this.pos += pattern.length
        return true
      } else return null
    } else {
      let match2 = this.string.slice(this.pos).match(pattern)
      if (match2 && match2.index > 0) return null
      if (match2 && consume !== false) this.pos += match2[0].length
      return match2
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos)
  }
}
function fullParser(spec) {
  return {
    name: spec.name || '',
    token: spec.token,
    blankLine: spec.blankLine || (() => {}),
    startState: spec.startState || (() => true),
    copyState: spec.copyState || defaultCopyState,
    indent: spec.indent || (() => null),
    languageData: spec.languageData || {},
    tokenTable: spec.tokenTable || noTokens,
    mergeTokens: spec.mergeTokens !== false
  }
}
function defaultCopyState(state) {
  if (typeof state != 'object') return state
  let newState = {}
  for (let prop in state) {
    let val = state[prop]
    newState[prop] = val instanceof Array ? val.slice() : val
  }
  return newState
}
const IndentedFrom = /* @__PURE__ */ new WeakMap()
class StreamLanguage extends Language {
  constructor(parser2) {
    let data2 = defineLanguageFacet(parser2.languageData)
    let p = fullParser(parser2),
      self2
    let impl = new (class extends Parser {
      createParse(input, fragments, ranges) {
        return new Parse$1(self2, input, fragments, ranges)
      }
    })()
    super(data2, impl, [], parser2.name)
    this.topNode = docID(data2, this)
    self2 = this
    this.streamParser = p
    this.stateAfter = new NodeProp({ perNode: true })
    this.tokenTable = parser2.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable
  }
  /**
  Define a stream language.
  */
  static define(spec) {
    return new StreamLanguage(spec)
  }
  /**
  @internal
  */
  getIndent(cx) {
    let from = void 0
    let { overrideIndentation } = cx.options
    if (overrideIndentation) {
      from = IndentedFrom.get(cx.state)
      if (from != null && from < cx.pos - 1e4) from = void 0
    }
    let start = findState(
        this,
        cx.node.tree,
        cx.node.from,
        cx.node.from,
        from !== null && from !== void 0 ? from : cx.pos
      ),
      statePos,
      state
    if (start) {
      state = start.state
      statePos = start.pos + 1
    } else {
      state = this.streamParser.startState(cx.unit)
      statePos = cx.node.from
    }
    if (cx.pos - statePos > 1e4) return null
    while (statePos < cx.pos) {
      let line2 = cx.state.doc.lineAt(statePos),
        end = Math.min(cx.pos, line2.to)
      if (line2.length) {
        let indentation = overrideIndentation ? overrideIndentation(line2.from) : -1
        let stream = new StringStream(
          line2.text,
          cx.state.tabSize,
          cx.unit,
          indentation < 0 ? void 0 : indentation
        )
        while (stream.pos < end - line2.from) readToken$1(this.streamParser.token, stream, state)
      } else {
        this.streamParser.blankLine(state, cx.unit)
      }
      if (end == cx.pos) break
      statePos = line2.to + 1
    }
    let line = cx.lineAt(cx.pos)
    if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from)
    return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx)
  }
  get allowsNesting() {
    return false
  }
}
function findState(lang, tree, off, startPos, before) {
  let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter)
  if (state) return { state: lang.streamParser.copyState(state), pos: off + tree.length }
  for (let i = tree.children.length - 1; i >= 0; i--) {
    let child = tree.children[i],
      pos = off + tree.positions[i]
    let found =
      child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before)
    if (found) return found
  }
  return null
}
function cutTree(lang, tree, from, to, inside2) {
  if (inside2 && from <= 0 && to >= tree.length) return tree
  if (!inside2 && from == 0 && tree.type == lang.topNode) inside2 = true
  for (let i = tree.children.length - 1; i >= 0; i--) {
    let pos = tree.positions[i],
      child = tree.children[i],
      inner
    if (pos < to && child instanceof Tree) {
      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside2))) break
      return !inside2
        ? inner
        : new Tree(
            tree.type,
            tree.children.slice(0, i).concat(inner),
            tree.positions.slice(0, i + 1),
            pos + inner.length
          )
    }
  }
  return null
}
function findStartInFragments(lang, fragments, startPos, endPos, editorState) {
  for (let f of fragments) {
    let from = f.from + (f.openStart ? 25 : 0),
      to = f.to - (f.openEnd ? 25 : 0)
    let found =
        from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),
      tree
    if (
      found &&
      found.pos <= endPos &&
      (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))
    )
      return { state: found.state, tree }
  }
  return {
    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),
    tree: Tree.empty
  }
}
let Parse$1 = class Parse {
  constructor(lang, input, fragments, ranges) {
    this.lang = lang
    this.input = input
    this.fragments = fragments
    this.ranges = ranges
    this.stoppedAt = null
    this.chunks = []
    this.chunkPos = []
    this.chunk = []
    this.chunkReused = void 0
    this.rangeIndex = 0
    this.to = ranges[ranges.length - 1].to
    let context = ParseContext.get(),
      from = ranges[0].from
    let { state, tree } = findStartInFragments(
      lang,
      fragments,
      from,
      this.to,
      context === null || context === void 0 ? void 0 : context.state
    )
    this.state = state
    this.parsedPos = this.chunkStart = from + tree.length
    for (let i = 0; i < tree.children.length; i++) {
      this.chunks.push(tree.children[i])
      this.chunkPos.push(tree.positions[i])
    }
    if (
      context &&
      this.parsedPos < context.viewport.from - 1e5 &&
      ranges.some((r2) => r2.from <= context.viewport.from && r2.to >= context.viewport.from)
    ) {
      this.state = this.lang.streamParser.startState(getIndentUnit(context.state))
      context.skipUntilInView(this.parsedPos, context.viewport.from)
      this.parsedPos = context.viewport.from
    }
    this.moveRangeIndex()
  }
  advance() {
    let context = ParseContext.get()
    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt)
    let end = Math.min(
      parseEnd,
      this.chunkStart + 2048
      /* C.ChunkSize */
    )
    if (context) end = Math.min(end, context.viewport.to)
    while (this.parsedPos < end) this.parseLine(context)
    if (this.chunkStart < this.parsedPos) this.finishChunk()
    if (this.parsedPos >= parseEnd) return this.finish()
    if (context && this.parsedPos >= context.viewport.to) {
      context.skipUntilInView(this.parsedPos, parseEnd)
      return this.finish()
    }
    return null
  }
  stopAt(pos) {
    this.stoppedAt = pos
  }
  lineAfter(pos) {
    let chunk = this.input.chunk(pos)
    if (!this.input.lineChunks) {
      let eol = chunk.indexOf('\n')
      if (eol > -1) chunk = chunk.slice(0, eol)
    } else if (chunk == '\n') {
      chunk = ''
    }
    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos)
  }
  nextLine() {
    let from = this.parsedPos,
      line = this.lineAfter(from),
      end = from + line.length
    for (let index2 = this.rangeIndex; ; ) {
      let rangeEnd2 = this.ranges[index2].to
      if (rangeEnd2 >= end) break
      line = line.slice(0, rangeEnd2 - (end - line.length))
      index2++
      if (index2 == this.ranges.length) break
      let rangeStart = this.ranges[index2].from
      let after = this.lineAfter(rangeStart)
      line += after
      end = rangeStart + after.length
    }
    return { line, end }
  }
  skipGapsTo(pos, offset, side) {
    for (;;) {
      let end = this.ranges[this.rangeIndex].to,
        offPos = pos + offset
      if (side > 0 ? end > offPos : end >= offPos) break
      let start = this.ranges[++this.rangeIndex].from
      offset += start - end
    }
    return offset
  }
  moveRangeIndex() {
    while (this.ranges[this.rangeIndex].to < this.parsedPos) this.rangeIndex++
  }
  emitToken(id2, from, to, offset) {
    let size = 4
    if (this.ranges.length > 1) {
      offset = this.skipGapsTo(from, offset, 1)
      from += offset
      let len0 = this.chunk.length
      offset = this.skipGapsTo(to, offset, -1)
      to += offset
      size += this.chunk.length - len0
    }
    let last = this.chunk.length - 4
    if (
      this.lang.streamParser.mergeTokens &&
      size == 4 &&
      last >= 0 &&
      this.chunk[last] == id2 &&
      this.chunk[last + 2] == from
    )
      this.chunk[last + 2] = to
    else this.chunk.push(id2, from, to, size)
    return offset
  }
  parseLine(context) {
    let { line, end } = this.nextLine(),
      offset = 0,
      { streamParser } = this.lang
    let stream = new StringStream(
      line,
      context ? context.state.tabSize : 4,
      context ? getIndentUnit(context.state) : 2
    )
    if (stream.eol()) {
      streamParser.blankLine(this.state, stream.indentUnit)
    } else {
      while (!stream.eol()) {
        let token = readToken$1(streamParser.token, stream, this.state)
        if (token)
          offset = this.emitToken(
            this.lang.tokenTable.resolve(token),
            this.parsedPos + stream.start,
            this.parsedPos + stream.pos,
            offset
          )
        if (stream.start > 1e4) break
      }
    }
    this.parsedPos = end
    this.moveRangeIndex()
    if (this.parsedPos < this.to) this.parsedPos++
  }
  finishChunk() {
    let tree = Tree.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    })
    tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [
      [this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]
    ])
    this.chunks.push(tree)
    this.chunkPos.push(this.chunkStart - this.ranges[0].from)
    this.chunk = []
    this.chunkReused = void 0
    this.chunkStart = this.parsedPos
  }
  finish() {
    return new Tree(
      this.lang.topNode,
      this.chunks,
      this.chunkPos,
      this.parsedPos - this.ranges[0].from
    ).balance()
  }
}
function readToken$1(token, stream, state) {
  stream.start = stream.pos
  for (let i = 0; i < 10; i++) {
    let result = token(stream, state)
    if (stream.pos > stream.start) return result
  }
  throw new Error('Stream parser failed to advance stream.')
}
const noTokens = /* @__PURE__ */ Object.create(null)
const typeArray = [NodeType.none]
const nodeSet = /* @__PURE__ */ new NodeSet(typeArray)
const warned = []
const byTag = /* @__PURE__ */ Object.create(null)
const defaultTable = /* @__PURE__ */ Object.create(null)
for (let [legacyName, name2] of [
  ['variable', 'variableName'],
  ['variable-2', 'variableName.special'],
  ['string-2', 'string.special'],
  ['def', 'variableName.definition'],
  ['tag', 'tagName'],
  ['attribute', 'attributeName'],
  ['type', 'typeName'],
  ['builtin', 'variableName.standard'],
  ['qualifier', 'modifier'],
  ['error', 'invalid'],
  ['header', 'heading'],
  ['property', 'propertyName']
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2)
class TokenTable {
  constructor(extra) {
    this.extra = extra
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable)
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag))
  }
}
const defaultTokenTable = /* @__PURE__ */ new TokenTable(noTokens)
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1) return
  warned.push(part)
  console.warn(msg)
}
function createTokenType(extra, tagStr) {
  let tags$1$1 = []
  for (let name3 of tagStr.split(' ')) {
    let found = []
    for (let part of name3.split('.')) {
      let value = extra[part] || tags$1[part]
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`)
      } else if (typeof value == 'function') {
        if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`)
        else found = found.map(value)
      } else {
        if (found.length) warnForPart(part, `Tag ${part} used as modifier`)
        else found = Array.isArray(value) ? value : [value]
      }
    }
    for (let tag of found) tags$1$1.push(tag)
  }
  if (!tags$1$1.length) return 0
  let name2 = tagStr.replace(/ /g, '_'),
    key = name2 + ' ' + tags$1$1.map((t2) => t2.id)
  let known = byTag[key]
  if (known) return known.id
  let type = (byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1$1 })]
  }))
  typeArray.push(type)
  return type.id
}
function docID(data2, lang) {
  let type = NodeType.define({
    id: typeArray.length,
    name: 'Document',
    props: [
      languageDataProp.add(() => data2),
      indentNodeProp.add(() => (cx) => lang.getIndent(cx))
    ],
    top: true
  })
  typeArray.push(type)
  return type
}
;({
  rtl: /* @__PURE__ */ Decoration.mark({
    class: 'cm-iso',
    inclusive: true,
    attributes: { dir: 'rtl' },
    bidiIsolate: Direction.RTL
  }),
  ltr: /* @__PURE__ */ Decoration.mark({
    class: 'cm-iso',
    inclusive: true,
    attributes: { dir: 'ltr' },
    bidiIsolate: Direction.LTR
  })
})
const toggleComment = (target) => {
  let { state } = target,
    line = state.doc.lineAt(state.selection.main.from),
    config2 = getConfig(target.state, line.from)
  return config2.line
    ? toggleLineComment(target)
    : config2.block
      ? toggleBlockCommentByLine(target)
      : false
}
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly) return false
    let tr = f(option, state)
    if (!tr) return false
    dispatch(state.update(tr))
    return true
  }
}
const toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
)
const toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
)
const toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
)
function getConfig(state, pos) {
  let data2 = state.languageDataAt('commentTokens', pos, 1)
  return data2.length ? data2[0] : {}
}
const SearchMargin = 50
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from)
  let textAfter = state.sliceDoc(to, to + SearchMargin)
  let spaceBefore = /\s*$/.exec(textBefore)[0].length,
    spaceAfter = /^\s*/.exec(textAfter)[0].length
  let beforeOff = textBefore.length - spaceBefore
  if (
    textBefore.slice(beforeOff - open.length, beforeOff) == open &&
    textAfter.slice(spaceAfter, spaceAfter + close.length) == close
  ) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    }
  }
  let startText, endText
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to)
  } else {
    startText = state.sliceDoc(from, from + SearchMargin)
    endText = state.sliceDoc(to - SearchMargin, to)
  }
  let startSpace = /^\s*/.exec(startText)[0].length,
    endSpace = /\s*$/.exec(endText)[0].length
  let endOff = endText.length - endSpace - close.length
  if (
    startText.slice(startSpace, startSpace + open.length) == open &&
    endText.slice(endOff, endOff + close.length) == close
  ) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    }
  }
  return null
}
function selectedLineRanges(state) {
  let ranges = []
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from)
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to)
    if (toLine.from > fromLine.from && toLine.from == r2.to)
      toLine = r2.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r2.to - 1)
    let last = ranges.length - 1
    if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to
    else ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to })
  }
  return ranges
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block)
  if (!tokens.every((c) => c)) return null
  let comments = ranges.map((r2, i) => findBlockComment(state, tokens[i], r2.from, r2.to))
  if (option != 2 && !comments.every((c) => c)) {
    return {
      changes: state.changes(
        ranges.map((range, i) => {
          if (comments[i]) return []
          return [
            { from: range.from, insert: tokens[i].open + ' ' },
            { from: range.to, insert: ' ' + tokens[i].close }
          ]
        })
      )
    }
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = []
    for (let i = 0, comment2; i < comments.length; i++)
      if ((comment2 = comments[i])) {
        let token = tokens[i],
          { open, close } = comment2
        changes.push(
          { from: open.pos - token.open.length, to: open.pos + open.margin },
          { from: close.pos - close.margin, to: close.pos + token.close.length }
        )
      }
    return { changes }
  }
  return null
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = []
  let prevLine = -1
  for (let { from, to } of ranges) {
    let startI = lines.length,
      minIndent = 1e9
    let token = getConfig(state, from).line
    if (!token) continue
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos)
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from
        let indent = /^\s*/.exec(line.text)[0].length
        let empty2 = indent == line.length
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1
        if (indent < line.text.length && indent < minIndent) minIndent = indent
        lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false })
      }
      pos = line.to + 1
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent
    }
    if (lines.length == startI + 1) lines[startI].single = true
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = []
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2) changes.push({ from: line.from + indent, insert: token + ' ' })
    let changeSet = state.changes(changes)
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) }
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = []
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2,
          to = from + token.length
        if (line.text[to - line.from] == ' ') to++
        changes.push({ from, to })
      }
    return { changes }
  }
  return null
}
const fromHistory = /* @__PURE__ */ Annotation.define()
const isolateHistory = /* @__PURE__ */ Annotation.define()
const invertedEffects = /* @__PURE__ */ Facet.define()
const historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(
      configs,
      {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (_t, isAdjacent2) => isAdjacent2
      },
      {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
      }
    )
  }
})
const historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig)
    let fromHist = tr.annotation(fromHistory)
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection),
        from = fromHist.side
      let other = from == 0 ? state.undone : state.done
      if (item) other = updateBranch(other, other.length, config2.minDepth, item)
      else other = addSelection(other, tr.startState.selection)
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest)
    }
    let isolate = tr.annotation(isolateHistory)
    if (isolate == 'full' || isolate == 'before') state = state.isolate()
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state
    let event = HistEvent.fromTransaction(tr)
    let time = tr.annotation(Transaction.time),
      userEvent = tr.annotation(Transaction.userEvent)
    if (event) state = state.addChanges(event, time, userEvent, config2, tr)
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay)
    if (isolate == 'full' || isolate == 'after') state = state.isolate()
    return state
  },
  toJSON(value) {
    return {
      done: value.done.map((e2) => e2.toJSON()),
      undone: value.undone.map((e2) => e2.toJSON())
    }
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON))
  }
})
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e2, view) {
        let command2 =
          e2.inputType == 'historyUndo' ? undo : e2.inputType == 'historyRedo' ? redo : null
        if (!command2) return false
        e2.preventDefault()
        return command2(view)
      }
    })
  ]
}
function cmd(side, selection2) {
  return function ({ state, dispatch }) {
    if (!selection2 && state.readOnly) return false
    let historyState = state.field(historyField_, false)
    if (!historyState) return false
    let tr = historyState.pop(side, state, selection2)
    if (!tr) return false
    dispatch(tr)
    return true
  }
}
const undo = /* @__PURE__ */ cmd(0, false)
const redo = /* @__PURE__ */ cmd(1, false)
const undoSelection = /* @__PURE__ */ cmd(0, true)
const redoSelection = /* @__PURE__ */ cmd(1, true)
class HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes
    this.effects = effects
    this.mapped = mapped
    this.startSelection = startSelection
    this.selectionsAfter = selectionsAfter
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after)
  }
  toJSON() {
    var _a2, _b, _c
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    }
  }
  static fromJSON(json) {
    return new HistEvent(
      json.changes && ChangeSet.fromJSON(json.changes),
      [],
      json.mapped && ChangeDesc.fromJSON(json.mapped),
      json.startSelection && EditorSelection.fromJSON(json.startSelection),
      json.selectionsAfter.map(EditorSelection.fromJSON)
    )
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none$2
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr)
      if (result.length) effects = effects.concat(result)
    }
    if (!effects.length && tr.changes.empty) return null
    return new HistEvent(
      tr.changes.invert(tr.startState.doc),
      effects,
      void 0,
      selection2 || tr.startState.selection,
      none$2
    )
  }
  static selection(selections) {
    return new HistEvent(void 0, none$2, void 0, void 0, selections)
  }
}
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0
  let newBranch = branch.slice(start, to)
  newBranch.push(newEvent)
  return newBranch
}
function isAdjacent(a, b) {
  let ranges = [],
    isAdjacent2 = false
  a.iterChangedRanges((f, t2) => ranges.push(f, t2))
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++],
        to = ranges[i++]
      if (t2 >= from && f <= to) isAdjacent2 = true
    }
  })
  return isAdjacent2
}
function eqSelectionShape(a, b) {
  return (
    a.ranges.length == b.ranges.length &&
    a.ranges.filter((r2, i) => r2.empty != b.ranges[i].empty).length === 0
  )
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b)
}
const none$2 = []
const MaxSelectionsPerEvent = 200
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])]
  } else {
    let lastEvent = branch[branch.length - 1]
    let sels = lastEvent.selectionsAfter.slice(
      Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent)
    )
    if (sels.length && sels[sels.length - 1].eq(selection2)) return branch
    sels.push(selection2)
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels))
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1]
  let newBranch = branch.slice()
  newBranch[branch.length - 1] = last.setSelAfter(
    last.selectionsAfter.slice(0, last.selectionsAfter.length - 1)
  )
  return newBranch
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length) return branch
  let length = branch.length,
    selections = none$2
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections)
    if ((event.changes && !event.changes.empty) || event.effects.length) {
      let result = branch.slice(0, length)
      result[length - 1] = event
      return result
    } else {
      mapping = event.mapped
      length--
      selections = event.selectionsAfter
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none$2
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(
    event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none$2,
    extraSelections
  )
  if (!event.changes) return HistEvent.selection(selections)
  let mappedChanges = event.changes.map(mapping),
    before = mapping.mapDesc(event.changes, true)
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before
  return new HistEvent(
    mappedChanges,
    StateEffect.mapEffects(event.effects, mapping),
    fullMapping,
    event.startSelection.map(before),
    selections
  )
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/
class HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done
    this.undone = undone
    this.prevTime = prevTime
    this.prevUserEvent = prevUserEvent
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this
  }
  addChanges(event, time, userEvent, config2, tr) {
    let done = this.done,
      lastEvent = done[done.length - 1]
    if (
      lastEvent &&
      lastEvent.changes &&
      !lastEvent.changes.empty &&
      event.changes &&
      (!userEvent || joinableUserEvent.test(userEvent)) &&
      ((!lastEvent.selectionsAfter.length &&
        time - this.prevTime < config2.newGroupDelay &&
        config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) || // For compose (but not compose.start) events, always join with previous event
        userEvent == 'input.type.compose')
    ) {
      done = updateBranch(
        done,
        done.length - 1,
        config2.minDepth,
        new HistEvent(
          event.changes.compose(lastEvent.changes),
          conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects),
          lastEvent.mapped,
          lastEvent.startSelection,
          none$2
        )
      )
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event)
    }
    return new HistoryState(done, none$2, time, userEvent)
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$2
    if (
      last.length > 0 &&
      time - this.prevTime < newGroupDelay &&
      userEvent == this.prevUserEvent &&
      userEvent &&
      /^select($|\.)/.test(userEvent) &&
      eqSelectionShape(last[last.length - 1], selection2)
    )
      return this
    return new HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent)
  }
  addMapping(mapping) {
    return new HistoryState(
      addMappingToBranch(this.done, mapping),
      addMappingToBranch(this.undone, mapping),
      this.prevTime,
      this.prevUserEvent
    )
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone
    if (branch.length == 0) return null
    let event = branch[branch.length - 1],
      selection2 = event.selectionsAfter[0] || state.selection
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? 'select.undo' : 'select.redo',
        scrollIntoView: true
      })
    } else if (!event.changes) {
      return null
    } else {
      let rest = branch.length == 1 ? none$2 : branch.slice(0, branch.length - 1)
      if (event.mapped) rest = addMappingToBranch(rest, event.mapped)
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? 'undo' : 'redo',
        scrollIntoView: true
      })
    }
  }
}
HistoryState.empty = /* @__PURE__ */ new HistoryState(none$2, none$2)
const historyKeymap = [
  { key: 'Mod-z', run: undo, preventDefault: true },
  { key: 'Mod-y', mac: 'Mod-Shift-z', run: redo, preventDefault: true },
  { linux: 'Ctrl-Shift-z', run: redo, preventDefault: true },
  { key: 'Mod-u', run: undoSelection, preventDefault: true },
  { key: 'Alt-u', mac: 'Mod-Shift-u', run: redoSelection, preventDefault: true }
]
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex)
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: 'select' })
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how)
  if (selection2.eq(state.selection, true)) return false
  dispatch(setSel(state, selection2))
  return true
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from)
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) =>
    range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward)
  )
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR
}
const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view))
const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view))
function cursorByGroup(view, forward) {
  return moveSel(view, (range) =>
    range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward)
  )
}
const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view))
const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view))
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp)) return true
  let len = node.to - node.from
  return (
    (len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to)))) || node.firstChild
  )
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head)
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at)
    if (!next) break
    if (interestingNode(state, next, bracketProp)) pos = next
    else at = forward ? next.to : next.from
  }
  let bracket2 = pos.type.prop(bracketProp),
    match2,
    newPos
  if (
    bracket2 &&
    (match2 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) &&
    match2.matched
  )
    newPos = forward ? match2.end.to : match2.end.from
  else newPos = forward ? pos.to : pos.from
  return EditorSelection.cursor(newPos, forward ? -1 : 1)
}
const cursorSyntaxLeft = (view) =>
  moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)))
const cursorSyntaxRight = (view) =>
  moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)))
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty) return rangeEnd(range, forward)
    let moved = view.moveVertically(range, forward)
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward)
  })
}
const cursorLineUp = (view) => cursorByLine(view, false)
const cursorLineDown = (view) => cursorByLine(view, true)
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2
  let marginTop = 0,
    marginBottom = 0,
    height
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view)
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(
          margins === null || margins === void 0 ? void 0 : margins.top,
          marginTop
        )
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(
          margins === null || margins === void 0 ? void 0 : margins.bottom,
          marginBottom
        )
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  }
}
function cursorByPage(view, forward) {
  let page = pageInfo(view)
  let { state } = view,
    selection2 = updateSel(state.selection, (range) => {
      return range.empty
        ? view.moveVertically(range, forward, page.height)
        : rangeEnd(range, forward)
    })
  if (selection2.eq(state.selection)) return false
  let effect
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head)
    let scrollRect = view.scrollDOM.getBoundingClientRect()
    let scrollTop = scrollRect.top + page.marginTop,
      scrollBottom = scrollRect.bottom - page.marginBottom
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, {
        y: 'start',
        yMargin: startPos.top - scrollTop
      })
  }
  view.dispatch(setSel(state, selection2), { effects: effect })
  return true
}
const cursorPageUp = (view) => cursorByPage(view, false)
const cursorPageDown = (view) => cursorByPage(view, true)
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head),
    moved = view.moveToLineBoundary(start, forward)
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false)
  if (!forward && moved.head == line.from && line.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0]
      .length
    if (space2 && start.head != line.from + space2)
      moved = EditorSelection.cursor(line.from + space2)
  }
  return moved
}
const cursorLineBoundaryForward = (view) =>
  moveSel(view, (range) => moveByLineBoundary(view, range, true))
const cursorLineBoundaryBackward = (view) =>
  moveSel(view, (range) => moveByLineBoundary(view, range, false))
const cursorLineBoundaryLeft = (view) =>
  moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)))
const cursorLineBoundaryRight = (view) =>
  moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)))
const cursorLineStart = (view) =>
  moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1))
const cursorLineEnd = (view) =>
  moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1))
function toMatchingBracket(state, dispatch, extend) {
  let found = false,
    selection2 = updateSel(state.selection, (range) => {
      let matching =
        matchBrackets(state, range.head, -1) ||
        matchBrackets(state, range.head, 1) ||
        (range.head > 0 && matchBrackets(state, range.head - 1, 1)) ||
        (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1))
      if (!matching || !matching.end) return range
      found = true
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from
      return EditorSelection.cursor(head)
    })
  if (!found) return false
  dispatch(setSel(state, selection2))
  return true
}
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch)
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range)
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0)
  })
  if (selection2.eq(target.state.selection)) return false
  target.dispatch(setSel(target.state, selection2))
  return true
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward))
}
const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view))
const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view))
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward))
}
const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view))
const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view))
const selectSyntaxLeft = (view) =>
  extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)))
const selectSyntaxRight = (view) =>
  extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)))
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward))
}
const selectLineUp = (view) => selectByLine(view, false)
const selectLineDown = (view) => selectByLine(view, true)
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height))
}
const selectPageUp = (view) => selectByPage(view, false)
const selectPageDown = (view) => selectByPage(view, true)
const selectLineBoundaryForward = (view) =>
  extendSel(view, (range) => moveByLineBoundary(view, range, true))
const selectLineBoundaryBackward = (view) =>
  extendSel(view, (range) => moveByLineBoundary(view, range, false))
const selectLineBoundaryLeft = (view) =>
  extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)))
const selectLineBoundaryRight = (view) =>
  extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)))
const selectLineStart = (view) =>
  extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from))
const selectLineEnd = (view) =>
  extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to))
const cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }))
  return true
}
const cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }))
  return true
}
const selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }))
  return true
}
const selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }))
  return true
}
const selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: 'select' }))
  return true
}
const selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) =>
    EditorSelection.range(from, Math.min(to + 1, state.doc.length))
  )
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: 'select' }))
  return true
}
const selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state),
      stack = tree.resolveStack(range.from, 1)
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1)
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node } = cur2
      if (
        ((node.from < range.from && node.to >= range.to) ||
          (node.to > range.to && node.from <= range.from)) &&
        cur2.next
      )
        return EditorSelection.range(node.to, node.from)
    }
    return range
  })
  if (selection2.eq(state.selection)) return false
  dispatch(setSel(state, selection2))
  return true
}
const simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection,
    selection2 = null
  if (cur2.ranges.length > 1) selection2 = EditorSelection.create([cur2.main])
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)])
  if (!selection2) return false
  dispatch(setSel(state, selection2))
  return true
}
function deleteBy(target, by) {
  if (target.state.readOnly) return false
  let event = 'delete.selection',
    { state } = target
  let changes = state.changeByRange((range) => {
    let { from, to } = range
    if (from == to) {
      let towards = by(range)
      if (towards < from) {
        event = 'delete.backward'
        towards = skipAtomic(target, towards, false)
      } else if (towards > from) {
        event = 'delete.forward'
        towards = skipAtomic(target, towards, true)
      }
      from = Math.min(from, towards)
      to = Math.max(to, towards)
    } else {
      from = skipAtomic(target, from, false)
      to = skipAtomic(target, to, true)
    }
    return from == to
      ? { range }
      : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) }
  })
  if (changes.changes.empty) return false
  target.dispatch(
    state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects:
        event == 'delete.selection'
          ? EditorView.announce.of(state.phrase('Selection deleted'))
          : void 0
    })
  )
  return true
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos) pos = forward ? to : from
      })
  return pos
}
const deleteByChar = (target, forward, byIndentUnit) =>
  deleteBy(target, (range) => {
    let pos = range.from,
      { state } = target,
      line = state.doc.lineAt(pos),
      before,
      targetPos
    if (
      byIndentUnit &&
      !forward &&
      pos > line.from &&
      pos < line.from + 200 &&
      !/[^ \t]/.test((before = line.text.slice(0, pos - line.from)))
    ) {
      if (before[before.length - 1] == '	') return pos - 1
      let col = countColumn(before, state.tabSize),
        drop = col % getIndentUnit(state) || getIndentUnit(state)
      for (let i = 0; i < drop && before[before.length - 1 - i] == ' '; i++) pos--
      targetPos = pos
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
        targetPos += forward ? 1 : -1
      else if (
        !forward &&
        /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))
      )
        targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from
    }
    return targetPos
  })
const deleteCharBackward = (view) => deleteByChar(view, false, true)
const deleteCharForward = (view) => deleteByChar(view, true, false)
const deleteByGroup = (target, forward) =>
  deleteBy(target, (range) => {
    let pos = range.head,
      { state } = target,
      line = state.doc.lineAt(pos)
    let categorize = state.charCategorizer(pos)
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
          pos += forward ? 1 : -1
        break
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from
      let nextChar = line.text.slice(
        Math.min(pos, next) - line.from,
        Math.max(pos, next) - line.from
      )
      let nextCat = categorize(nextChar)
      if (cat != null && nextCat != cat) break
      if (nextChar != ' ' || pos != range.head) cat = nextCat
      pos = next
    }
    return pos
  })
const deleteGroupBackward = (target) => deleteByGroup(target, false)
const deleteGroupForward = (target) => deleteByGroup(target, true)
const deleteToLineEnd = (view) =>
  deleteBy(view, (range) => {
    let lineEnd2 = view.lineBlockAt(range.head).to
    return range.head < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, range.head + 1)
  })
const deleteLineBoundaryBackward = (view) =>
  deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, false).head
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1)
  })
const deleteLineBoundaryForward = (view) =>
  deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, true).head
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1)
  })
const splitLine = ({ state, dispatch }) => {
  if (state.readOnly) return false
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(['', '']) },
      range: EditorSelection.cursor(range.from)
    }
  })
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: 'input' }))
  return true
}
const transposeChars = ({ state, dispatch }) => {
  if (state.readOnly) return false
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length) return { range }
    let pos = range.from,
      line = state.doc.lineAt(pos)
    let from =
      pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from
    let to =
      pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    }
  })
  if (changes.changes.empty) return false
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: 'move.character' }))
  return true
}
function selectedLineBlocks(state) {
  let blocks = [],
    upto = -1
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from),
      endLine = state.doc.lineAt(range.to)
    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1)
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1]
      prev.to = endLine.to
      prev.ranges.push(range)
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] })
    }
    upto = endLine.number + 1
  }
  return blocks
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly) return false
  let changes = [],
    ranges = []
  for (let block2 of selectedLineBlocks(state)) {
    if (forward ? block2.to == state.doc.length : block2.from == 0) continue
    let nextLine = state.doc.lineAt(forward ? block2.to + 1 : block2.from - 1)
    let size = nextLine.length + 1
    if (forward) {
      changes.push(
        { from: block2.to, to: nextLine.to },
        { from: block2.from, insert: nextLine.text + state.lineBreak }
      )
      for (let r2 of block2.ranges)
        ranges.push(
          EditorSelection.range(
            Math.min(state.doc.length, r2.anchor + size),
            Math.min(state.doc.length, r2.head + size)
          )
        )
    } else {
      changes.push(
        { from: nextLine.from, to: block2.from },
        { from: block2.to, insert: state.lineBreak + nextLine.text }
      )
      for (let r2 of block2.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size, r2.head - size))
    }
  }
  if (!changes.length) return false
  dispatch(
    state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: 'move.line'
    })
  )
  return true
}
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false)
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true)
function copyLine(state, dispatch, forward) {
  if (state.readOnly) return false
  let changes = []
  for (let block2 of selectedLineBlocks(state)) {
    if (forward)
      changes.push({
        from: block2.from,
        insert: state.doc.slice(block2.from, block2.to) + state.lineBreak
      })
    else
      changes.push({
        from: block2.to,
        insert: state.lineBreak + state.doc.slice(block2.from, block2.to)
      })
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: 'input.copyline' }))
  return true
}
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false)
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true)
const deleteLine = (view) => {
  if (view.state.readOnly) return false
  let { state } = view,
    changes = state.changes(
      selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0) from--
        else if (to < state.doc.length) to++
        return { from, to }
      })
    )
  let selection2 = updateSel(state.selection, (range) => {
    let dist2 = void 0
    if (view.lineWrapping) {
      let block2 = view.lineBlockAt(range.head),
        pos = view.coordsAtPos(range.head, range.assoc || 1)
      if (pos) dist2 = block2.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2
    }
    return view.moveVertically(range, true, dist2)
  }).map(changes)
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: 'delete.line' })
  return true
}
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return { from: pos, to: pos }
  let context = syntaxTree(state).resolveInner(pos)
  let before = context.childBefore(pos),
    after = context.childAfter(pos),
    closedBy
  if (
    before &&
    after &&
    before.to <= pos &&
    after.from >= pos &&
    (closedBy = before.type.prop(NodeProp.closedBy)) &&
    closedBy.indexOf(after.name) > -1 &&
    state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
    !/\S/.test(state.sliceDoc(before.to, after.from))
  )
    return { from: before.to, to: after.from }
  return null
}
const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false)
const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true)
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly) return false
    let changes = state.changeByRange((range) => {
      let { from, to } = range,
        line = state.doc.lineAt(from)
      let explode = !atEof && from == to && isBetweenBrackets(state, from)
      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode })
      let indent = getIndentation(cx, from)
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize)
      while (to < line.to && /\s/.test(line.text[to - line.from])) to++
      if (explode) ({ from, to } = explode)
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from
      let insert2 = ['', indentString(state, indent)]
      if (explode) insert2.push(indentString(state, cx.lineIndent(line.from, -1)))
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      }
    })
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: 'input' }))
    return true
  }
}
function changeBySelectedLine(state, f) {
  let atLine = -1
  return state.changeByRange((range) => {
    let changes = []
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos)
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range)
        atLine = line.number
      }
      pos = line.to + 1
    }
    let changeSet = state.changes(changes)
    return {
      changes,
      range: EditorSelection.range(
        changeSet.mapPos(range.anchor, 1),
        changeSet.mapPos(range.head, 1)
      )
    }
  })
}
const indentSelection = ({ state, dispatch }) => {
  if (state.readOnly) return false
  let updated = /* @__PURE__ */ Object.create(null)
  let context = new IndentContext(state, {
    overrideIndentation: (start) => {
      let found = updated[start]
      return found == null ? -1 : found
    }
  })
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from)
    if (indent == null) return
    if (!/\S/.test(line.text)) indent = 0
    let cur2 = /^\s*/.exec(line.text)[0]
    let norm = indentString(state, indent)
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm })
    }
  })
  if (!changes.changes.empty) dispatch(state.update(changes, { userEvent: 'indent' }))
  return true
}
const indentMore = ({ state, dispatch }) => {
  if (state.readOnly) return false
  dispatch(
    state.update(
      changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(indentUnit) })
      }),
      { userEvent: 'input.indent' }
    )
  )
  return true
}
const indentLess = ({ state, dispatch }) => {
  if (state.readOnly) return false
  dispatch(
    state.update(
      changeBySelectedLine(state, (line, changes) => {
        let space2 = /^\s*/.exec(line.text)[0]
        if (!space2) return
        let col = countColumn(space2, state.tabSize),
          keep = 0
        let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)))
        while (
          keep < space2.length &&
          keep < insert2.length &&
          space2.charCodeAt(keep) == insert2.charCodeAt(keep)
        )
          keep++
        changes.push({
          from: line.from + keep,
          to: line.from + space2.length,
          insert: insert2.slice(keep)
        })
      }),
      { userEvent: 'delete.dedent' }
    )
  )
  return true
}
const toggleTabFocusMode = (view) => {
  view.setTabFocusMode()
  return true
}
const emacsStyleKeymap = [
  { key: 'Ctrl-b', run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: 'Ctrl-f', run: cursorCharRight, shift: selectCharRight },
  { key: 'Ctrl-p', run: cursorLineUp, shift: selectLineUp },
  { key: 'Ctrl-n', run: cursorLineDown, shift: selectLineDown },
  { key: 'Ctrl-a', run: cursorLineStart, shift: selectLineStart },
  { key: 'Ctrl-e', run: cursorLineEnd, shift: selectLineEnd },
  { key: 'Ctrl-d', run: deleteCharForward },
  { key: 'Ctrl-h', run: deleteCharBackward },
  { key: 'Ctrl-k', run: deleteToLineEnd },
  { key: 'Ctrl-Alt-h', run: deleteGroupBackward },
  { key: 'Ctrl-o', run: splitLine },
  { key: 'Ctrl-t', run: transposeChars },
  { key: 'Ctrl-v', run: cursorPageDown }
]
const standardKeymap = /* @__PURE__ */ [
  { key: 'ArrowLeft', run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  {
    key: 'Mod-ArrowLeft',
    mac: 'Alt-ArrowLeft',
    run: cursorGroupLeft,
    shift: selectGroupLeft,
    preventDefault: true
  },
  {
    mac: 'Cmd-ArrowLeft',
    run: cursorLineBoundaryLeft,
    shift: selectLineBoundaryLeft,
    preventDefault: true
  },
  { key: 'ArrowRight', run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  {
    key: 'Mod-ArrowRight',
    mac: 'Alt-ArrowRight',
    run: cursorGroupRight,
    shift: selectGroupRight,
    preventDefault: true
  },
  {
    mac: 'Cmd-ArrowRight',
    run: cursorLineBoundaryRight,
    shift: selectLineBoundaryRight,
    preventDefault: true
  },
  { key: 'ArrowUp', run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: 'Cmd-ArrowUp', run: cursorDocStart, shift: selectDocStart },
  { mac: 'Ctrl-ArrowUp', run: cursorPageUp, shift: selectPageUp },
  { key: 'ArrowDown', run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: 'Cmd-ArrowDown', run: cursorDocEnd, shift: selectDocEnd },
  { mac: 'Ctrl-ArrowDown', run: cursorPageDown, shift: selectPageDown },
  { key: 'PageUp', run: cursorPageUp, shift: selectPageUp },
  { key: 'PageDown', run: cursorPageDown, shift: selectPageDown },
  {
    key: 'Home',
    run: cursorLineBoundaryBackward,
    shift: selectLineBoundaryBackward,
    preventDefault: true
  },
  { key: 'Mod-Home', run: cursorDocStart, shift: selectDocStart },
  {
    key: 'End',
    run: cursorLineBoundaryForward,
    shift: selectLineBoundaryForward,
    preventDefault: true
  },
  { key: 'Mod-End', run: cursorDocEnd, shift: selectDocEnd },
  { key: 'Enter', run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: 'Mod-a', run: selectAll },
  { key: 'Backspace', run: deleteCharBackward, shift: deleteCharBackward },
  { key: 'Delete', run: deleteCharForward },
  { key: 'Mod-Backspace', mac: 'Alt-Backspace', run: deleteGroupBackward },
  { key: 'Mod-Delete', mac: 'Alt-Delete', run: deleteGroupForward },
  { mac: 'Mod-Backspace', run: deleteLineBoundaryBackward },
  { mac: 'Mod-Delete', run: deleteLineBoundaryForward }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })))
const defaultKeymap = /* @__PURE__ */ [
  { key: 'Alt-ArrowLeft', mac: 'Ctrl-ArrowLeft', run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  {
    key: 'Alt-ArrowRight',
    mac: 'Ctrl-ArrowRight',
    run: cursorSyntaxRight,
    shift: selectSyntaxRight
  },
  { key: 'Alt-ArrowUp', run: moveLineUp },
  { key: 'Shift-Alt-ArrowUp', run: copyLineUp },
  { key: 'Alt-ArrowDown', run: moveLineDown },
  { key: 'Shift-Alt-ArrowDown', run: copyLineDown },
  { key: 'Escape', run: simplifySelection },
  { key: 'Mod-Enter', run: insertBlankLine },
  { key: 'Alt-l', mac: 'Ctrl-l', run: selectLine },
  { key: 'Mod-i', run: selectParentSyntax, preventDefault: true },
  { key: 'Mod-[', run: indentLess },
  { key: 'Mod-]', run: indentMore },
  { key: 'Mod-Alt-\\', run: indentSelection },
  { key: 'Shift-Mod-k', run: deleteLine },
  { key: 'Shift-Mod-\\', run: cursorMatchingBracket },
  { key: 'Mod-/', run: toggleComment },
  { key: 'Alt-A', run: toggleBlockComment },
  { key: 'Ctrl-m', mac: 'Shift-Alt-m', run: toggleTabFocusMode }
].concat(standardKeymap)
const indentWithTab = { key: 'Tab', run: indentMore, shift: indentLess }
const basicNormalize =
  typeof String.prototype.normalize == 'function' ? (x2) => x2.normalize('NFKD') : (x2) => x2
class SearchCursor {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text2, query, from = 0, to = text2.length, normalize3, test2) {
    this.test = test2
    this.value = { from: 0, to: 0 }
    this.done = false
    this.matches = []
    this.buffer = ''
    this.bufferPos = 0
    this.iter = text2.iterRange(from, to)
    this.bufferStart = from
    this.normalize = normalize3 ? (x2) => normalize3(basicNormalize(x2)) : basicNormalize
    this.query = this.normalize(query)
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length
      this.iter.next()
      if (this.iter.done) return -1
      this.bufferPos = 0
      this.buffer = this.iter.value
    }
    return codePointAt(this.buffer, this.bufferPos)
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length) this.matches.pop()
    return this.nextOverlapping()
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (;;) {
      let next = this.peek()
      if (next < 0) {
        this.done = true
        return this
      }
      let str = fromCodePoint(next),
        start = this.bufferStart + this.bufferPos
      this.bufferPos += codePointSize(next)
      let norm = this.normalize(str)
      if (norm.length)
        for (let i = 0, pos = start; ; i++) {
          let code = norm.charCodeAt(i)
          let match2 = this.match(code, pos, this.bufferPos + this.bufferStart)
          if (i == norm.length - 1) {
            if (match2) {
              this.value = match2
              return this
            }
            break
          }
          if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++
        }
    }
  }
  match(code, pos, end) {
    let match2 = null
    for (let i = 0; i < this.matches.length; i += 2) {
      let index2 = this.matches[i],
        keep = false
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match2 = { from: this.matches[i + 1], to: end }
        } else {
          this.matches[i]++
          keep = true
        }
      }
      if (!keep) {
        this.matches.splice(i, 2)
        i -= 2
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1) match2 = { from: pos, to: end }
      else this.matches.push(1, pos)
    }
    if (match2 && this.test && !this.test(match2.from, match2.to, this.buffer, this.bufferStart))
      match2 = null
    return match2
  }
}
if (typeof Symbol != 'undefined')
  SearchCursor.prototype[Symbol.iterator] = function () {
    return this
  }
const empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec('') }
const baseFlags = 'gm' + (/x/.unicode == null ? '' : 'u')
class RegExpCursor {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text2, query, options, from = 0, to = text2.length) {
    this.text = text2
    this.to = to
    this.curLine = ''
    this.done = false
    this.value = empty
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text2, query, options, from, to)
    this.re = new RegExp(
      query,
      baseFlags +
        ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? 'i' : '')
    )
    this.test = options === null || options === void 0 ? void 0 : options.test
    this.iter = text2.iter()
    let startLine = text2.lineAt(from)
    this.curLineStart = startLine.from
    this.matchPos = toCharEnd(text2, from)
    this.getLine(this.curLineStart)
  }
  getLine(skip) {
    this.iter.next(skip)
    if (this.iter.lineBreak) {
      this.curLine = ''
    } else {
      this.curLine = this.iter.value
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart)
      this.iter.next()
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1
    if (this.curLineStart > this.to) this.curLine = ''
    else this.getLine(0)
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off
      let match2 = this.matchPos <= this.to && this.re.exec(this.curLine)
      if (match2) {
        let from = this.curLineStart + match2.index,
          to = from + match2[0].length
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0))
        if (from == this.curLineStart + this.curLine.length) this.nextLine()
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match2))) {
          this.value = { from, to, match: match2 }
          return this
        }
        off = this.matchPos - this.curLineStart
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine()
        off = 0
      } else {
        this.done = true
        return this
      }
    }
  }
}
const flattened = /* @__PURE__ */ new WeakMap()
class FlattenedDoc {
  constructor(from, text2) {
    this.from = from
    this.text = text2
  }
  get to() {
    return this.from + this.text.length
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2)
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new FlattenedDoc(from, doc2.sliceString(from, to))
      flattened.set(doc2, flat)
      return flat
    }
    if (cached.from == from && cached.to == to) return cached
    let { text: text2, from: cachedFrom } = cached
    if (cachedFrom > from) {
      text2 = doc2.sliceString(from, cachedFrom) + text2
      cachedFrom = from
    }
    if (cached.to < to) text2 += doc2.sliceString(cached.to, to)
    flattened.set(doc2, new FlattenedDoc(cachedFrom, text2))
    return new FlattenedDoc(from, text2.slice(from - cachedFrom, to - cachedFrom))
  }
}
class MultilineRegExpCursor {
  constructor(text2, query, options, from, to) {
    this.text = text2
    this.to = to
    this.done = false
    this.value = empty
    this.matchPos = toCharEnd(text2, from)
    this.re = new RegExp(
      query,
      baseFlags +
        ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? 'i' : '')
    )
    this.test = options === null || options === void 0 ? void 0 : options.test
    this.flat = FlattenedDoc.get(
      text2,
      from,
      this.chunkEnd(
        from + 5e3
        /* Chunk.Base */
      )
    )
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to
  }
  next() {
    for (;;) {
      let off = (this.re.lastIndex = this.matchPos - this.flat.from)
      let match2 = this.re.exec(this.flat.text)
      if (match2 && !match2[0] && match2.index == off) {
        this.re.lastIndex = off + 1
        match2 = this.re.exec(this.flat.text)
      }
      if (match2) {
        let from = this.flat.from + match2.index,
          to = from + match2[0].length
        if (
          (this.flat.to >= this.to ||
            match2.index + match2[0].length <= this.flat.text.length - 10) &&
          (!this.test || this.test(from, to, match2))
        ) {
          this.value = { from, to, match: match2 }
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0))
          return this
        }
      }
      if (this.flat.to == this.to) {
        this.done = true
        return this
      }
      this.flat = FlattenedDoc.get(
        this.text,
        this.flat.from,
        this.chunkEnd(this.flat.from + this.flat.text.length * 2)
      )
    }
  }
}
if (typeof Symbol != 'undefined') {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
    function () {
      return this
    }
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags)
    return true
  } catch (_a2) {
    return false
  }
}
function toCharEnd(text2, pos) {
  if (pos >= text2.length) return pos
  let line = text2.lineAt(pos),
    next
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++
  return pos
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number)
  let input = crelt('input', { class: 'cm-textfield', name: 'line', value: line })
  let dom = crelt(
    'form',
    {
      class: 'cm-gotoLine',
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault()
          view.dispatch({ effects: dialogEffect.of(false) })
          view.focus()
        } else if (event.keyCode == 13) {
          event.preventDefault()
          go()
        }
      },
      onsubmit: (event) => {
        event.preventDefault()
        go()
      }
    },
    crelt('label', view.state.phrase('Go to line'), ': ', input),
    ' ',
    crelt('button', { class: 'cm-button', type: 'submit' }, view.state.phrase('go')),
    crelt(
      'button',
      {
        name: 'close',
        onclick: () => {
          view.dispatch({ effects: dialogEffect.of(false) })
          view.focus()
        },
        'aria-label': view.state.phrase('close'),
        type: 'button'
      },
      ['×']
    )
  )
  function go() {
    let match2 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value)
    if (!match2) return
    let { state } = view,
      startLine = state.doc.lineAt(state.selection.main.head)
    let [, sign, ln, cl, percent2] = match2
    let col = cl ? +cl.slice(1) : 0
    let line2 = ln ? +ln : startLine.number
    if (ln && percent2) {
      let pc = line2 / 100
      if (sign) pc = pc * (sign == '-' ? -1 : 1) + startLine.number / state.doc.lines
      line2 = Math.round(state.doc.lines * pc)
    } else if (ln && sign) {
      line2 = line2 * (sign == '-' ? -1 : 1) + startLine.number
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)))
    let selection2 = EditorSelection.cursor(
      docLine.from + Math.max(0, Math.min(col, docLine.length))
    )
    view.dispatch({
      effects: [
        dialogEffect.of(false),
        EditorView.scrollIntoView(selection2.from, { y: 'center' })
      ],
      selection: selection2
    })
    view.focus()
  }
  return { dom }
}
const dialogEffect = /* @__PURE__ */ StateEffect.define()
const dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true
  },
  update(value, tr) {
    for (let e2 of tr.effects) if (e2.is(dialogEffect)) value = e2.value
    return value
  },
  provide: (f) => showPanel.from(f, (val) => (val ? createLineDialog : null))
})
const gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog)
  if (!panel) {
    let effects = [dialogEffect.of(true)]
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]))
    view.dispatch({ effects })
    panel = getPanel(view, createLineDialog)
  }
  if (panel) panel.dom.querySelector('input').select()
  return true
}
const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
  '.cm-panel.cm-gotoLine': {
    padding: '2px 6px 4px',
    position: 'relative',
    '& label': { fontSize: '80%' },
    '& [name=close]': {
      position: 'absolute',
      top: '0',
      bottom: '0',
      right: '4px',
      backgroundColor: 'inherit',
      border: 'none',
      font: 'inherit',
      padding: '0'
    }
  }
})
const selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state
  let newSel = EditorSelection.create(
    selection2.ranges.map(
      (range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)
    ),
    selection2.mainIndex
  )
  if (newSel.eq(selection2)) return false
  dispatch(state.update({ selection: newSel }))
  return true
}
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection
  let word = state.wordAt(main.head),
    fullWord = word && word.from == main.from && word.to == main.to
  for (
    let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);
    ;

  ) {
    cursor2.next()
    if (cursor2.done) {
      if (cycled) return null
      cursor2 = new SearchCursor(
        state.doc,
        query,
        0,
        Math.max(0, ranges[ranges.length - 1].from - 1)
      )
      cycled = true
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor2.value.from)) continue
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from)
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to) continue
      }
      return cursor2.value
    }
  }
}
const selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection
  if (ranges.some((sel) => sel.from === sel.to)) return selectWord({ state, dispatch })
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to)
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false
  let range = findNextOccurrence(state, searchedText)
  if (!range) return false
  dispatch(
    state.update({
      selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    })
  )
  return true
}
const searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    })
  }
})
class SearchQuery {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search
    this.caseSensitive = !!config2.caseSensitive
    this.literal = !!config2.literal
    this.regexp = !!config2.regexp
    this.replace = config2.replace || ''
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search))
    this.unquoted = this.unquote(this.search)
    this.wholeWord = !!config2.wholeWord
  }
  /**
  @internal
  */
  unquote(text2) {
    return this.literal
      ? text2
      : text2.replace(/\\([nrt\\])/g, (_2, ch) =>
          ch == 'n' ? '\n' : ch == 'r' ? '\r' : ch == 't' ? '	' : '\\'
        )
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return (
      this.search == other.search &&
      this.replace == other.replace &&
      this.caseSensitive == other.caseSensitive &&
      this.regexp == other.regexp &&
      this.wholeWord == other.wholeWord
    )
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this)
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state })
    if (to == null) to = st.doc.length
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to)
  }
}
class QueryType {
  constructor(spec) {
    this.spec = spec
  }
}
function stringCursor(spec, state, from, to) {
  return new SearchCursor(
    state.doc,
    spec.unquoted,
    from,
    to,
    spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(),
    spec.wholeWord
      ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head))
      : void 0
  )
}
function stringWordTest(doc2, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2)
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2))
    }
    return (
      (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||
        categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&
      (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||
        categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word)
    )
  }
}
class StringQuery extends QueryType {
  constructor(spec) {
    super(spec)
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping()
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length)
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping()
    }
    return cursor2.done || (cursor2.value.from == curFrom && cursor2.value.to == curTo)
      ? null
      : cursor2.value
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length)
      let cursor2 = stringCursor(this.spec, state, start, pos),
        range = null
      while (!cursor2.nextOverlapping().done) range = cursor2.value
      if (range) return range
      if (start == from) return null
      pos -= 1e4
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom)
    if (!found)
      found = this.prevMatchInRange(
        state,
        Math.max(0, curTo - this.spec.unquoted.length),
        state.doc.length
      )
    return found && (found.from != curFrom || found.to != curTo) ? found : null
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace)
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length),
      ranges = []
    while (!cursor2.next().done) {
      if (ranges.length >= limit) return null
      ranges.push(cursor2.value)
    }
    return ranges
  }
  highlight(state, from, to, add3) {
    let cursor2 = stringCursor(
      this.spec,
      state,
      Math.max(0, from - this.spec.unquoted.length),
      Math.min(to + this.spec.unquoted.length, state.doc.length)
    )
    while (!cursor2.next().done) add3(cursor2.value.from, cursor2.value.to)
  }
}
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(
    state.doc,
    spec.search,
    {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord
        ? regexpWordTest(state.charCategorizer(state.selection.main.head))
        : void 0
    },
    from,
    to
  )
}
function charBefore(str, index2) {
  return str.slice(findClusterBreak(str, index2, false), index2)
}
function charAfter(str, index2) {
  return str.slice(index2, findClusterBreak(str, index2))
}
function regexpWordTest(categorizer) {
  return (_from, _to, match2) =>
    !match2[0].length ||
    ((categorizer(charBefore(match2.input, match2.index)) != CharCategory.Word ||
      categorizer(charAfter(match2.input, match2.index)) != CharCategory.Word) &&
      (categorizer(charAfter(match2.input, match2.index + match2[0].length)) != CharCategory.Word ||
        categorizer(charBefore(match2.input, match2.index + match2[0].length)) !=
          CharCategory.Word))
}
class RegExpQuery extends QueryType {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next()
    if (cursor2.done) cursor2 = regexpCursor(this.spec, state, 0, curFrom).next()
    return cursor2.done ? null : cursor2.value
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      )
      let cursor2 = regexpCursor(this.spec, state, start, to),
        range = null
      while (!cursor2.next().done) range = cursor2.value
      if (range && (start == from || range.from > start + 10)) return range
      if (start == from) return null
    }
  }
  prevMatch(state, curFrom, curTo) {
    return (
      this.prevMatchInRange(state, 0, curFrom) ||
      this.prevMatchInRange(state, curTo, state.doc.length)
    )
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m, i) => {
      if (i == '&') return result.match[0]
      if (i == '$') return '$'
      for (let l = i.length; l > 0; l--) {
        let n2 = +i.slice(0, l)
        if (n2 > 0 && n2 < result.match.length) return result.match[n2] + i.slice(l)
      }
      return m
    })
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length),
      ranges = []
    while (!cursor2.next().done) {
      if (ranges.length >= limit) return null
      ranges.push(cursor2.value)
    }
    return ranges
  }
  highlight(state, from, to, add3) {
    let cursor2 = regexpCursor(
      this.spec,
      state,
      Math.max(
        0,
        from - 250
        /* RegExp.HighlightMargin */
      ),
      Math.min(to + 250, state.doc.length)
    )
    while (!cursor2.next().done) add3(cursor2.value.from, cursor2.value.to)
  }
}
const setSearchQuery = /* @__PURE__ */ StateEffect.define()
const togglePanel = /* @__PURE__ */ StateEffect.define()
const searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null)
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel)
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null)
    }
    return value
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
})
class SearchState {
  constructor(query, panel) {
    this.query = query
    this.panel = panel
  }
}
const matchMark = /* @__PURE__ */ Decoration.mark({ class: 'cm-searchMatch' }),
  selectedMatchMark = /* @__PURE__ */ Decoration.mark({
    class: 'cm-searchMatch cm-searchMatch-selected'
  })
const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.view = view
      this.decorations = this.highlight(view.state.field(searchState))
    }
    update(update) {
      let state = update.state.field(searchState)
      if (
        state != update.startState.field(searchState) ||
        update.docChanged ||
        update.selectionSet ||
        update.viewportChanged
      )
        this.decorations = this.highlight(state)
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid) return Decoration.none
      let { view } = this
      let builder = new RangeSetBuilder()
      for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
        let { from, to } = ranges[i]
        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250) to = ranges[++i].to
        query.highlight(view.state, from, to, (from2, to2) => {
          let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to2)
          builder.add(from2, to2, selected ? selectedMatchMark : matchMark)
        })
      }
      return builder.finish()
    }
  },
  {
    decorations: (v) => v.decorations
  }
)
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false)
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view)
  }
}
const findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { to } = view.state.selection.main
  let next = query.nextMatch(view.state, to, to)
  if (!next) return false
  let selection2 = EditorSelection.single(next.from, next.to)
  let config2 = view.state.facet(searchConfigFacet)
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection2.main, view)],
    userEvent: 'select.search'
  })
  selectSearchInput(view)
  return true
})
const findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view,
    { from } = state.selection.main
  let prev = query.prevMatch(state, from, from)
  if (!prev) return false
  let selection2 = EditorSelection.single(prev.from, prev.to)
  let config2 = view.state.facet(searchConfigFacet)
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
    userEvent: 'select.search'
  })
  selectSearchInput(view)
  return true
})
const selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3)
  if (!ranges || !ranges.length) return false
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: 'select.search.matches'
  })
  return true
})
const selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection
  if (sel.ranges.length > 1 || sel.main.empty) return false
  let { from, to } = sel.main
  let ranges = [],
    main = 0
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3) return false
    if (cur2.value.from == from) main = ranges.length
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to))
  }
  dispatch(
    state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: 'select.search.matches'
    })
  )
  return true
}
const replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view,
    { from, to } = state.selection.main
  if (state.readOnly) return false
  let match2 = query.nextMatch(state, from, from)
  if (!match2) return false
  let next = match2
  let changes = [],
    selection2,
    replacement
  let effects = []
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next))
    changes.push({ from: next.from, to: next.to, insert: replacement })
    next = query.nextMatch(state, next.from, next.to)
    effects.push(
      EditorView.announce.of(
        state.phrase('replaced match on line $', state.doc.lineAt(from).number) + '.'
      )
    )
  }
  let changeSet = view.state.changes(changes)
  if (next) {
    selection2 = EditorSelection.single(next.from, next.to).map(changeSet)
    effects.push(announceMatch(view, next))
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view))
  }
  view.dispatch({
    changes: changeSet,
    selection: selection2,
    effects,
    userEvent: 'input.replace'
  })
  return true
})
const replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly) return false
  let changes = query.matchAll(view.state, 1e9).map((match2) => {
    let { from, to } = match2
    return { from, to, insert: query.getReplacement(match2) }
  })
  if (!changes.length) return false
  let announceText = view.state.phrase('replaced $ matches', changes.length) + '.'
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: 'input.replace.all'
  })
  return true
})
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view)
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e
  let sel = state.selection.main
  let selText = sel.empty || sel.to > sel.from + 100 ? '' : state.sliceDoc(sel.from, sel.to)
  if (fallback && !selText) return fallback
  let config2 = state.facet(searchConfigFacet)
  return new SearchQuery({
    search: (
      (_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null &&
      _a2 !== void 0
        ? _a2
        : config2.literal
    )
      ? selText
      : selText.replace(/\n/g, '\\n'),
    caseSensitive:
      (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null &&
      _b !== void 0
        ? _b
        : config2.caseSensitive,
    literal:
      (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null &&
      _c !== void 0
        ? _c
        : config2.literal,
    regexp:
      (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null &&
      _d !== void 0
        ? _d
        : config2.regexp,
    wholeWord:
      (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null &&
      _e !== void 0
        ? _e
        : config2.wholeWord
  })
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel)
  return panel && panel.dom.querySelector('[main-field]')
}
function selectSearchInput(view) {
  let input = getSearchInput(view)
  if (input && input == view.root.activeElement) input.select()
}
const openSearchPanel = (view) => {
  let state = view.state.field(searchState, false)
  if (state && state.panel) {
    let searchInput = getSearchInput(view)
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec)
      if (query.valid) view.dispatch({ effects: setSearchQuery.of(query) })
      searchInput.focus()
      searchInput.select()
    }
  } else {
    view.dispatch({
      effects: [
        togglePanel.of(true),
        state
          ? setSearchQuery.of(defaultQuery(view.state, state.query.spec))
          : StateEffect.appendConfig.of(searchExtensions)
      ]
    })
  }
  return true
}
const closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false)
  if (!state || !state.panel) return false
  let panel = getPanel(view, createSearchPanel)
  if (panel && panel.dom.contains(view.root.activeElement)) view.focus()
  view.dispatch({ effects: togglePanel.of(false) })
  return true
}
const searchKeymap = [
  { key: 'Mod-f', run: openSearchPanel, scope: 'editor search-panel' },
  {
    key: 'F3',
    run: findNext,
    shift: findPrevious,
    scope: 'editor search-panel',
    preventDefault: true
  },
  {
    key: 'Mod-g',
    run: findNext,
    shift: findPrevious,
    scope: 'editor search-panel',
    preventDefault: true
  },
  { key: 'Escape', run: closeSearchPanel, scope: 'editor search-panel' },
  { key: 'Mod-Shift-l', run: selectSelectionMatches },
  { key: 'Mod-Alt-g', run: gotoLine },
  { key: 'Mod-d', run: selectNextOccurrence, preventDefault: true }
]
class SearchPanel {
  constructor(view) {
    this.view = view
    let query = (this.query = view.state.field(searchState).query.spec)
    this.commit = this.commit.bind(this)
    this.searchField = crelt('input', {
      value: query.search,
      placeholder: phrase(view, 'Find'),
      'aria-label': phrase(view, 'Find'),
      class: 'cm-textfield',
      name: 'search',
      form: '',
      'main-field': 'true',
      onchange: this.commit,
      onkeyup: this.commit
    })
    this.replaceField = crelt('input', {
      value: query.replace,
      placeholder: phrase(view, 'Replace'),
      'aria-label': phrase(view, 'Replace'),
      class: 'cm-textfield',
      name: 'replace',
      form: '',
      onchange: this.commit,
      onkeyup: this.commit
    })
    this.caseField = crelt('input', {
      type: 'checkbox',
      name: 'case',
      form: '',
      checked: query.caseSensitive,
      onchange: this.commit
    })
    this.reField = crelt('input', {
      type: 'checkbox',
      name: 're',
      form: '',
      checked: query.regexp,
      onchange: this.commit
    })
    this.wordField = crelt('input', {
      type: 'checkbox',
      name: 'word',
      form: '',
      checked: query.wholeWord,
      onchange: this.commit
    })
    function button(name2, onclick, content2) {
      return crelt('button', { class: 'cm-button', name: name2, onclick, type: 'button' }, content2)
    }
    this.dom = crelt('div', { onkeydown: (e2) => this.keydown(e2), class: 'cm-search' }, [
      this.searchField,
      button('next', () => findNext(view), [phrase(view, 'next')]),
      button('prev', () => findPrevious(view), [phrase(view, 'previous')]),
      button('select', () => selectMatches(view), [phrase(view, 'all')]),
      crelt('label', null, [this.caseField, phrase(view, 'match case')]),
      crelt('label', null, [this.reField, phrase(view, 'regexp')]),
      crelt('label', null, [this.wordField, phrase(view, 'by word')]),
      ...(view.state.readOnly
        ? []
        : [
            crelt('br'),
            this.replaceField,
            button('replace', () => replaceNext(view), [phrase(view, 'replace')]),
            button('replaceAll', () => replaceAll(view), [phrase(view, 'replace all')])
          ]),
      crelt(
        'button',
        {
          name: 'close',
          onclick: () => closeSearchPanel(view),
          'aria-label': phrase(view, 'close'),
          type: 'button'
        },
        ['×']
      )
    ])
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    })
    if (!query.eq(this.query)) {
      this.query = query
      this.view.dispatch({ effects: setSearchQuery.of(query) })
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, 'search-panel')) {
      e2.preventDefault()
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault()
      ;(e2.shiftKey ? findPrevious : findNext)(this.view)
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault()
      replaceNext(this.view)
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value)
      }
  }
  setQuery(query) {
    this.query = query
    this.searchField.value = query.search
    this.replaceField.value = query.replace
    this.caseField.checked = query.caseSensitive
    this.reField.checked = query.regexp
    this.wordField.checked = query.wholeWord
  }
  mount() {
    this.searchField.select()
  }
  get pos() {
    return 80
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top
  }
}
function phrase(view, phrase2) {
  return view.state.phrase(phrase2)
}
const AnnounceMargin = 30
const Break = /[\s\.,:;?!]/
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from),
    lineEnd2 = view.state.doc.lineAt(to).to
  let start = Math.max(line.from, from - AnnounceMargin),
    end = Math.min(lineEnd2, to + AnnounceMargin)
  let text2 = view.state.sliceDoc(start, end)
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text2[i + 1]) && Break.test(text2[i])) {
        text2 = text2.slice(i)
        break
      }
  }
  if (end != lineEnd2) {
    for (let i = text2.length - 1; i > text2.length - AnnounceMargin; i--)
      if (!Break.test(text2[i - 1]) && Break.test(text2[i])) {
        text2 = text2.slice(0, i)
        break
      }
  }
  return EditorView.announce.of(
    `${view.state.phrase('current match')}. ${text2} ${view.state.phrase('on line')} ${line.number}.`
  )
}
const baseTheme$2 = /* @__PURE__ */ EditorView.baseTheme({
  '.cm-panel.cm-search': {
    padding: '2px 6px 4px',
    position: 'relative',
    '& [name=close]': {
      position: 'absolute',
      top: '0',
      right: '4px',
      backgroundColor: 'inherit',
      border: 'none',
      font: 'inherit',
      padding: 0,
      margin: 0
    },
    '& input, & button, & label': {
      margin: '.2em .6em .2em 0'
    },
    '& input[type=checkbox]': {
      marginRight: '.2em'
    },
    '& label': {
      fontSize: '80%',
      whiteSpace: 'pre'
    }
  },
  '&light .cm-searchMatch': { backgroundColor: '#ffff0054' },
  '&dark .cm-searchMatch': { backgroundColor: '#00ffff8a' },
  '&light .cm-searchMatch-selected': { backgroundColor: '#ff6a0054' },
  '&dark .cm-searchMatch-selected': { backgroundColor: '#ff00ff8a' }
})
const searchExtensions = [searchState, /* @__PURE__ */ Prec.low(searchHighlighter), baseTheme$2]
class CompletionContext {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state
    this.pos = pos
    this.explicit = explicit
    this.view = view
    this.abortListeners = []
    this.abortOnDocChange = false
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1)
    while (token && types2.indexOf(token.name) < 0) token = token.parent
    return token
      ? {
          from: token.from,
          to: this.pos,
          text: this.state.sliceDoc(token.from, this.pos),
          type: token.type
        }
      : null
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos)
    let start = Math.max(line.from, this.pos - 250)
    let str = line.text.slice(start - line.from, this.pos - line.from)
    let found = str.search(ensureAnchor(expr, false))
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) }
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == 'abort' && this.abortListeners) {
      this.abortListeners.push(listener)
      if (options && options.onDocChange) this.abortOnDocChange = true
    }
  }
}
function toSet(chars) {
  let flat = Object.keys(chars).join('')
  let words = /\w/.test(flat)
  if (words) flat = flat.replace(/\w/g, '')
  return `[${words ? '\\w' : ''}${flat.replace(/[^\w\s]/g, '\\$&')}]`
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null),
    rest = /* @__PURE__ */ Object.create(null)
  for (let { label } of options) {
    first[label[0]] = true
    for (let i = 1; i < label.length; i++) rest[label[i]] = true
  }
  let source = toSet(first) + toSet(rest) + '*$'
  return [new RegExp('^' + source), new RegExp(source)]
}
function completeFromList(list2) {
  let options = list2.map((o) => (typeof o == 'string' ? { label: o } : o))
  let [validFor, match2] = options.every((o) => /^\w+$/.test(o.label))
    ? [/\w*$/, /\w+$/]
    : prefixMatch(options)
  return (context) => {
    let token = context.matchBefore(match2)
    return token || context.explicit
      ? { from: token ? token.from : context.pos, options, validFor }
      : null
  }
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1) return null
      if (pos.type.isTop) break
    }
    return source(context)
  }
}
class Option {
  constructor(completion, source, match2, score2) {
    this.completion = completion
    this.source = source
    this.match = match2
    this.score = score2
  }
}
function cur(state) {
  return state.selection.main.from
}
function ensureAnchor(expr, start) {
  var _a2
  let { source } = expr
  let addStart = start && source[0] != '^',
    addEnd = source[source.length - 1] != '$'
  if (!addStart && !addEnd) return expr
  return new RegExp(
    `${addStart ? '^' : ''}(?:${source})${addEnd ? '$' : ''}`,
    (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? 'i' : ''
  )
}
const pickedCompletion = /* @__PURE__ */ Annotation.define()
function insertCompletionText(state, text2, from, to) {
  let { main } = state.selection,
    fromOff = from - main.from,
    toOff = to - main.from
  return Object.assign(
    Object.assign(
      {},
      state.changeByRange((range) => {
        if (
          range != main &&
          from != to &&
          state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)
        )
          return { range }
        let lines = state.toText(text2)
        return {
          changes: {
            from: range.from + fromOff,
            to: to == main.from ? range.to : range.from + toOff,
            insert: lines
          },
          range: EditorSelection.cursor(range.from + fromOff + lines.length)
        }
      })
    ),
    { scrollIntoView: true, userEvent: 'input.complete' }
  )
}
const SourceCache = /* @__PURE__ */ new WeakMap()
function asSource(source) {
  if (!Array.isArray(source)) return source
  let known = SourceCache.get(source)
  if (!known) SourceCache.set(source, (known = completeFromList(source)))
  return known
}
const startCompletionEffect = /* @__PURE__ */ StateEffect.define()
const closeCompletionEffect = /* @__PURE__ */ StateEffect.define()
class FuzzyMatcher {
  constructor(pattern) {
    this.pattern = pattern
    this.chars = []
    this.folded = []
    this.any = []
    this.precise = []
    this.byWord = []
    this.score = 0
    this.matched = []
    for (let p = 0; p < pattern.length; ) {
      let char = codePointAt(pattern, p),
        size = codePointSize(char)
      this.chars.push(char)
      let part = pattern.slice(p, p + size),
        upper = part.toUpperCase()
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0))
      p += size
    }
    this.astral = pattern.length != this.chars.length
  }
  ret(score2, matched) {
    this.score = score2
    this.matched = matched
    return this
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0) return this.ret(-100, [])
    if (word.length < this.pattern.length) return null
    let { chars, folded, any, precise, byWord } = this
    if (chars.length == 1) {
      let first = codePointAt(word, 0),
        firstSize = codePointSize(first)
      let score2 = firstSize == word.length ? 0 : -100
      if (first == chars[0]);
      else if (first == folded[0]) score2 += -200
      else return null
      return this.ret(score2, [0, firstSize])
    }
    let direct = word.indexOf(this.pattern)
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length])
    let len = chars.length,
      anyTo = 0
    if (direct < 0) {
      for (let i = 0, e2 = Math.min(word.length, 200); i < e2 && anyTo < len; ) {
        let next = codePointAt(word, i)
        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i
        i += codePointSize(next)
      }
      if (anyTo < len) return null
    }
    let preciseTo = 0
    let byWordTo = 0,
      byWordFolded = false
    let adjacentTo = 0,
      adjacentStart = -1,
      adjacentEnd = -1
    let hasLower = /[a-z]/.test(word),
      wordAdjacent = true
    for (let i = 0, e2 = Math.min(word.length, 200), prevType = 0; i < e2 && byWordTo < len; ) {
      let next = codePointAt(word, i)
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0) adjacentStart = i
            adjacentEnd = i + 1
            adjacentTo++
          } else {
            adjacentTo = 0
          }
        }
      }
      let ch,
        type =
          next < 255
            ? (next >= 48 && next <= 57) || (next >= 97 && next <= 122)
              ? 2
              : next >= 65 && next <= 90
                ? 1
                : 0
            : (ch = fromCodePoint(next)) != ch.toLowerCase()
              ? 1
              : ch != ch.toUpperCase()
                ? 2
                : 0
      if (!i || (type == 1 && hasLower) || (prevType == 0 && type != 0)) {
        if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))
          byWord[byWordTo++] = i
        else if (byWord.length) wordAdjacent = false
      }
      prevType = type
      i += codePointSize(next)
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word)
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [
        0,
        adjacentEnd
      ])
    if (direct > -1) return this.ret(-700 - word.length, [direct, direct + this.pattern.length])
    if (adjacentTo == len) return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd])
    if (byWordTo == len)
      return this.result(
        -100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100),
        byWord,
        word
      )
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word)
  }
  result(score2, positions, word) {
    let result = [],
      i = 0
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1)
      if (i && result[i - 1] == pos) result[i - 1] = to
      else {
        result[i++] = pos
        result[i++] = to
      }
    }
    return this.ret(score2 - word.length, result)
  }
}
class StrictMatcher {
  constructor(pattern) {
    this.pattern = pattern
    this.matched = []
    this.score = 0
    this.folded = pattern.toLowerCase()
  }
  match(word) {
    if (word.length < this.pattern.length) return null
    let start = word.slice(0, this.pattern.length)
    let match2 = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null
    if (match2 == null) return null
    this.matched = [0, start.length]
    this.score = match2 + (word.length == this.pattern.length ? 0 : -100)
    return this
  }
}
const completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(
      configs,
      {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => '',
        optionClass: () => '',
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        filterStrict: false,
        compareCompletions: (a, b) => a.label.localeCompare(b.label),
        interactionDelay: 75,
        updateSyncTime: 100
      },
      {
        defaultKeymap: (a, b) => a && b,
        closeOnBlur: (a, b) => a && b,
        icons: (a, b) => a && b,
        tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
        optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
        addToOptions: (a, b) => a.concat(b),
        filterStrict: (a, b) => a || b
      }
    )
  }
})
function joinClass(a, b) {
  return a ? (b ? a + ' ' + b : a) : b
}
function defaultPositionInfo(view, list2, option, info, space2, tooltip) {
  let rtl = view.textDirection == Direction.RTL,
    left = rtl,
    narrow = false
  let side = 'top',
    offset,
    maxWidth
  let spaceLeft = list2.left - space2.left,
    spaceRight = space2.right - list2.right
  let infoWidth = info.right - info.left,
    infoHeight = info.bottom - info.top
  if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list2.top
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight)
  } else {
    narrow = true
    maxWidth = Math.min(
      400,
      (rtl ? list2.right : space2.right - list2.left) - 30
      /* Info.Margin */
    )
    let spaceBelow = space2.bottom - list2.bottom
    if (spaceBelow >= infoHeight || spaceBelow > list2.top) {
      offset = option.bottom - list2.top
    } else {
      side = 'bottom'
      offset = list2.bottom - option.top
    }
  }
  let scaleY = (list2.bottom - list2.top) / tooltip.offsetHeight
  let scaleX = (list2.right - list2.left) / tooltip.offsetWidth
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class:
      'cm-completionInfo-' +
      (narrow ? (rtl ? 'left-narrow' : 'right-narrow') : left ? 'left' : 'right')
  }
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice()
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement('div')
        icon.classList.add('cm-completionIcon')
        if (completion.type)
          icon.classList.add(
            ...completion.type.split(/\s+/g).map((cls) => 'cm-completionIcon-' + cls)
          )
        icon.setAttribute('aria-hidden', 'true')
        return icon
      },
      position: 20
    })
  content2.push(
    {
      render(completion, _s, _v, match2) {
        let labelElt = document.createElement('span')
        labelElt.className = 'cm-completionLabel'
        let label = completion.displayLabel || completion.label,
          off = 0
        for (let j = 0; j < match2.length; ) {
          let from = match2[j++],
            to = match2[j++]
          if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)))
          let span = labelElt.appendChild(document.createElement('span'))
          span.appendChild(document.createTextNode(label.slice(from, to)))
          span.className = 'cm-completionMatchedText'
          off = to
        }
        if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)))
        return labelElt
      },
      position: 50
    },
    {
      render(completion) {
        if (!completion.detail) return null
        let detailElt = document.createElement('span')
        detailElt.className = 'cm-completionDetail'
        detailElt.textContent = completion.detail
        return detailElt
      },
      position: 80
    }
  )
  return content2.sort((a, b) => a.position - b.position).map((a) => a.render)
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max) return { from: 0, to: total }
  if (selected < 0) selected = 0
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max)
    return { from: off2 * max, to: (off2 + 1) * max }
  }
  let off = Math.floor((total - selected) / max)
  return { from: total - (off + 1) * max, to: total - off * max }
}
class CompletionTooltip {
  constructor(view, stateField, applyCompletion2) {
    this.view = view
    this.stateField = stateField
    this.applyCompletion = applyCompletion2
    this.info = null
    this.infoDestroy = null
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    }
    this.space = null
    this.currentClass = ''
    let cState = view.state.field(stateField)
    let { options, selected } = cState.open
    let config2 = view.state.facet(completionConfig)
    this.optionContent = optionContent(config2)
    this.optionClass = config2.optionClass
    this.tooltipClass = config2.tooltipClass
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions)
    this.dom = document.createElement('div')
    this.dom.className = 'cm-tooltip-autocomplete'
    this.updateTooltipClass(view.state)
    this.dom.addEventListener('mousedown', (e2) => {
      let { options: options2 } = view.state.field(stateField).open
      for (let dom = e2.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
        if (
          dom.nodeName == 'LI' &&
          (match2 = /-(\d+)$/.exec(dom.id)) &&
          +match2[1] < options2.length
        ) {
          this.applyCompletion(view, options2[+match2[1]])
          e2.preventDefault()
          return
        }
      }
    })
    this.dom.addEventListener('focusout', (e2) => {
      let state = view.state.field(this.stateField, false)
      if (
        state &&
        state.tooltip &&
        view.state.facet(completionConfig).closeOnBlur &&
        e2.relatedTarget != view.contentDOM
      )
        view.dispatch({ effects: closeCompletionEffect.of(null) })
    })
    this.showOptions(options, cState.id)
  }
  mount() {
    this.updateSel()
  }
  showOptions(options, id2) {
    if (this.list) this.list.remove()
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range))
    this.list.addEventListener('scroll', () => {
      if (this.info) this.view.requestMeasure(this.placeInfoReq)
    })
  }
  update(update) {
    var _a2
    let cState = update.state.field(this.stateField)
    let prevState = update.startState.field(this.stateField)
    this.updateTooltipClass(update.state)
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(
          options.length,
          selected,
          update.state.facet(completionConfig).maxRenderedOptions
        )
        this.showOptions(options, cState.id)
      }
      this.updateSel()
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle('cm-tooltip-autocomplete-disabled', !!disabled)
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state)
    if (cls != this.currentClass) {
      for (let c of this.currentClass.split(' ')) if (c) this.dom.classList.remove(c)
      for (let c of cls.split(' ')) if (c) this.dom.classList.add(c)
      this.currentClass = cls
    }
  }
  positioned(space2) {
    this.space = space2
    if (this.info) this.view.requestMeasure(this.placeInfoReq)
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField),
      open = cState.open
    if ((open.selected > -1 && open.selected < this.range.from) || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(
        open.options.length,
        open.selected,
        this.view.state.facet(completionConfig).maxRenderedOptions
      )
      this.showOptions(open.options, cState.id)
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo()
      let { completion } = open.options[open.selected]
      let { info } = completion
      if (!info) return
      let infoResult = typeof info === 'string' ? document.createTextNode(info) : info(completion)
      if (!infoResult) return
      if ('then' in infoResult) {
        infoResult
          .then((obj) => {
            if (obj && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(obj, completion)
          })
          .catch((e2) => logException(this.view.state, e2, 'completion info'))
      } else {
        this.addInfoPane(infoResult, completion)
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo()
    let wrap = (this.info = document.createElement('div'))
    wrap.className = 'cm-tooltip cm-completionInfo'
    if (content2.nodeType != null) {
      wrap.appendChild(content2)
      this.infoDestroy = null
    } else {
      let { dom, destroy } = content2
      wrap.appendChild(dom)
      this.infoDestroy = destroy || null
    }
    this.dom.appendChild(wrap)
    this.view.requestMeasure(this.placeInfoReq)
  }
  updateSelectedOption(selected) {
    let set2 = null
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (opt.nodeName != 'LI' || !opt.id) {
        i--
      } else if (i == selected) {
        if (!opt.hasAttribute('aria-selected')) {
          opt.setAttribute('aria-selected', 'true')
          set2 = opt
        }
      } else {
        if (opt.hasAttribute('aria-selected')) opt.removeAttribute('aria-selected')
      }
    }
    if (set2) scrollIntoView(this.list, set2)
    return set2
  }
  measureInfo() {
    let sel = this.dom.querySelector('[aria-selected]')
    if (!sel || !this.info) return null
    let listRect = this.dom.getBoundingClientRect()
    let infoRect = this.info.getBoundingClientRect()
    let selRect = sel.getBoundingClientRect()
    let space2 = this.space
    if (!space2) {
      let docElt = this.dom.ownerDocument.documentElement
      space2 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight }
    }
    if (
      selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 ||
      selRect.bottom < Math.max(space2.top, listRect.top) + 10
    )
      return null
    return this.view.state
      .facet(completionConfig)
      .positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom)
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style) this.info.style.cssText = pos.style
        this.info.className = 'cm-tooltip cm-completionInfo ' + (pos.class || '')
      } else {
        this.info.style.cssText = 'top: -1e6px'
      }
    }
  }
  createListBox(options, id2, range) {
    const ul = document.createElement('ul')
    ul.id = id2
    ul.setAttribute('role', 'listbox')
    ul.setAttribute('aria-expanded', 'true')
    ul.setAttribute('aria-label', this.view.state.phrase('Completions'))
    ul.addEventListener('mousedown', (e2) => {
      if (e2.target == ul) e2.preventDefault()
    })
    let curSection = null
    for (let i = range.from; i < range.to; i++) {
      let { completion, match: match2 } = options[i],
        { section } = completion
      if (section) {
        let name2 = typeof section == 'string' ? section : section.name
        if (name2 != curSection && (i > range.from || range.from == 0)) {
          curSection = name2
          if (typeof section != 'string' && section.header) {
            ul.appendChild(section.header(section))
          } else {
            let header = ul.appendChild(document.createElement('completion-section'))
            header.textContent = name2
          }
        }
      }
      const li = ul.appendChild(document.createElement('li'))
      li.id = id2 + '-' + i
      li.setAttribute('role', 'option')
      let cls = this.optionClass(completion)
      if (cls) li.className = cls
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match2)
        if (node) li.appendChild(node)
      }
    }
    if (range.from) ul.classList.add('cm-completionListIncompleteTop')
    if (range.to < options.length) ul.classList.add('cm-completionListIncompleteBottom')
    return ul
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy) this.infoDestroy()
      this.info.remove()
      this.info = null
    }
  }
  destroy() {
    this.destroyInfo()
  }
}
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2)
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect()
  let self2 = element.getBoundingClientRect()
  let scaleY = parent.height / container.offsetHeight
  if (self2.top < parent.top) container.scrollTop -= (parent.top - self2.top) / scaleY
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY
}
function score(option) {
  return (
    (option.boost || 0) * 100 +
    (option.apply ? 10 : 0) +
    (option.info ? 5 : 0) +
    (option.type ? 1 : 0)
  )
}
function sortOptions(active, state) {
  let options = []
  let sections = null
  let addOption = (option) => {
    options.push(option)
    let { section } = option.completion
    if (section) {
      if (!sections) sections = []
      let name2 = typeof section == 'string' ? section : section.name
      if (!sections.some((s) => s.name == name2))
        sections.push(typeof section == 'string' ? { name: name2 } : section)
    }
  }
  let conf = state.facet(completionConfig)
  for (let a of active)
    if (a.hasResult()) {
      let getMatch = a.result.getMatch
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(
            new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length)
          )
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to),
          match2
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern)
        for (let option of a.result.options)
          if ((match2 = matcher.match(option.label))) {
            let matched = !option.displayLabel
              ? match2.matched
              : getMatch
                ? getMatch(option, match2.matched)
                : []
            addOption(new Option(option, a.source, matched, match2.score + (option.boost || 0)))
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null),
      pos = 0
    let cmp = (a, b) => {
      var _a2, _b
      return (
        ((_a2 = a.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) -
          ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1)
      )
    }
    for (let s of sections.sort(cmp)) {
      pos -= 1e5
      sectionOrder[s.name] = pos
    }
    for (let option of options) {
      let { section } = option.completion
      if (section) option.score += sectionOrder[typeof section == 'string' ? section : section.name]
    }
  }
  let result = [],
    prev = null
  let compare2 = conf.compareCompletions
  for (let opt of options.sort(
    (a, b) => b.score - a.score || compare2(a.completion, b.completion)
  )) {
    let cur2 = opt.completion
    if (
      !prev ||
      prev.label != cur2.label ||
      prev.detail != cur2.detail ||
      (prev.type != null && cur2.type != null && prev.type != cur2.type) ||
      prev.apply != cur2.apply ||
      prev.boost != cur2.boost
    )
      result.push(opt)
    else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt
    prev = opt.completion
  }
  return result
}
class CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options
    this.attrs = attrs
    this.tooltip = tooltip
    this.timestamp = timestamp
    this.selected = selected
    this.disabled = disabled
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length
      ? this
      : new CompletionDialog(
          this.options,
          makeAttrs(id2, selected),
          this.tooltip,
          this.timestamp,
          selected,
          this.disabled
        )
  }
  static build(active, state, id2, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s) => s.isPending)) return prev.setDisabled()
    let options = sortOptions(active, state)
    if (!options.length) return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion
      for (let i = 0; i < options.length; i++)
        if (options[i].completion == selectedValue) {
          selected = i
          break
        }
    }
    return new CompletionDialog(
      options,
      makeAttrs(id2, selected),
      {
        pos: active.reduce((a, b) => (b.hasResult() ? Math.min(a, b.from) : a), 1e8),
        create: createTooltip,
        above: conf.aboveCursor
      },
      prev ? prev.timestamp : Date.now(),
      selected,
      false
    )
  }
  map(changes) {
    return new CompletionDialog(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }),
      this.timestamp,
      this.selected,
      this.disabled
    )
  }
  setDisabled() {
    return new CompletionDialog(
      this.options,
      this.attrs,
      this.tooltip,
      this.timestamp,
      this.selected,
      true
    )
  }
}
class CompletionState {
  constructor(active, id2, open) {
    this.active = active
    this.id = id2
    this.open = open
  }
  static start() {
    return new CompletionState(
      none$1,
      'cm-ac-' + Math.floor(Math.random() * 2e6).toString(36),
      null
    )
  }
  update(tr) {
    let { state } = tr,
      conf = state.facet(completionConfig)
    let sources = conf.override || state.languageDataAt('autocomplete', cur(state)).map(asSource)
    let active = sources.map((source) => {
      let value =
        this.active.find((s) => s.source == source) ||
        new ActiveSource(
          source,
          this.active.some(
            (a) => a.state != 0
            /* State.Inactive */
          )
            ? 1
            : 0
          /* State.Inactive */
        )
      return value.update(tr, conf)
    })
    if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
      active = this.active
    let open = this.open,
      didSet = tr.effects.some((e2) => e2.is(setActiveEffect))
    if (open && tr.docChanged) open = open.map(tr.changes)
    if (
      tr.selection ||
      active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
      !sameResults(active, this.active) ||
      didSet
    )
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet)
    else if (open && open.disabled && !active.some((a) => a.isPending)) open = null
    if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult()))
      active = active.map((a) =>
        a.hasResult()
          ? new ActiveSource(
              a.source,
              0
              /* State.Inactive */
            )
          : a
      )
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id)
    return active == this.active && open == this.open
      ? this
      : new CompletionState(active, this.id, open)
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs
  }
}
function sameResults(a, b) {
  if (a == b) return true
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a.length && !a[iA].hasResult()) iA++
    while (iB < b.length && !b[iB].hasResult()) iB++
    let endA = iA == a.length,
      endB = iB == b.length
    if (endA || endB) return endA == endB
    if (a[iA++].result != b[iB++].result) return false
  }
}
const baseAttrs = {
  'aria-autocomplete': 'list'
}
const noAttrs = {}
function makeAttrs(id2, selected) {
  let result = {
    'aria-autocomplete': 'list',
    'aria-haspopup': 'listbox',
    'aria-controls': id2
  }
  if (selected > -1) result['aria-activedescendant'] = id2 + '-' + selected
  return result
}
const none$1 = []
function getUpdateType(tr, conf) {
  if (tr.isUserEvent('input.complete')) {
    let completion = tr.annotation(pickedCompletion)
    if (completion && conf.activateOnCompletion(completion)) return 4 | 8
  }
  let typing = tr.isUserEvent('input.type')
  return typing && conf.activateOnTyping
    ? 4 | 1
    : typing
      ? 1
      : tr.isUserEvent('delete.backward')
        ? 2
        : tr.selection
          ? 8
          : tr.docChanged
            ? 16
            : 0
}
class ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source
    this.state = state
    this.explicit = explicit
  }
  hasResult() {
    return false
  }
  get isPending() {
    return this.state == 1
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf),
      value = this
    if (type & 8 || (type & 16 && this.touches(tr)))
      value = new ActiveSource(
        value.source,
        0
        /* State.Inactive */
      )
    if (type & 4 && value.state == 0)
      value = new ActiveSource(
        this.source,
        1
        /* State.Pending */
      )
    value = value.updateFor(tr, type)
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1, effect.value)
      else if (effect.is(closeCompletionEffect))
        value = new ActiveSource(
          value.source,
          0
          /* State.Inactive */
        )
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value) if (active.source == value.source) value = active
      }
    }
    return value
  }
  updateFor(tr, type) {
    return this.map(tr.changes)
  }
  map(changes) {
    return this
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state))
  }
}
class ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit)
    this.limit = limit
    this.result = result
    this.from = from
    this.to = to
  }
  hasResult() {
    return true
  }
  updateFor(tr, type) {
    var _a2
    if (!(type & 3)) return this.map(tr.changes)
    let result = this.result
    if (result.map && !tr.changes.empty) result = result.map(result, tr.changes)
    let from = tr.changes.mapPos(this.from),
      to = tr.changes.mapPos(this.to, 1)
    let pos = cur(tr.state)
    if (pos > to || !result || (type & 2 && (cur(tr.startState) == this.from || pos < this.limit)))
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      )
    let limit = tr.changes.mapPos(this.limit)
    if (checkValid(result.validFor, tr.state, from, to))
      return new ActiveResult(this.source, this.explicit, limit, result, from, to)
    if (
      result.update &&
      (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false)))
    )
      return new ActiveResult(
        this.source,
        this.explicit,
        limit,
        result,
        result.from,
        (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state)
      )
    return new ActiveSource(this.source, 1, this.explicit)
  }
  map(mapping) {
    if (mapping.empty) return this
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      )
    return new ActiveResult(
      this.source,
      this.explicit,
      mapping.mapPos(this.limit),
      this.result,
      mapping.mapPos(this.from),
      mapping.mapPos(this.to, 1)
    )
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to)
  }
}
function checkValid(validFor, state, from, to) {
  if (!validFor) return false
  let text2 = state.sliceDoc(from, to)
  return typeof validFor == 'function'
    ? validFor(text2, from, to, state)
    : ensureAnchor(validFor, true).test(text2)
}
const setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s) => s.map(mapping))
  }
})
const setSelectedEffect = /* @__PURE__ */ StateEffect.define()
const completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start()
  },
  update(value, tr) {
    return value.update(tr)
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
})
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label
  let result = view.state.field(completionState).active.find((a) => a.source == option.source)
  if (!(result instanceof ActiveResult)) return false
  if (typeof apply == 'string')
    view.dispatch(
      Object.assign(
        Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)),
        { annotations: pickedCompletion.of(option.completion) }
      )
    )
  else apply(view, option.completion, result.from, result.to)
  return true
}
const createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion)
function moveCompletionSelection(forward, by = 'option') {
  return (view) => {
    let cState = view.state.field(completionState, false)
    if (
      !cState ||
      !cState.open ||
      cState.open.disabled ||
      Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay
    )
      return false
    let step = 1,
      tooltip
    if (by == 'page' && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(
        2,
        Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector('li').offsetHeight) - 1
      )
    let { length } = cState.open.options
    let selected =
      cState.open.selected > -1
        ? cState.open.selected + step * (forward ? 1 : -1)
        : forward
          ? 0
          : length - 1
    if (selected < 0) selected = by == 'page' ? 0 : length - 1
    else if (selected >= length) selected = by == 'page' ? length - 1 : 0
    view.dispatch({ effects: setSelectedEffect.of(selected) })
    return true
  }
}
const acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false)
  if (
    view.state.readOnly ||
    !cState ||
    !cState.open ||
    cState.open.selected < 0 ||
    cState.open.disabled ||
    Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay
  )
    return false
  return applyCompletion(view, cState.open.options[cState.open.selected])
}
const startCompletion = (view) => {
  let cState = view.state.field(completionState, false)
  if (!cState) return false
  view.dispatch({ effects: startCompletionEffect.of(true) })
  return true
}
const closeCompletion = (view) => {
  let cState = view.state.field(completionState, false)
  if (
    !cState ||
    !cState.active.some(
      (a) => a.state != 0
      /* State.Inactive */
    )
  )
    return false
  view.dispatch({ effects: closeCompletionEffect.of(null) })
  return true
}
class RunningQuery {
  constructor(active, context) {
    this.active = active
    this.context = context
    this.time = Date.now()
    this.updates = []
    this.done = void 0
  }
}
const MaxUpdateCount = 50,
  MinAbortTime = 1e3
const completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.view = view
      this.debounceUpdate = -1
      this.running = []
      this.debounceAccept = -1
      this.pendingStart = false
      this.composing = 0
      for (let active of view.state.field(completionState).active)
        if (active.isPending) this.startQuery(active)
    }
    update(update) {
      let cState = update.state.field(completionState)
      let conf = update.state.facet(completionConfig)
      if (
        !update.selectionSet &&
        !update.docChanged &&
        update.startState.field(completionState) == cState
      )
        return
      let doesReset = update.transactions.some((tr) => {
        let type = getUpdateType(tr, conf)
        return type & 8 || ((tr.selection || tr.docChanged) && !(type & 3))
      })
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i]
        if (
          doesReset ||
          (query.context.abortOnDocChange && update.docChanged) ||
          (query.updates.length + update.transactions.length > MaxUpdateCount &&
            Date.now() - query.time > MinAbortTime)
        ) {
          for (let handler of query.context.abortListeners) {
            try {
              handler()
            } catch (e2) {
              logException(this.view.state, e2)
            }
          }
          query.context.abortListeners = null
          this.running.splice(i--, 1)
        } else {
          query.updates.push(...update.transactions)
        }
      }
      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate)
      if (update.transactions.some((tr) => tr.effects.some((e2) => e2.is(startCompletionEffect))))
        this.pendingStart = true
      let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay
      this.debounceUpdate = cState.active.some(
        (a) => a.isPending && !this.running.some((q) => q.active.source == a.source)
      )
        ? setTimeout(() => this.startUpdate(), delay)
        : -1
      if (this.composing != 0)
        for (let tr of update.transactions) {
          if (tr.isUserEvent('input.type')) this.composing = 2
          else if (this.composing == 2 && tr.selection) this.composing = 3
        }
    }
    startUpdate() {
      this.debounceUpdate = -1
      this.pendingStart = false
      let { state } = this.view,
        cState = state.field(completionState)
      for (let active of cState.active) {
        if (active.isPending && !this.running.some((r2) => r2.active.source == active.source))
          this.startQuery(active)
      }
      if (this.running.length && cState.open && cState.open.disabled)
        this.debounceAccept = setTimeout(
          () => this.accept(),
          this.view.state.facet(completionConfig).updateSyncTime
        )
    }
    startQuery(active) {
      let { state } = this.view,
        pos = cur(state)
      let context = new CompletionContext(state, pos, active.explicit, this.view)
      let pending = new RunningQuery(active, context)
      this.running.push(pending)
      Promise.resolve(active.source(context)).then(
        (result) => {
          if (!pending.context.aborted) {
            pending.done = result || null
            this.scheduleAccept()
          }
        },
        (err) => {
          this.view.dispatch({ effects: closeCompletionEffect.of(null) })
          logException(this.view.state, err)
        }
      )
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0)) this.accept()
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(
          () => this.accept(),
          this.view.state.facet(completionConfig).updateSyncTime
        )
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
      var _a2
      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept)
      this.debounceAccept = -1
      let updated = []
      let conf = this.view.state.facet(completionConfig),
        cState = this.view.state.field(completionState)
      for (let i = 0; i < this.running.length; i++) {
        let query = this.running[i]
        if (query.done === void 0) continue
        this.running.splice(i--, 1)
        if (query.done) {
          let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state)
          let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1))
          let active = new ActiveResult(
            query.active.source,
            query.active.explicit,
            limit,
            query.done,
            query.done.from,
            (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos
          )
          for (let tr of query.updates) active = active.update(tr, conf)
          if (active.hasResult()) {
            updated.push(active)
            continue
          }
        }
        let current = cState.active.find((a) => a.source == query.active.source)
        if (current && current.isPending) {
          if (query.done == null) {
            let active = new ActiveSource(
              query.active.source,
              0
              /* State.Inactive */
            )
            for (let tr of query.updates) active = active.update(tr, conf)
            if (!active.isPending) updated.push(active)
          } else {
            this.startQuery(current)
          }
        }
      }
      if (updated.length || (cState.open && cState.open.disabled))
        this.view.dispatch({ effects: setActiveEffect.of(updated) })
    }
  },
  {
    eventHandlers: {
      blur(event) {
        let state = this.view.state.field(completionState, false)
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
          let dialog = state.open && getTooltip(this.view, state.open.tooltip)
          if (!dialog || !dialog.dom.contains(event.relatedTarget))
            setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10)
        }
      },
      compositionstart() {
        this.composing = 1
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20)
        }
        this.composing = 0
      }
    }
  }
)
const windows = typeof navigator == 'object' && /* @__PURE__ */ /Win/.test(navigator.platform)
const commitCharacters = /* @__PURE__ */ Prec.highest(
  /* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      let field = view.state.field(completionState, false)
      if (
        !field ||
        !field.open ||
        field.open.disabled ||
        field.open.selected < 0 ||
        event.key.length > 1 ||
        (event.ctrlKey && !(windows && event.altKey)) ||
        event.metaKey
      )
        return false
      let option = field.open.options[field.open.selected]
      let result = field.active.find((a) => a.source == option.source)
      let commitChars = option.completion.commitCharacters || result.result.commitCharacters
      if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option)
      return false
    }
  })
)
const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  '.cm-tooltip.cm-tooltip-autocomplete': {
    '& > ul': {
      fontFamily: 'monospace',
      whiteSpace: 'nowrap',
      overflow: 'hidden auto',
      maxWidth_fallback: '700px',
      maxWidth: 'min(700px, 95vw)',
      minWidth: '250px',
      maxHeight: '10em',
      height: '100%',
      listStyle: 'none',
      margin: 0,
      padding: 0,
      '& > li, & > completion-section': {
        padding: '1px 3px',
        lineHeight: 1.2
      },
      '& > li': {
        overflowX: 'hidden',
        textOverflow: 'ellipsis',
        cursor: 'pointer'
      },
      '& > completion-section': {
        display: 'list-item',
        borderBottom: '1px solid silver',
        paddingLeft: '0.5em',
        opacity: 0.7
      }
    }
  },
  '&light .cm-tooltip-autocomplete ul li[aria-selected]': {
    background: '#17c',
    color: 'white'
  },
  '&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
    background: '#777'
  },
  '&dark .cm-tooltip-autocomplete ul li[aria-selected]': {
    background: '#347',
    color: 'white'
  },
  '&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
    background: '#444'
  },
  '.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after': {
    content: '"···"',
    opacity: 0.5,
    display: 'block',
    textAlign: 'center'
  },
  '.cm-tooltip.cm-completionInfo': {
    position: 'absolute',
    padding: '3px 9px',
    width: 'max-content',
    maxWidth: `${400}px`,
    boxSizing: 'border-box',
    whiteSpace: 'pre-line'
  },
  '.cm-completionInfo.cm-completionInfo-left': { right: '100%' },
  '.cm-completionInfo.cm-completionInfo-right': { left: '100%' },
  '.cm-completionInfo.cm-completionInfo-left-narrow': { right: `${30}px` },
  '.cm-completionInfo.cm-completionInfo-right-narrow': { left: `${30}px` },
  '&light .cm-snippetField': { backgroundColor: '#00000022' },
  '&dark .cm-snippetField': { backgroundColor: '#ffffff22' },
  '.cm-snippetFieldPosition': {
    verticalAlign: 'text-top',
    width: 0,
    height: '1.15em',
    display: 'inline-block',
    margin: '0 -0.7px -.7em',
    borderLeft: '1.4px dotted #888'
  },
  '.cm-completionMatchedText': {
    textDecoration: 'underline'
  },
  '.cm-completionDetail': {
    marginLeft: '0.5em',
    fontStyle: 'italic'
  },
  '.cm-completionIcon': {
    fontSize: '90%',
    width: '.8em',
    display: 'inline-block',
    textAlign: 'center',
    paddingRight: '.6em',
    opacity: '0.6',
    boxSizing: 'content-box'
  },
  '.cm-completionIcon-function, .cm-completionIcon-method': {
    '&:after': { content: "'ƒ'" }
  },
  '.cm-completionIcon-class': {
    '&:after': { content: "'○'" }
  },
  '.cm-completionIcon-interface': {
    '&:after': { content: "'◌'" }
  },
  '.cm-completionIcon-variable': {
    '&:after': { content: "'𝑥'" }
  },
  '.cm-completionIcon-constant': {
    '&:after': { content: "'𝐶'" }
  },
  '.cm-completionIcon-type': {
    '&:after': { content: "'𝑡'" }
  },
  '.cm-completionIcon-enum': {
    '&:after': { content: "'∪'" }
  },
  '.cm-completionIcon-property': {
    '&:after': { content: "'□'" }
  },
  '.cm-completionIcon-keyword': {
    '&:after': { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  '.cm-completionIcon-namespace': {
    '&:after': { content: "'▢'" }
  },
  '.cm-completionIcon-text': {
    '&:after': { content: "'abc'", fontSize: '50%', verticalAlign: 'middle' }
  }
})
class FieldPos {
  constructor(field, line, from, to) {
    this.field = field
    this.line = line
    this.from = from
    this.to = to
  }
}
class FieldRange {
  constructor(field, from, to) {
    this.field = field
    this.from = from
    this.to = to
  }
  map(changes) {
    let from = changes.mapPos(this.from, -1, MapMode.TrackDel)
    let to = changes.mapPos(this.to, 1, MapMode.TrackDel)
    return from == null || to == null ? null : new FieldRange(this.field, from, to)
  }
}
class Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines
    this.fieldPositions = fieldPositions
  }
  instantiate(state, pos) {
    let text2 = [],
      lineStart = [pos]
    let lineObj = state.doc.lineAt(pos),
      baseIndent = /^\s*/.exec(lineObj.text)[0]
    for (let line of this.lines) {
      if (text2.length) {
        let indent = baseIndent,
          tabs = /^\t*/.exec(line)[0].length
        for (let i = 0; i < tabs; i++) indent += state.facet(indentUnit)
        lineStart.push(pos + indent.length - tabs)
        line = indent + line.slice(tabs)
      }
      text2.push(line)
      pos += line.length + 1
    }
    let ranges = this.fieldPositions.map(
      (pos2) =>
        new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to)
    )
    return { text: text2, ranges }
  }
  static parse(template2) {
    let fields = []
    let lines = [],
      positions = [],
      m
    for (let line of template2.split(/\r\n?|\n/)) {
      while ((m = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line))) {
        let seq = m[1] ? +m[1] : null,
          rawName = m[2] || m[3] || '',
          found = -1
        let name2 = rawName.replace(/\\[{}]/g, (m2) => m2[1])
        for (let i = 0; i < fields.length; i++) {
          if (seq != null ? fields[i].seq == seq : name2 ? fields[i].name == name2 : false)
            found = i
        }
        if (found < 0) {
          let i = 0
          while (
            i < fields.length &&
            (seq == null || (fields[i].seq != null && fields[i].seq < seq))
          )
            i++
          fields.splice(i, 0, { seq, name: name2 })
          found = i
          for (let pos of positions) if (pos.field >= found) pos.field++
        }
        positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length))
        line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length)
      }
      line = line.replace(/\\([{}])/g, (_2, brace, index2) => {
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > index2) {
            pos.from--
            pos.to--
          }
        return brace
      })
      lines.push(line)
    }
    return new Snippet(lines, positions)
  }
}
let fieldMarker = /* @__PURE__ */ Decoration.widget({
  widget: /* @__PURE__ */ new (class extends WidgetType {
    toDOM() {
      let span = document.createElement('span')
      span.className = 'cm-snippetFieldPosition'
      return span
    }
    ignoreEvent() {
      return false
    }
  })()
})
let fieldRange = /* @__PURE__ */ Decoration.mark({ class: 'cm-snippetField' })
class ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges
    this.active = active
    this.deco = Decoration.set(
      ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to))
    )
  }
  map(changes) {
    let ranges = []
    for (let r2 of this.ranges) {
      let mapped = r2.map(changes)
      if (!mapped) return null
      ranges.push(mapped)
    }
    return new ActiveSnippet(ranges, this.active)
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) =>
      this.ranges.some(
        (r2) => r2.field == this.active && r2.from <= range.from && r2.to >= range.to
      )
    )
  }
}
const setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes)
  }
})
const moveToField = /* @__PURE__ */ StateEffect.define()
const snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive)) return effect.value
      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value)
    }
    if (value && tr.docChanged) value = value.map(tr.changes)
    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null
    return value
  },
  provide: (f) => EditorView.decorations.from(f, (val) => (val ? val.deco : Decoration.none))
})
function fieldSelection(ranges, field) {
  return EditorSelection.create(
    ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to))
  )
}
function snippet(template2) {
  let snippet2 = Snippet.parse(template2)
  return (editor, completion, from, to) => {
    let { text: text2, ranges } = snippet2.instantiate(editor.state, from)
    let { main } = editor.state.selection
    let spec = {
      changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text2) },
      scrollIntoView: true,
      annotations: completion
        ? [pickedCompletion.of(completion), Transaction.userEvent.of('input.complete')]
        : void 0
    }
    if (ranges.length) spec.selection = fieldSelection(ranges, 0)
    if (ranges.some((r2) => r2.field > 0)) {
      let active = new ActiveSnippet(ranges, 0)
      let effects = (spec.effects = [setActive.of(active)])
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(
          StateEffect.appendConfig.of([
            snippetState,
            addSnippetKeymap,
            snippetPointerHandler,
            baseTheme
          ])
        )
    }
    editor.dispatch(editor.state.update(spec))
  }
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false)
    if (!active || (dir < 0 && active.active == 0)) return false
    let next = active.active + dir,
      last = dir > 0 && !active.ranges.some((r2) => r2.field == next + dir)
    dispatch(
      state.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
        scrollIntoView: true
      })
    )
    return true
  }
}
const clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false)
  if (!active) return false
  dispatch(state.update({ effects: setActive.of(null) }))
  return true
}
const nextSnippetField = /* @__PURE__ */ moveField(1)
const prevSnippetField = /* @__PURE__ */ moveField(-1)
const defaultSnippetKeymap = [
  { key: 'Tab', run: nextSnippetField, shift: prevSnippetField },
  { key: 'Escape', run: clearSnippet }
]
const snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap
  }
})
const addSnippetKeymap = /* @__PURE__ */ Prec.highest(
  /* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap))
)
function snippetCompletion(template2, completion) {
  return Object.assign(Object.assign({}, completion), { apply: snippet(template2) })
}
const snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false),
      pos
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false
    let match2 = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos)
    if (!match2 || match2.field == active.active) return false
    view.dispatch({
      selection: fieldSelection(active.ranges, match2.field),
      effects: setActive.of(
        active.ranges.some((r2) => r2.field > match2.field)
          ? new ActiveSnippet(active.ranges, match2.field)
          : null
      ),
      scrollIntoView: true
    })
    return true
  }
})
const closedBracket = /* @__PURE__ */ new (class extends RangeValue {})()
closedBracket.startSide = 1
closedBracket.endSide = -1
function autocompletion(config2 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme
  ]
}
const completionKeymap = [
  { key: 'Ctrl-Space', run: startCompletion },
  { mac: 'Alt-`', run: startCompletion },
  { key: 'Escape', run: closeCompletion },
  { key: 'ArrowDown', run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: 'ArrowUp', run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: 'PageDown', run: /* @__PURE__ */ moveCompletionSelection(true, 'page') },
  { key: 'PageUp', run: /* @__PURE__ */ moveCompletionSelection(false, 'page') },
  { key: 'Enter', run: acceptCompletion }
]
const completionKeymapExt = /* @__PURE__ */ Prec.highest(
  /* @__PURE__ */ keymap.computeN([completionConfig], (state) =>
    state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []
  )
)
function legacy(parser2) {
  return new LanguageSupport(StreamLanguage.define(parser2))
}
function sql(dialectName) {
  return __vitePreload(
    () => import('./index-jMCgefF-.js'),
    true ? __vite__mapDeps([0, 1, 2]) : void 0,
    import.meta.url
  ).then((m) => m.sql({ dialect: m[dialectName] }))
}
const languages = [
  // New-style language modes
  /* @__PURE__ */ LanguageDescription.of({
    name: 'C',
    extensions: ['c', 'h', 'ino'],
    load() {
      return __vitePreload(
        () => import('./index-CSbRCW7e.js'),
        true ? __vite__mapDeps([3, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.cpp())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'C++',
    alias: ['cpp'],
    extensions: ['cpp', 'c++', 'cc', 'cxx', 'hpp', 'h++', 'hh', 'hxx'],
    load() {
      return __vitePreload(
        () => import('./index-CSbRCW7e.js'),
        true ? __vite__mapDeps([3, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.cpp())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'CQL',
    alias: ['cassandra'],
    extensions: ['cql'],
    load() {
      return sql('Cassandra')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'CSS',
    extensions: ['css'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$3),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.css())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Go',
    extensions: ['go'],
    load() {
      return __vitePreload(
        () => import('./index-BSjlmN_j.js'),
        true ? __vite__mapDeps([4, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.go())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'HTML',
    alias: ['xhtml'],
    extensions: ['html', 'htm', 'handlebars', 'hbs'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$1),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.html())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Java',
    extensions: ['java'],
    load() {
      return __vitePreload(
        () => import('./index-DwAlBAzC.js'),
        true ? __vite__mapDeps([5, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.java())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'JavaScript',
    alias: ['ecmascript', 'js', 'node'],
    extensions: ['js', 'mjs', 'cjs'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$2),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.javascript())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'JSON',
    alias: ['json5'],
    extensions: ['json', 'map'],
    load() {
      return __vitePreload(
        () => import('./index-CHqsOsLh.js'),
        true ? __vite__mapDeps([6, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.json())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'JSX',
    extensions: ['jsx'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$2),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.javascript({ jsx: true }))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'LESS',
    extensions: ['less'],
    load() {
      return __vitePreload(
        () => import('./index-CRoXZydy.js'),
        true ? __vite__mapDeps([7, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.less())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Liquid',
    extensions: ['liquid'],
    load() {
      return __vitePreload(
        () => import('./index-DK-86nzt.js'),
        true ? __vite__mapDeps([8, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.liquid())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MariaDB SQL',
    load() {
      return sql('MariaSQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Markdown',
    extensions: ['md', 'markdown', 'mkd'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.markdown())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MS SQL',
    load() {
      return sql('MSSQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MySQL',
    load() {
      return sql('MySQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'PHP',
    extensions: ['php', 'php3', 'php4', 'php5', 'php7', 'phtml'],
    load() {
      return __vitePreload(
        () => import('./index-l_kxj-Qp.js'),
        true ? __vite__mapDeps([9, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.php())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'PLSQL',
    extensions: ['pls'],
    load() {
      return sql('PLSQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'PostgreSQL',
    load() {
      return sql('PostgreSQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Python',
    extensions: ['BUILD', 'bzl', 'py', 'pyw'],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return __vitePreload(
        () => import('./index-fP7_3oki.js'),
        true ? __vite__mapDeps([10, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.python())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Rust',
    extensions: ['rs'],
    load() {
      return __vitePreload(
        () => import('./index-BuwiCW2_.js'),
        true ? __vite__mapDeps([11, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.rust())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Sass',
    extensions: ['sass'],
    load() {
      return __vitePreload(
        () => import('./index-ClD5AWZd.js'),
        true ? __vite__mapDeps([12, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.sass({ indented: true }))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SCSS',
    extensions: ['scss'],
    load() {
      return __vitePreload(
        () => import('./index-ClD5AWZd.js'),
        true ? __vite__mapDeps([12, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.sass())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SQL',
    extensions: ['sql'],
    load() {
      return sql('StandardSQL')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SQLite',
    load() {
      return sql('SQLite')
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TSX',
    extensions: ['tsx'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$2),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.javascript({ jsx: true, typescript: true }))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TypeScript',
    alias: ['ts'],
    extensions: ['ts', 'mts', 'cts'],
    load() {
      return __vitePreload(
        () => Promise.resolve().then(() => index$2),
        true ? void 0 : void 0,
        import.meta.url
      ).then((m) => m.javascript({ typescript: true }))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'WebAssembly',
    extensions: ['wat', 'wast'],
    load() {
      return __vitePreload(
        () => import('./index-Cc7Zf0nm.js'),
        true ? __vite__mapDeps([13, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.wast())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'XML',
    alias: ['rss', 'wsdl', 'xsd'],
    extensions: ['xml', 'xsl', 'xsd', 'svg'],
    load() {
      return __vitePreload(
        () => import('./index-DMAWZZQR.js'),
        true ? __vite__mapDeps([14, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.xml())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'YAML',
    alias: ['yml'],
    extensions: ['yaml', 'yml'],
    load() {
      return __vitePreload(
        () => import('./index-C5rrPrtW.js'),
        true ? __vite__mapDeps([15, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.yaml())
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ LanguageDescription.of({
    name: 'APL',
    extensions: ['dyalog', 'apl'],
    load() {
      return __vitePreload(
        () => import('./apl-fqmucPXA.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.apl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'PGP',
    alias: ['asciiarmor'],
    extensions: ['asc', 'pgp', 'sig'],
    load() {
      return __vitePreload(
        () => import('./asciiarmor-DucZyvP0.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.asciiArmor))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'ASN.1',
    extensions: ['asn', 'asn1'],
    load() {
      return __vitePreload(
        () => import('./asn1-BnOEsgAm.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.asn1({})))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Asterisk',
    filename: /^extensions\.conf$/i,
    load() {
      return __vitePreload(
        () => import('./asterisk-QAlztEwS.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.asterisk))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Brainfuck',
    extensions: ['b', 'bf'],
    load() {
      return __vitePreload(
        () => import('./brainfuck-DZVCuF_t.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.brainfuck))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Cobol',
    extensions: ['cob', 'cpy'],
    load() {
      return __vitePreload(
        () => import('./cobol-4yqQntpt.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.cobol))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'C#',
    alias: ['csharp', 'cs'],
    extensions: ['cs'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.csharp))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Clojure',
    extensions: ['clj', 'cljc', 'cljx'],
    load() {
      return __vitePreload(
        () => import('./clojure-BhXMqnxz.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.clojure))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'ClojureScript',
    extensions: ['cljs'],
    load() {
      return __vitePreload(
        () => import('./clojure-BhXMqnxz.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.clojure))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Closure Stylesheets (GSS)',
    extensions: ['gss'],
    load() {
      return __vitePreload(
        () => import('./css-c-jst79C.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.gss))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'CMake',
    extensions: ['cmake', 'cmake.in'],
    filename: /^CMakeLists\.txt$/,
    load() {
      return __vitePreload(
        () => import('./cmake-BGaNd9E7.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.cmake))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'CoffeeScript',
    alias: ['coffee', 'coffee-script'],
    extensions: ['coffee'],
    load() {
      return __vitePreload(
        () => import('./coffeescript-D2dXvhEc.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.coffeeScript))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Common Lisp',
    alias: ['lisp'],
    extensions: ['cl', 'lisp', 'el'],
    load() {
      return __vitePreload(
        () => import('./commonlisp-CF_VNHQR.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.commonLisp))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Cypher',
    extensions: ['cyp', 'cypher'],
    load() {
      return __vitePreload(
        () => import('./cypher-Dlu_3r4V.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.cypher))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Cython',
    extensions: ['pyx', 'pxd', 'pxi'],
    load() {
      return __vitePreload(
        () => import('./python-CvWbmiX4.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.cython))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Crystal',
    extensions: ['cr'],
    load() {
      return __vitePreload(
        () => import('./crystal-DyuLTqLs.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.crystal))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'D',
    extensions: ['d'],
    load() {
      return __vitePreload(
        () => import('./d-UURgV0Ux.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.d))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Dart',
    extensions: ['dart'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.dart))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'diff',
    extensions: ['diff', 'patch'],
    load() {
      return __vitePreload(
        () => import('./diff-B_Bi2Crb.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.diff))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Dockerfile',
    filename: /^Dockerfile$/,
    load() {
      return __vitePreload(
        () => import('./dockerfile-DUNqykAP.js'),
        true ? __vite__mapDeps([16, 17]) : void 0,
        import.meta.url
      ).then((m) => legacy(m.dockerFile))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'DTD',
    extensions: ['dtd'],
    load() {
      return __vitePreload(
        () => import('./dtd-Dy74G54E.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.dtd))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Dylan',
    extensions: ['dylan', 'dyl', 'intr'],
    load() {
      return __vitePreload(
        () => import('./dylan-TSb-Nfix.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.dylan))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'EBNF',
    load() {
      return __vitePreload(
        () => import('./ebnf-4fKAGW3a.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ebnf))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'ECL',
    extensions: ['ecl'],
    load() {
      return __vitePreload(
        () => import('./ecl-B59qGGVg.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ecl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'edn',
    extensions: ['edn'],
    load() {
      return __vitePreload(
        () => import('./clojure-BhXMqnxz.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.clojure))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Eiffel',
    extensions: ['e'],
    load() {
      return __vitePreload(
        () => import('./eiffel-Dze7nlu3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.eiffel))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Elm',
    extensions: ['elm'],
    load() {
      return __vitePreload(
        () => import('./elm-DG7jkhNZ.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.elm))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Erlang',
    extensions: ['erl'],
    load() {
      return __vitePreload(
        () => import('./erlang-BO6gOnGA.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.erlang))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Esper',
    load() {
      return __vitePreload(
        () => import('./sql-BSrOzCRI.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.esper))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Factor',
    extensions: ['factor'],
    load() {
      return __vitePreload(
        () => import('./factor-BqI9_rff.js'),
        true ? __vite__mapDeps([18, 17]) : void 0,
        import.meta.url
      ).then((m) => legacy(m.factor))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'FCL',
    load() {
      return __vitePreload(
        () => import('./fcl-CDDUNjTj.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.fcl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Forth',
    extensions: ['forth', 'fth', '4th'],
    load() {
      return __vitePreload(
        () => import('./forth-B9D2JCeE.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.forth))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Fortran',
    extensions: ['f', 'for', 'f77', 'f90', 'f95'],
    load() {
      return __vitePreload(
        () => import('./fortran-CAG2BFbe.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.fortran))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'F#',
    alias: ['fsharp'],
    extensions: ['fs'],
    load() {
      return __vitePreload(
        () => import('./mllike-DHn7xckP.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.fSharp))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Gas',
    extensions: ['s'],
    load() {
      return __vitePreload(
        () => import('./gas-d3KEcW3x.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.gas))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Gherkin',
    extensions: ['feature'],
    load() {
      return __vitePreload(
        () => import('./gherkin-DhZlEZiy.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.gherkin))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Groovy',
    extensions: ['groovy', 'gradle'],
    filename: /^Jenkinsfile$/,
    load() {
      return __vitePreload(
        () => import('./groovy-CpwJiBl7.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.groovy))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Haskell',
    extensions: ['hs'],
    load() {
      return __vitePreload(
        () => import('./haskell-BlGBCCe3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.haskell))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Haxe',
    extensions: ['hx'],
    load() {
      return __vitePreload(
        () => import('./haxe-7MlzfeYV.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.haxe))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'HXML',
    extensions: ['hxml'],
    load() {
      return __vitePreload(
        () => import('./haxe-7MlzfeYV.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.hxml))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'HTTP',
    load() {
      return __vitePreload(
        () => import('./http-BqypyemW.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.http))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'IDL',
    extensions: ['pro'],
    load() {
      return __vitePreload(
        () => import('./idl-4HIGJlDI.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.idl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'JSON-LD',
    alias: ['jsonld'],
    extensions: ['jsonld'],
    load() {
      return __vitePreload(
        () => import('./javascript-C3MnDRiU.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.jsonld))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Jinja2',
    extensions: ['j2', 'jinja', 'jinja2'],
    load() {
      return __vitePreload(
        () => import('./jinja2-2Vo2sGef.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.jinja2))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Julia',
    extensions: ['jl'],
    load() {
      return __vitePreload(
        () => import('./julia-Bs6JJhYG.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.julia))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Kotlin',
    extensions: ['kt', 'kts'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.kotlin))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'LiveScript',
    alias: ['ls'],
    extensions: ['ls'],
    load() {
      return __vitePreload(
        () => import('./livescript-DmzgM3Yt.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.liveScript))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Lua',
    extensions: ['lua'],
    load() {
      return __vitePreload(
        () => import('./lua-8cJgIlqe.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.lua))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'mIRC',
    extensions: ['mrc'],
    load() {
      return __vitePreload(
        () => import('./mirc-Dma3B8rS.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.mirc))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Mathematica',
    extensions: ['m', 'nb', 'wl', 'wls'],
    load() {
      return __vitePreload(
        () => import('./mathematica-DNLOL9PQ.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.mathematica))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Modelica',
    extensions: ['mo'],
    load() {
      return __vitePreload(
        () => import('./modelica-0d55jYY0.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.modelica))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MUMPS',
    extensions: ['mps'],
    load() {
      return __vitePreload(
        () => import('./mumps-Btr8VblO.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.mumps))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Mbox',
    extensions: ['mbox'],
    load() {
      return __vitePreload(
        () => import('./mbox-Ga7d4MMN.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.mbox))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Nginx',
    filename: /nginx.*\.conf$/i,
    load() {
      return __vitePreload(
        () => import('./nginx-DTDtBDVN.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.nginx))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'NSIS',
    extensions: ['nsh', 'nsi'],
    load() {
      return __vitePreload(
        () => import('./nsis-BbZeYEiA.js'),
        true ? __vite__mapDeps([19, 17]) : void 0,
        import.meta.url
      ).then((m) => legacy(m.nsis))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'NTriples',
    extensions: ['nt', 'nq'],
    load() {
      return __vitePreload(
        () => import('./ntriples-CvgOYMpL.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ntriples))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Objective-C',
    alias: ['objective-c', 'objc'],
    extensions: ['m'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.objectiveC))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Objective-C++',
    alias: ['objective-c++', 'objc++'],
    extensions: ['mm'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.objectiveCpp))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'OCaml',
    extensions: ['ml', 'mli', 'mll', 'mly'],
    load() {
      return __vitePreload(
        () => import('./mllike-DHn7xckP.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.oCaml))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Octave',
    extensions: ['m'],
    load() {
      return __vitePreload(
        () => import('./octave-DYBj3-tl.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.octave))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Oz',
    extensions: ['oz'],
    load() {
      return __vitePreload(
        () => import('./oz-R_e8WMIi.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.oz))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Pascal',
    extensions: ['p', 'pas'],
    load() {
      return __vitePreload(
        () => import('./pascal-GD8iposT.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.pascal))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Perl',
    extensions: ['pl', 'pm'],
    load() {
      return __vitePreload(
        () => import('./perl-DL9mHpoi.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.perl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Pig',
    extensions: ['pig'],
    load() {
      return __vitePreload(
        () => import('./pig-C_4T4YIV.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.pig))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'PowerShell',
    extensions: ['ps1', 'psd1', 'psm1'],
    load() {
      return __vitePreload(
        () => import('./powershell-B0suO7Vd.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.powerShell))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Properties files',
    alias: ['ini', 'properties'],
    extensions: ['properties', 'ini', 'in'],
    load() {
      return __vitePreload(
        () => import('./properties-BR-vP1aU.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.properties))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'ProtoBuf',
    extensions: ['proto'],
    load() {
      return __vitePreload(
        () => import('./protobuf-BxgpyhoW.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.protobuf))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Pug',
    alias: ['jade'],
    extensions: ['pug', 'jade'],
    load() {
      return __vitePreload(
        () => import('./pug-By0kVCfm.js'),
        true ? __vite__mapDeps([20, 21]) : void 0,
        import.meta.url
      ).then((m) => legacy(m.pug))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Puppet',
    extensions: ['pp'],
    load() {
      return __vitePreload(
        () => import('./puppet-Bdao66PW.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.puppet))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Q',
    extensions: ['q'],
    load() {
      return __vitePreload(
        () => import('./q-819KmTeu.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.q))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'R',
    alias: ['rscript'],
    extensions: ['r', 'R'],
    load() {
      return __vitePreload(
        () => import('./r-V7nswm59.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.r))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'RPM Changes',
    load() {
      return __vitePreload(
        () => import('./rpm-C-DLY-If.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.rpmChanges))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'RPM Spec',
    extensions: ['spec'],
    load() {
      return __vitePreload(
        () => import('./rpm-C-DLY-If.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.rpmSpec))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Ruby',
    alias: ['jruby', 'macruby', 'rake', 'rb', 'rbx'],
    extensions: ['rb'],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return __vitePreload(
        () => import('./ruby-JDKLJNK0.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ruby))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SAS',
    extensions: ['sas'],
    load() {
      return __vitePreload(
        () => import('./sas-D2UG-yhZ.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.sas))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Scala',
    extensions: ['scala'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.scala))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Scheme',
    extensions: ['scm', 'ss'],
    load() {
      return __vitePreload(
        () => import('./scheme-BKzrkGJD.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.scheme))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Shell',
    alias: ['bash', 'sh', 'zsh'],
    extensions: ['sh', 'ksh', 'bash'],
    filename: /^PKGBUILD$/,
    load() {
      return __vitePreload(
        () => import('./shell-BlsXDxCn.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.shell))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Sieve',
    extensions: ['siv', 'sieve'],
    load() {
      return __vitePreload(
        () => import('./sieve-CjwBwOY5.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.sieve))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Smalltalk',
    extensions: ['st'],
    load() {
      return __vitePreload(
        () => import('./smalltalk-BOIGQuhN.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.smalltalk))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Solr',
    load() {
      return __vitePreload(
        () => import('./solr-CwD7U71z.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.solr))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SML',
    extensions: ['sml', 'sig', 'fun', 'smackspec'],
    load() {
      return __vitePreload(
        () => import('./mllike-DHn7xckP.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.sml))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SPARQL',
    alias: ['sparul'],
    extensions: ['rq', 'sparql'],
    load() {
      return __vitePreload(
        () => import('./sparql-DYskk2vE.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.sparql))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Spreadsheet',
    alias: ['excel', 'formula'],
    load() {
      return __vitePreload(
        () => import('./spreadsheet-Bgtt3oLP.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.spreadsheet))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Squirrel',
    extensions: ['nut'],
    load() {
      return __vitePreload(
        () => import('./clike-DaICHkS3.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.squirrel))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Stylus',
    extensions: ['styl'],
    load() {
      return __vitePreload(
        () => import('./stylus-BkS-boTH.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.stylus))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Swift',
    extensions: ['swift'],
    load() {
      return __vitePreload(
        () => import('./swift-FRZi1uvB.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.swift))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'sTeX',
    load() {
      return __vitePreload(
        () => import('./stex-B6LNC55o.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.stex))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'LaTeX',
    alias: ['tex'],
    extensions: ['text', 'ltx', 'tex'],
    load() {
      return __vitePreload(
        () => import('./stex-B6LNC55o.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.stex))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'SystemVerilog',
    extensions: ['v', 'sv', 'svh'],
    load() {
      return __vitePreload(
        () => import('./verilog-DDCYnHN8.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.verilog))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Tcl',
    extensions: ['tcl'],
    load() {
      return __vitePreload(
        () => import('./tcl-CUcaCdmq.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.tcl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Textile',
    extensions: ['textile'],
    load() {
      return __vitePreload(
        () => import('./textile-BnFpjsrl.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.textile))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TiddlyWiki',
    load() {
      return __vitePreload(
        () => import('./tiddlywiki-CjprD-Qp.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.tiddlyWiki))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Tiki wiki',
    load() {
      return __vitePreload(
        () => import('./tiki-DK9DOeWn.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.tiki))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TOML',
    extensions: ['toml'],
    load() {
      return __vitePreload(
        () => import('./toml-CrLTxh7K.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.toml))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Troff',
    extensions: ['1', '2', '3', '4', '5', '6', '7', '8', '9'],
    load() {
      return __vitePreload(
        () => import('./troff-E1bJ0PPL.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.troff))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TTCN',
    extensions: ['ttcn', 'ttcn3', 'ttcnpp'],
    load() {
      return __vitePreload(
        () => import('./ttcn-tKd4HLu4.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ttcn))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'TTCN_CFG',
    extensions: ['cfg'],
    load() {
      return __vitePreload(
        () => import('./ttcn-cfg-Dc39-fIP.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.ttcnCfg))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Turtle',
    extensions: ['ttl'],
    load() {
      return __vitePreload(
        () => import('./turtle-Dq7-1WAf.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.turtle))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Web IDL',
    extensions: ['webidl'],
    load() {
      return __vitePreload(
        () => import('./webidl-BTLTThCm.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.webIDL))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'VB.NET',
    extensions: ['vb'],
    load() {
      return __vitePreload(
        () => import('./vb-Dp90gtsv.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.vb))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'VBScript',
    extensions: ['vbs'],
    load() {
      return __vitePreload(
        () => import('./vbscript-CI6_mxxU.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.vbScript))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Velocity',
    extensions: ['vtl'],
    load() {
      return __vitePreload(
        () => import('./velocity-BwIZK1TH.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.velocity))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Verilog',
    extensions: ['v'],
    load() {
      return __vitePreload(
        () => import('./verilog-DDCYnHN8.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.verilog))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'VHDL',
    extensions: ['vhd', 'vhdl'],
    load() {
      return __vitePreload(
        () => import('./vhdl-DCkMIyT9.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.vhdl))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'XQuery',
    extensions: ['xy', 'xquery'],
    load() {
      return __vitePreload(
        () => import('./xquery-BgiOC5Ce.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.xQuery))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Yacas',
    extensions: ['ys'],
    load() {
      return __vitePreload(
        () => import('./yacas-b5lAVEIl.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.yacas))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Z80',
    extensions: ['z80'],
    load() {
      return __vitePreload(
        () => import('./z80-BZV19vqv.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.z80))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MscGen',
    extensions: ['mscgen', 'mscin', 'msc'],
    load() {
      return __vitePreload(
        () => import('./mscgen-DdqZYINH.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.mscgen))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Xù',
    extensions: ['xu'],
    load() {
      return __vitePreload(
        () => import('./mscgen-DdqZYINH.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.xu))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'MsGenny',
    extensions: ['msgenny'],
    load() {
      return __vitePreload(
        () => import('./mscgen-DdqZYINH.js'),
        true ? [] : void 0,
        import.meta.url
      ).then((m) => legacy(m.msgenny))
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Vue',
    extensions: ['vue'],
    load() {
      return __vitePreload(
        () => import('./index-BG3EwtfT.js'),
        true ? __vite__mapDeps([22, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.vue())
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: 'Angular Template',
    load() {
      return __vitePreload(
        () => import('./index-BZQmcA9k.js'),
        true ? __vite__mapDeps([23, 1, 2]) : void 0,
        import.meta.url
      ).then((m) => m.angular())
    }
  })
]
class CompositeBlock {
  static create(type, value, from, parentHash, end) {
    let hash2 = (parentHash + (parentHash << 8) + type + (value << 4)) | 0
    return new CompositeBlock(type, value, from, hash2, end, [], [])
  }
  constructor(type, value, from, hash2, end, children, positions) {
    this.type = type
    this.value = value
    this.from = from
    this.hash = hash2
    this.end = end
    this.children = children
    this.positions = positions
    this.hashProp = [[NodeProp.contextHash, hash2]]
  }
  addChild(child, pos) {
    if (child.prop(NodeProp.contextHash) != this.hash)
      child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp)
    this.children.push(child)
    this.positions.push(pos)
  }
  toTree(nodeSet2, end = this.end) {
    let last = this.children.length - 1
    if (last >= 0)
      end = Math.max(end, this.positions[last] + this.children[last].length + this.from)
    return new Tree(
      nodeSet2.types[this.type],
      this.children,
      this.positions,
      end - this.from
    ).balance({
      makeTree: (children, positions, length) =>
        new Tree(NodeType.none, children, positions, length, this.hashProp)
    })
  }
}
var Type
;(function (Type2) {
  Type2[(Type2['Document'] = 1)] = 'Document'
  Type2[(Type2['CodeBlock'] = 2)] = 'CodeBlock'
  Type2[(Type2['FencedCode'] = 3)] = 'FencedCode'
  Type2[(Type2['Blockquote'] = 4)] = 'Blockquote'
  Type2[(Type2['HorizontalRule'] = 5)] = 'HorizontalRule'
  Type2[(Type2['BulletList'] = 6)] = 'BulletList'
  Type2[(Type2['OrderedList'] = 7)] = 'OrderedList'
  Type2[(Type2['ListItem'] = 8)] = 'ListItem'
  Type2[(Type2['ATXHeading1'] = 9)] = 'ATXHeading1'
  Type2[(Type2['ATXHeading2'] = 10)] = 'ATXHeading2'
  Type2[(Type2['ATXHeading3'] = 11)] = 'ATXHeading3'
  Type2[(Type2['ATXHeading4'] = 12)] = 'ATXHeading4'
  Type2[(Type2['ATXHeading5'] = 13)] = 'ATXHeading5'
  Type2[(Type2['ATXHeading6'] = 14)] = 'ATXHeading6'
  Type2[(Type2['SetextHeading1'] = 15)] = 'SetextHeading1'
  Type2[(Type2['SetextHeading2'] = 16)] = 'SetextHeading2'
  Type2[(Type2['HTMLBlock'] = 17)] = 'HTMLBlock'
  Type2[(Type2['LinkReference'] = 18)] = 'LinkReference'
  Type2[(Type2['Paragraph'] = 19)] = 'Paragraph'
  Type2[(Type2['CommentBlock'] = 20)] = 'CommentBlock'
  Type2[(Type2['ProcessingInstructionBlock'] = 21)] = 'ProcessingInstructionBlock'
  Type2[(Type2['Escape'] = 22)] = 'Escape'
  Type2[(Type2['Entity'] = 23)] = 'Entity'
  Type2[(Type2['HardBreak'] = 24)] = 'HardBreak'
  Type2[(Type2['Emphasis'] = 25)] = 'Emphasis'
  Type2[(Type2['StrongEmphasis'] = 26)] = 'StrongEmphasis'
  Type2[(Type2['Link'] = 27)] = 'Link'
  Type2[(Type2['Image'] = 28)] = 'Image'
  Type2[(Type2['InlineCode'] = 29)] = 'InlineCode'
  Type2[(Type2['HTMLTag'] = 30)] = 'HTMLTag'
  Type2[(Type2['Comment'] = 31)] = 'Comment'
  Type2[(Type2['ProcessingInstruction'] = 32)] = 'ProcessingInstruction'
  Type2[(Type2['Autolink'] = 33)] = 'Autolink'
  Type2[(Type2['HeaderMark'] = 34)] = 'HeaderMark'
  Type2[(Type2['QuoteMark'] = 35)] = 'QuoteMark'
  Type2[(Type2['ListMark'] = 36)] = 'ListMark'
  Type2[(Type2['LinkMark'] = 37)] = 'LinkMark'
  Type2[(Type2['EmphasisMark'] = 38)] = 'EmphasisMark'
  Type2[(Type2['CodeMark'] = 39)] = 'CodeMark'
  Type2[(Type2['CodeText'] = 40)] = 'CodeText'
  Type2[(Type2['CodeInfo'] = 41)] = 'CodeInfo'
  Type2[(Type2['LinkTitle'] = 42)] = 'LinkTitle'
  Type2[(Type2['LinkLabel'] = 43)] = 'LinkLabel'
  Type2[(Type2['URL'] = 44)] = 'URL'
})(Type || (Type = {}))
class LeafBlock {
  /**
  @internal
  */
  constructor(start, content2) {
    this.start = start
    this.content = content2
    this.marks = []
    this.parsers = []
  }
}
class Line2 {
  constructor() {
    this.text = ''
    this.baseIndent = 0
    this.basePos = 0
    this.depth = 0
    this.markers = []
    this.pos = 0
    this.indent = 0
    this.next = -1
  }
  /**
  @internal
  */
  forward() {
    if (this.basePos > this.pos) this.forwardInner()
  }
  /**
  @internal
  */
  forwardInner() {
    let newPos = this.skipSpace(this.basePos)
    this.indent = this.countIndent(newPos, this.pos, this.indent)
    this.pos = newPos
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos)
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(from) {
    return skipSpace(this.text, from)
  }
  /**
  @internal
  */
  reset(text2) {
    this.text = text2
    this.baseIndent = this.basePos = this.pos = this.indent = 0
    this.forwardInner()
    this.depth = 1
    while (this.markers.length) this.markers.pop()
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(to) {
    this.basePos = to
    this.baseIndent = this.countIndent(to, this.pos, this.indent)
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(indent) {
    this.baseIndent = indent
    this.basePos = this.findColumn(indent)
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(elt2) {
    this.markers.push(elt2)
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(to, from = 0, indent = 0) {
    for (let i = from; i < to; i++) indent += this.text.charCodeAt(i) == 9 ? 4 - (indent % 4) : 1
    return indent
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(goal) {
    let i = 0
    for (let indent = 0; i < this.text.length && indent < goal; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - (indent % 4) : 1
    return i
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent) return this.text
    let result = ''
    for (let i = 0; i < this.basePos; i++) result += ' '
    return result + this.text.slice(this.basePos)
  }
}
function skipForList(bl, cx, line) {
  if (
    line.pos == line.text.length ||
    (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
  )
    return true
  if (line.indent >= line.baseIndent + 4) return false
  let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false)
  return (
    size > 0 &&
    (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&
    line.text.charCodeAt(line.pos + size - 1) == bl.value
  )
}
const DefaultSkipMarkup = {
  [Type.Blockquote](bl, cx, line) {
    if (line.next != 62) return false
    line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1))
    line.moveBase(line.pos + (space$2(line.text.charCodeAt(line.pos + 1)) ? 2 : 1))
    bl.end = cx.lineStart + line.text.length
    return true
  },
  [Type.ListItem](bl, _cx, line) {
    if (line.indent < line.baseIndent + bl.value && line.next > -1) return false
    line.moveBaseColumn(line.baseIndent + bl.value)
    return true
  },
  [Type.OrderedList]: skipForList,
  [Type.BulletList]: skipForList,
  [Type.Document]() {
    return true
  }
}
function space$2(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13
}
function skipSpace(line, i = 0) {
  while (i < line.length && space$2(line.charCodeAt(i))) i++
  return i
}
function skipSpaceBack(line, i, to) {
  while (i > to && space$2(line.charCodeAt(i - 1))) i--
  return i
}
function isFencedCode(line) {
  if (line.next != 96 && line.next != 126) return -1
  let pos = line.pos + 1
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++
  if (pos < line.pos + 3) return -1
  if (line.next == 96) {
    for (let i = pos; i < line.text.length; i++) if (line.text.charCodeAt(i) == 96) return -1
  }
  return pos
}
function isBlockquote(line) {
  return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1
}
function isHorizontalRule(line, cx, breaking) {
  if (line.next != 42 && line.next != 45 && line.next != 95) return -1
  let count2 = 1
  for (let pos = line.pos + 1; pos < line.text.length; pos++) {
    let ch = line.text.charCodeAt(pos)
    if (ch == line.next) count2++
    else if (!space$2(ch)) return -1
  }
  if (
    breaking &&
    line.next == 45 &&
    isSetextUnderline(line) > -1 &&
    line.depth == cx.stack.length &&
    cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1
  )
    return -1
  return count2 < 3 ? -1 : 1
}
function inList(cx, type) {
  for (let i = cx.stack.length - 1; i >= 0; i--) if (cx.stack[i].type == type) return true
  return false
}
function isBulletList(line, cx, breaking) {
  return (line.next == 45 || line.next == 43 || line.next == 42) &&
    (line.pos == line.text.length - 1 || space$2(line.text.charCodeAt(line.pos + 1))) &&
    (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length)
    ? 1
    : -1
}
function isOrderedList(line, cx, breaking) {
  let pos = line.pos,
    next = line.next
  for (;;) {
    if (next >= 48 && next <= 57) pos++
    else break
    if (pos == line.text.length) return -1
    next = line.text.charCodeAt(pos)
  }
  if (
    pos == line.pos ||
    pos > line.pos + 9 ||
    (next != 46 && next != 41) ||
    (pos < line.text.length - 1 && !space$2(line.text.charCodeAt(pos + 1))) ||
    (breaking &&
      !inList(cx, Type.OrderedList) &&
      (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
  )
    return -1
  return pos + 1 - line.pos
}
function isAtxHeading(line) {
  if (line.next != 35) return -1
  let pos = line.pos + 1
  while (pos < line.text.length && line.text.charCodeAt(pos) == 35) pos++
  if (pos < line.text.length && line.text.charCodeAt(pos) != 32) return -1
  let size = pos - line.pos
  return size > 6 ? -1 : size
}
function isSetextUnderline(line) {
  if ((line.next != 45 && line.next != 61) || line.indent >= line.baseIndent + 4) return -1
  let pos = line.pos + 1
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++
  let end = pos
  while (pos < line.text.length && space$2(line.text.charCodeAt(pos))) pos++
  return pos == line.text.length ? end : -1
}
const EmptyLine = /^[ \t]*$/,
  CommentEnd = /-->/,
  ProcessingEnd = /\?>/
const HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [
    /^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i,
    EmptyLine
  ],
  [
    /^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i,
    EmptyLine
  ]
]
function isHTMLBlock(line, _cx, breaking) {
  if (line.next != 60) return -1
  let rest = line.text.slice(line.pos)
  for (let i = 0, e2 = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e2; i++)
    if (HTMLBlockStyle[i][0].test(rest)) return i
  return -1
}
function getListIndent(line, pos) {
  let indentAfter = line.countIndent(pos, line.pos, line.indent)
  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter)
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented
}
function addCodeText(marks, from, to) {
  let last = marks.length - 1
  if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText) marks[last].to = to
  else marks.push(elt(Type.CodeText, from, to))
}
const DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line) {
    let base2 = line.baseIndent + 4
    if (line.indent < base2) return false
    let start = line.findColumn(base2)
    let from = cx.lineStart + start,
      to = cx.lineStart + line.text.length
    let marks = [],
      pendingMarks = []
    addCodeText(marks, from, to)
    while (cx.nextLine() && line.depth >= cx.stack.length) {
      if (line.pos == line.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart)
        for (let m of line.markers) pendingMarks.push(m)
      } else if (line.indent < base2) {
        break
      } else {
        if (pendingMarks.length) {
          for (let m of pendingMarks) {
            if (m.type == Type.CodeText) addCodeText(marks, m.from, m.to)
            else marks.push(m)
          }
          pendingMarks = []
        }
        addCodeText(marks, cx.lineStart - 1, cx.lineStart)
        for (let m of line.markers) marks.push(m)
        to = cx.lineStart + line.text.length
        let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4)
        if (codeStart < to) addCodeText(marks, codeStart, to)
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m) => m.type != Type.CodeText)
      if (pendingMarks.length) line.markers = pendingMarks.concat(line.markers)
    }
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from)
    return true
  },
  FencedCode(cx, line) {
    let fenceEnd = isFencedCode(line)
    if (fenceEnd < 0) return false
    let from = cx.lineStart + line.pos,
      ch = line.next,
      len = fenceEnd - line.pos
    let infoFrom = line.skipSpace(fenceEnd),
      infoTo = skipSpaceBack(line.text, line.text.length, infoFrom)
    let marks = [elt(Type.CodeMark, from, from + len)]
    if (infoFrom < infoTo)
      marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo))
    for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
      let i = line.pos
      if (line.indent - line.baseIndent < 4)
        while (i < line.text.length && line.text.charCodeAt(i) == ch) i++
      if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {
        for (let m of line.markers) marks.push(m)
        marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i))
        cx.nextLine()
        break
      } else {
        if (!first) addCodeText(marks, cx.lineStart - 1, cx.lineStart)
        for (let m of line.markers) marks.push(m)
        let textStart = cx.lineStart + line.basePos,
          textEnd = cx.lineStart + line.text.length
        if (textStart < textEnd) addCodeText(marks, textStart, textEnd)
      }
    }
    cx.addNode(
      cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from),
      from
    )
    return true
  },
  Blockquote(cx, line) {
    let size = isBlockquote(line)
    if (size < 0) return false
    cx.startContext(Type.Blockquote, line.pos)
    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1)
    line.moveBase(line.pos + size)
    return null
  },
  HorizontalRule(cx, line) {
    if (isHorizontalRule(line, cx, false) < 0) return false
    let from = cx.lineStart + line.pos
    cx.nextLine()
    cx.addNode(Type.HorizontalRule, from)
    return true
  },
  BulletList(cx, line) {
    let size = isBulletList(line, cx, false)
    if (size < 0) return false
    if (cx.block.type != Type.BulletList) cx.startContext(Type.BulletList, line.basePos, line.next)
    let newBase = getListIndent(line, line.pos + 1)
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent)
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size)
    line.moveBaseColumn(newBase)
    return null
  },
  OrderedList(cx, line) {
    let size = isOrderedList(line, cx, false)
    if (size < 0) return false
    if (cx.block.type != Type.OrderedList)
      cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1))
    let newBase = getListIndent(line, line.pos + size)
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent)
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size)
    line.moveBaseColumn(newBase)
    return null
  },
  ATXHeading(cx, line) {
    let size = isAtxHeading(line)
    if (size < 0) return false
    let off = line.pos,
      from = cx.lineStart + off
    let endOfSpace = skipSpaceBack(line.text, line.text.length, off),
      after = endOfSpace
    while (after > off && line.text.charCodeAt(after - 1) == line.next) after--
    if (after == endOfSpace || after == off || !space$2(line.text.charCodeAt(after - 1)))
      after = line.text.length
    let buf = cx.buffer
      .write(Type.HeaderMark, 0, size)
      .writeElements(
        cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1),
        -from
      )
    if (after < line.text.length) buf.write(Type.HeaderMark, after - off, endOfSpace - off)
    let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off)
    cx.nextLine()
    cx.addNode(node, from)
    return true
  },
  HTMLBlock(cx, line) {
    let type = isHTMLBlock(line, cx, false)
    if (type < 0) return false
    let from = cx.lineStart + line.pos,
      end = HTMLBlockStyle[type][1]
    let marks = [],
      trailing = end != EmptyLine
    while (!end.test(line.text) && cx.nextLine()) {
      if (line.depth < cx.stack.length) {
        trailing = false
        break
      }
      for (let m of line.markers) marks.push(m)
    }
    if (trailing) cx.nextLine()
    let nodeType =
      end == CommentEnd
        ? Type.CommentBlock
        : end == ProcessingEnd
          ? Type.ProcessingInstructionBlock
          : Type.HTMLBlock
    let to = cx.prevLineEnd()
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from)
    return true
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
}
class LinkReferenceParser {
  constructor(leaf) {
    this.stage = 0
    this.elts = []
    this.pos = 0
    this.start = leaf.start
    this.advance(leaf.content)
  }
  nextLine(cx, line, leaf) {
    if (this.stage == -1) return false
    let content2 = leaf.content + '\n' + line.scrub()
    let finish = this.advance(content2)
    if (finish > -1 && finish < content2.length) return this.complete(cx, leaf, finish)
    return false
  }
  finish(cx, leaf) {
    if (
      (this.stage == 2 || this.stage == 3) &&
      skipSpace(leaf.content, this.pos) == leaf.content.length
    )
      return this.complete(cx, leaf, leaf.content.length)
    return false
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts))
    return true
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start
      this.elts.push(elt2)
      this.stage++
      return true
    }
    if (elt2 === false) this.stage = -1
    return false
  }
  advance(content2) {
    for (;;) {
      if (this.stage == -1) {
        return -1
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true))) return -1
        if (content2.charCodeAt(this.pos) != 58) return (this.stage = -1)
        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1))
        this.pos++
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
          return -1
      } else if (this.stage == 2) {
        let skip = skipSpace(content2, this.pos),
          end = 0
        if (skip > this.pos) {
          let title = parseLinkTitle(content2, skip, this.start)
          if (title) {
            let titleEnd = lineEnd(content2, title.to - this.start)
            if (titleEnd > 0) {
              this.nextStage(title)
              end = titleEnd
            }
          }
        }
        if (!end) end = lineEnd(content2, this.pos)
        return end > 0 && end < content2.length ? end : -1
      } else {
        return lineEnd(content2, this.pos)
      }
    }
  }
}
function lineEnd(text2, pos) {
  for (; pos < text2.length; pos++) {
    let next = text2.charCodeAt(pos)
    if (next == 10) break
    if (!space$2(next)) return -1
  }
  return pos
}
class SetextHeadingParser {
  nextLine(cx, line, leaf) {
    let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line)
    let next = line.next
    if (underline < 0) return false
    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline)
    cx.nextLine()
    cx.addLeafElement(
      leaf,
      elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
        ...cx.parser.parseInline(leaf.content, leaf.start),
        underlineMark
      ])
    )
    return true
  }
  finish() {
    return false
  }
}
const DefaultLeafBlocks = {
  LinkReference(_2, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null
  },
  SetextHeading() {
    return new SetextHeadingParser()
  }
}
const DefaultEndLeaf = [
  (_2, line) => isAtxHeading(line) >= 0,
  (_2, line) => isFencedCode(line) >= 0,
  (_2, line) => isBlockquote(line) >= 0,
  (p, line) => isBulletList(line, p, true) >= 0,
  (p, line) => isOrderedList(line, p, true) >= 0,
  (p, line) => isHorizontalRule(line, p, true) >= 0,
  (p, line) => isHTMLBlock(line, p, true) >= 0
]
const scanLineResult = { text: '', end: 0 }
class BlockContext {
  /**
  @internal
  */
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2
    this.input = input
    this.ranges = ranges
    this.line = new Line2()
    this.atEnd = false
    this.reusePlaceholders = /* @__PURE__ */ new Map()
    this.stoppedAt = null
    this.rangeI = 0
    this.to = ranges[ranges.length - 1].to
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from
    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0)
    this.stack = [this.block]
    this.fragments = fragments.length ? new FragmentCursor$1(fragments, input) : null
    this.readLine()
  }
  get parsedPos() {
    return this.absoluteLineStart
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish()
    let { line } = this
    for (;;) {
      for (let markI = 0; ; ) {
        let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null
        while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
          let mark = line.markers[markI++]
          this.addNode(mark.type, mark.from, mark.to)
        }
        if (!next) break
        this.finishContext()
      }
      if (line.pos < line.text.length) break
      if (!this.nextLine()) return this.finish()
    }
    if (this.fragments && this.reuseFragment(line.basePos)) return null
    start: for (;;) {
      for (let type of this.parser.blockParsers)
        if (type) {
          let result = type(this, line)
          if (result != false) {
            if (result == true) return null
            line.forward()
            continue start
          }
        }
      break
    }
    let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos))
    for (let parse of this.parser.leafBlockParsers)
      if (parse) {
        let parser2 = parse(this, leaf)
        if (parser2) leaf.parsers.push(parser2)
      }
    lines: while (this.nextLine()) {
      if (line.pos == line.text.length) break
      if (line.indent < line.baseIndent + 4) {
        for (let stop of this.parser.endLeafBlock) if (stop(this, line, leaf)) break lines
      }
      for (let parser2 of leaf.parsers) if (parser2.nextLine(this, line, leaf)) return null
      leaf.content += '\n' + line.scrub()
      for (let m of line.markers) leaf.marks.push(m)
    }
    this.finishLeaf(leaf)
    return null
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward")
    this.stoppedAt = pos
  }
  reuseFragment(start) {
    if (
      !this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||
      !this.fragments.matches(this.block.hash)
    )
      return false
    let taken = this.fragments.takeNodes(this)
    if (!taken) return false
    this.absoluteLineStart += taken
    this.lineStart = toRelative(this.absoluteLineStart, this.ranges)
    this.moveRangeI()
    if (this.absoluteLineStart < this.to) {
      this.lineStart++
      this.absoluteLineStart++
      this.readLine()
    } else {
      this.atEnd = true
      this.readLine()
    }
    return true
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(depth = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth].type]
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    this.lineStart += this.line.text.length
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd
      this.atEnd = true
      this.readLine()
      return false
    } else {
      this.lineStart++
      this.absoluteLineStart = this.absoluteLineEnd + 1
      this.moveRangeI()
      this.readLine()
      return true
    }
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text
  }
  moveRangeI() {
    while (
      this.rangeI < this.ranges.length - 1 &&
      this.absoluteLineStart >= this.ranges[this.rangeI].to
    ) {
      this.rangeI++
      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from)
    }
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(start) {
    let r2 = scanLineResult
    r2.end = start
    if (start >= this.to) {
      r2.text = ''
    } else {
      r2.text = this.lineChunkAt(start)
      r2.end += r2.text.length
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart,
          rangeI = this.rangeI
        while (this.ranges[rangeI].to < r2.end) {
          rangeI++
          let nextFrom = this.ranges[rangeI].from
          let after = this.lineChunkAt(nextFrom)
          r2.end = nextFrom + after.length
          r2.text = r2.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after
          textOffset = r2.end - r2.text.length
        }
      }
    }
    return r2
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line } = this,
      { text: text2, end } = this.scanLine(this.absoluteLineStart)
    this.absoluteLineEnd = end
    line.reset(text2)
    for (; line.depth < this.stack.length; line.depth++) {
      let cx = this.stack[line.depth],
        handler = this.parser.skipContextMarkup[cx.type]
      if (!handler) throw new Error('Unhandled block context ' + Type[cx.type])
      if (!handler(cx, this, line)) break
      line.forward()
    }
  }
  lineChunkAt(pos) {
    let next = this.input.chunk(pos),
      text2
    if (!this.input.lineChunks) {
      let eol = next.indexOf('\n')
      text2 = eol < 0 ? next : next.slice(0, eol)
    } else {
      text2 = next == '\n' ? '' : next
    }
    return pos + text2.length > this.to ? text2.slice(0, this.to - pos) : text2
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1
  }
  /**
  @internal
  */
  startContext(type, start, value = 0) {
    this.block = CompositeBlock.create(
      type,
      value,
      this.lineStart + start,
      this.block.hash,
      this.lineStart + this.line.text.length
    )
    this.stack.push(this.block)
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(type, start, value = 0) {
    this.startContext(this.parser.getNodeType(type), start, value)
  }
  /**
  @internal
  */
  addNode(block2, from, to) {
    if (typeof block2 == 'number')
      block2 = new Tree(
        this.parser.nodeSet.types[block2],
        none,
        none,
        (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from
      )
    this.block.addChild(block2, from - this.block.from)
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from)
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(leaf, elt2) {
    this.addNode(
      this.buffer
        .writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from)
        .finish(elt2.type, elt2.to - elt2.from),
      elt2.from
    )
  }
  /**
  @internal
  */
  finishContext() {
    let cx = this.stack.pop()
    let top2 = this.stack[this.stack.length - 1]
    top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from)
    this.block = top2
  }
  finish() {
    while (this.stack.length > 1) this.finishContext()
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart))
  }
  addGaps(tree) {
    return this.ranges.length > 1
      ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders)
      : tree
  }
  /**
  @internal
  */
  finishLeaf(leaf) {
    for (let parser2 of leaf.parsers) if (parser2.finish(this, leaf)) return
    let inline2 = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks)
    this.addNode(
      this.buffer.writeElements(inline2, -leaf.start).finish(Type.Paragraph, leaf.content.length),
      leaf.start
    )
  }
  elt(type, from, to, children) {
    if (typeof type == 'string') return elt(this.parser.getNodeType(type), from, to, children)
    return new TreeElement(type, from)
  }
  /**
  @internal
  */
  get buffer() {
    return new Buffer(this.parser.nodeSet)
  }
}
function injectGaps(ranges, rangeI, tree, offset, dummies) {
  let rangeEnd2 = ranges[rangeI].to
  let children = [],
    positions = [],
    start = tree.from + offset
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges[rangeI + 1].from - rangeEnd2
      offset += size
      upto += size
      rangeI++
      rangeEnd2 = ranges[rangeI].to
    }
  }
  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true)
    let from = ch.from + offset,
      node,
      reuse = dummies.get(ch.tree)
    if (reuse) {
      node = reuse
    } else if (ch.to + offset > rangeEnd2) {
      node = injectGaps(ranges, rangeI, ch, offset, dummies)
      movePastNext(ch.to + offset, false)
    } else {
      node = ch.toTree()
    }
    children.push(node)
    positions.push(from - start)
  }
  movePastNext(tree.to + offset, false)
  return new Tree(
    tree.type,
    children,
    positions,
    tree.to + offset - start,
    tree.tree ? tree.tree.propValues : void 0
  )
}
class MarkdownParser extends Parser {
  /**
  @internal
  */
  constructor(
    nodeSet2,
    blockParsers,
    leafBlockParsers,
    blockNames,
    endLeafBlock,
    skipContextMarkup,
    inlineParsers,
    inlineNames,
    wrappers2
  ) {
    super()
    this.nodeSet = nodeSet2
    this.blockParsers = blockParsers
    this.leafBlockParsers = leafBlockParsers
    this.blockNames = blockNames
    this.endLeafBlock = endLeafBlock
    this.skipContextMarkup = skipContextMarkup
    this.inlineParsers = inlineParsers
    this.inlineNames = inlineNames
    this.wrappers = wrappers2
    this.nodeTypes = /* @__PURE__ */ Object.create(null)
    for (let t2 of nodeSet2.types) this.nodeTypes[t2.name] = t2.id
  }
  createParse(input, fragments, ranges) {
    let parse = new BlockContext(this, input, fragments, ranges)
    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges)
    return parse
  }
  /**
  Reconfigure the parser.
  */
  configure(spec) {
    let config2 = resolveConfig(spec)
    if (!config2) return this
    let { nodeSet: nodeSet2, skipContextMarkup } = this
    let blockParsers = this.blockParsers.slice(),
      leafBlockParsers = this.leafBlockParsers.slice(),
      blockNames = this.blockNames.slice(),
      inlineParsers = this.inlineParsers.slice(),
      inlineNames = this.inlineNames.slice(),
      endLeafBlock = this.endLeafBlock.slice(),
      wrappers2 = this.wrappers
    if (nonEmpty(config2.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup)
      let nodeTypes2 = nodeSet2.types.slice(),
        styles
      for (let s of config2.defineNodes) {
        let {
          name: name2,
          block: block2,
          composite,
          style
        } = typeof s == 'string' ? { name: s } : s
        if (nodeTypes2.some((t2) => t2.name == name2)) continue
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value)
        let id2 = nodeTypes2.length
        let group = composite
          ? ['Block', 'BlockContext']
          : !block2
            ? void 0
            : id2 >= Type.ATXHeading1 && id2 <= Type.SetextHeading2
              ? ['Block', 'LeafBlock', 'Heading']
              : ['Block', 'LeafBlock']
        nodeTypes2.push(
          NodeType.define({
            id: id2,
            name: name2,
            props: group && [[NodeProp.group, group]]
          })
        )
        if (style) {
          if (!styles) styles = {}
          if (Array.isArray(style) || style instanceof Tag) styles[name2] = style
          else Object.assign(styles, style)
        }
      }
      nodeSet2 = new NodeSet(nodeTypes2)
      if (styles) nodeSet2 = nodeSet2.extend(styleTags(styles))
    }
    if (nonEmpty(config2.props)) nodeSet2 = nodeSet2.extend(...config2.props)
    if (nonEmpty(config2.remove)) {
      for (let rm2 of config2.remove) {
        let block2 = this.blockNames.indexOf(rm2),
          inline2 = this.inlineNames.indexOf(rm2)
        if (block2 > -1) blockParsers[block2] = leafBlockParsers[block2] = void 0
        if (inline2 > -1) inlineParsers[inline2] = void 0
      }
    }
    if (nonEmpty(config2.parseBlock)) {
      for (let spec2 of config2.parseBlock) {
        let found = blockNames.indexOf(spec2.name)
        if (found > -1) {
          blockParsers[found] = spec2.parse
          leafBlockParsers[found] = spec2.leaf
        } else {
          let pos = spec2.before
            ? findName(blockNames, spec2.before)
            : spec2.after
              ? findName(blockNames, spec2.after) + 1
              : blockNames.length - 1
          blockParsers.splice(pos, 0, spec2.parse)
          leafBlockParsers.splice(pos, 0, spec2.leaf)
          blockNames.splice(pos, 0, spec2.name)
        }
        if (spec2.endLeaf) endLeafBlock.push(spec2.endLeaf)
      }
    }
    if (nonEmpty(config2.parseInline)) {
      for (let spec2 of config2.parseInline) {
        let found = inlineNames.indexOf(spec2.name)
        if (found > -1) {
          inlineParsers[found] = spec2.parse
        } else {
          let pos = spec2.before
            ? findName(inlineNames, spec2.before)
            : spec2.after
              ? findName(inlineNames, spec2.after) + 1
              : inlineNames.length - 1
          inlineParsers.splice(pos, 0, spec2.parse)
          inlineNames.splice(pos, 0, spec2.name)
        }
      }
    }
    if (config2.wrap) wrappers2 = wrappers2.concat(config2.wrap)
    return new MarkdownParser(
      nodeSet2,
      blockParsers,
      leafBlockParsers,
      blockNames,
      endLeafBlock,
      skipContextMarkup,
      inlineParsers,
      inlineNames,
      wrappers2
    )
  }
  /**
  @internal
  */
  getNodeType(name2) {
    let found = this.nodeTypes[name2]
    if (found == null) throw new RangeError(`Unknown node type '${name2}'`)
    return found
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(text2, offset) {
    let cx = new InlineContext(this, text2, offset)
    outer: for (let pos = offset; pos < cx.end; ) {
      let next = cx.char(pos)
      for (let token of this.inlineParsers)
        if (token) {
          let result = token(cx, next, pos)
          if (result >= 0) {
            pos = result
            continue outer
          }
        }
      pos++
    }
    return cx.resolveMarkers(0)
  }
}
function nonEmpty(a) {
  return a != null && a.length > 0
}
function resolveConfig(spec) {
  if (!Array.isArray(spec)) return spec
  if (spec.length == 0) return null
  let conf = resolveConfig(spec[0])
  if (spec.length == 1) return conf
  let rest = resolveConfig(spec.slice(1))
  if (!rest || !conf) return conf || rest
  let conc2 = (a, b) => (a || none).concat(b || none)
  let wrapA = conf.wrap,
    wrapB = rest.wrap
  return {
    props: conc2(conf.props, rest.props),
    defineNodes: conc2(conf.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf.parseBlock, rest.parseBlock),
    parseInline: conc2(conf.parseInline, rest.parseInline),
    remove: conc2(conf.remove, rest.remove),
    wrap: !wrapA
      ? wrapB
      : !wrapB
        ? wrapA
        : (inner, input, fragments, ranges) =>
            wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
  }
}
function findName(names, name2) {
  let found = names.indexOf(name2)
  if (found < 0) throw new RangeError(`Position specified relative to unknown parser ${name2}`)
  return found
}
let nodeTypes = [NodeType.none]
for (let i = 1, name2; (name2 = Type[i]); i++) {
  nodeTypes[i] = NodeType.define({
    id: i,
    name: name2,
    props:
      i >= Type.Escape
        ? []
        : [
            [
              NodeProp.group,
              i in DefaultSkipMarkup ? ['Block', 'BlockContext'] : ['Block', 'LeafBlock']
            ]
          ],
    top: name2 == 'Document'
  })
}
const none = []
class Buffer {
  constructor(nodeSet2) {
    this.nodeSet = nodeSet2
    this.content = []
    this.nodes = []
  }
  write(type, from, to, children = 0) {
    this.content.push(type, from, to, 4 + children * 4)
    return this
  }
  writeElements(elts, offset = 0) {
    for (let e2 of elts) e2.writeTo(this, offset)
    return this
  }
  finish(type, length) {
    return Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type,
      length
    })
  }
}
let Element$1 = class Element {
  /**
  @internal
  */
  constructor(type, from, to, children = none) {
    this.type = type
    this.from = from
    this.to = to
    this.children = children
  }
  /**
  @internal
  */
  writeTo(buf, offset) {
    let startOff = buf.content.length
    buf.writeElements(this.children, offset)
    buf.content.push(
      this.type,
      this.from + offset,
      this.to + offset,
      buf.content.length + 4 - startOff
    )
  }
  /**
  @internal
  */
  toTree(nodeSet2) {
    return new Buffer(nodeSet2)
      .writeElements(this.children, -this.from)
      .finish(this.type, this.to - this.from)
  }
}
class TreeElement {
  constructor(tree, from) {
    this.tree = tree
    this.from = from
  }
  get to() {
    return this.from + this.tree.length
  }
  get type() {
    return this.tree.type.id
  }
  get children() {
    return none
  }
  writeTo(buf, offset) {
    buf.nodes.push(this.tree)
    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1)
  }
  toTree() {
    return this.tree
  }
}
function elt(type, from, to, children) {
  return new Element$1(type, from, to, children)
}
const EmphasisUnderscore = { resolve: 'Emphasis', mark: 'EmphasisMark' }
const EmphasisAsterisk = { resolve: 'Emphasis', mark: 'EmphasisMark' }
const LinkStart = {},
  ImageStart = {}
class InlineDelimiter {
  constructor(type, from, to, side) {
    this.type = type
    this.from = from
    this.to = to
    this.side = side
  }
}
const Escapable = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/
try {
  Punctuation = new RegExp('[\\p{S}|\\p{P}]', 'u')
} catch (_2) {}
const DefaultInline = {
  Escape(cx, next, start) {
    if (next != 92 || start == cx.end - 1) return -1
    let escaped = cx.char(start + 1)
    for (let i = 0; i < Escapable.length; i++)
      if (Escapable.charCodeAt(i) == escaped) return cx.append(elt(Type.Escape, start, start + 2))
    return -1
  },
  Entity(cx, next, start) {
    if (next != 38) return -1
    let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31))
    return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1
  },
  InlineCode(cx, next, start) {
    if (next != 96 || (start && cx.char(start - 1) == 96)) return -1
    let pos = start + 1
    while (pos < cx.end && cx.char(pos) == 96) pos++
    let size = pos - start,
      curSize = 0
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++
        if (curSize == size && cx.char(pos + 1) != 96)
          return cx.append(
            elt(Type.InlineCode, start, pos + 1, [
              elt(Type.CodeMark, start, start + size),
              elt(Type.CodeMark, pos + 1 - size, pos + 1)
            ])
          )
      } else {
        curSize = 0
      }
    }
    return -1
  },
  HTMLTag(cx, next, start) {
    if (next != 60 || start == cx.end - 1) return -1
    let after = cx.slice(start + 1, cx.end)
    let url =
      /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(
        after
      )
    if (url) {
      return cx.append(
        elt(Type.Autolink, start, start + 1 + url[0].length, [
          elt(Type.LinkMark, start, start + 1),
          // url[0] includes the closing bracket, so exclude it from this slice
          elt(Type.URL, start + 1, start + url[0].length),
          elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
        ])
      )
    }
    let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after)
    if (comment2) return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length))
    let procInst = /^\?[^]*?\?>/.exec(after)
    if (procInst)
      return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length))
    let m =
      /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(
        after
      )
    if (!m) return -1
    return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length))
  },
  Emphasis(cx, next, start) {
    if (next != 95 && next != 42) return -1
    let pos = start + 1
    while (cx.char(pos) == next) pos++
    let before = cx.slice(start - 1, start),
      after = cx.slice(pos, pos + 1)
    let pBefore = Punctuation.test(before),
      pAfter = Punctuation.test(after)
    let sBefore = /\s|^$/.test(before),
      sAfter = /\s|^$/.test(after)
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore)
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter)
    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore)
    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter)
    return cx.append(
      new InlineDelimiter(
        next == 95 ? EmphasisUnderscore : EmphasisAsterisk,
        start,
        pos,
        (canOpen ? 1 : 0) | (canClose ? 2 : 0)
      )
    )
  },
  HardBreak(cx, next, start) {
    if (next == 92 && cx.char(start + 1) == 10)
      return cx.append(elt(Type.HardBreak, start, start + 2))
    if (next == 32) {
      let pos = start + 1
      while (cx.char(pos) == 32) pos++
      if (cx.char(pos) == 10 && pos >= start + 2)
        return cx.append(elt(Type.HardBreak, start, pos + 1))
    }
    return -1
  },
  Link(cx, next, start) {
    return next == 91
      ? cx.append(
          new InlineDelimiter(
            LinkStart,
            start,
            start + 1,
            1
            /* Mark.Open */
          )
        )
      : -1
  },
  Image(cx, next, start) {
    return next == 33 && cx.char(start + 1) == 91
      ? cx.append(
          new InlineDelimiter(
            ImageStart,
            start,
            start + 2,
            1
            /* Mark.Open */
          )
        )
      : -1
  },
  LinkEnd(cx, next, start) {
    if (next != 93) return -1
    for (let i = cx.parts.length - 1; i >= 0; i--) {
      let part = cx.parts[i]
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
        if (
          !part.side ||
          (cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2)))
        ) {
          cx.parts[i] = null
          return -1
        }
        let content2 = cx.takeContent(i)
        let link2 = (cx.parts[i] = finishLink(
          cx,
          content2,
          part.type == LinkStart ? Type.Link : Type.Image,
          part.from,
          start + 1
        ))
        if (part.type == LinkStart)
          for (let j = 0; j < i; j++) {
            let p = cx.parts[j]
            if (p instanceof InlineDelimiter && p.type == LinkStart) p.side = 0
          }
        return link2.to
      }
    }
    return -1
  }
}
function finishLink(cx, content2, type, start, startPos) {
  let { text: text2 } = cx,
    next = cx.char(startPos),
    endPos = startPos
  content2.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)))
  content2.push(elt(Type.LinkMark, startPos - 1, startPos))
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1)
    let dest = parseURL(text2, pos - cx.offset, cx.offset),
      title
    if (dest) {
      pos = cx.skipSpace(dest.to)
      if (pos != dest.to) {
        title = parseLinkTitle(text2, pos - cx.offset, cx.offset)
        if (title) pos = cx.skipSpace(title.to)
      }
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type.LinkMark, startPos, startPos + 1))
      endPos = pos + 1
      if (dest) content2.push(dest)
      if (title) content2.push(title)
      content2.push(elt(Type.LinkMark, pos, endPos))
    }
  } else if (next == 91) {
    let label = parseLinkLabel(text2, startPos - cx.offset, cx.offset, false)
    if (label) {
      content2.push(label)
      endPos = label.to
    }
  }
  return elt(type, start, endPos, content2)
}
function parseURL(text2, start, offset) {
  let next = text2.charCodeAt(start)
  if (next == 60) {
    for (let pos = start + 1; pos < text2.length; pos++) {
      let ch = text2.charCodeAt(pos)
      if (ch == 62) return elt(Type.URL, start + offset, pos + 1 + offset)
      if (ch == 60 || ch == 10) return false
    }
    return null
  } else {
    let depth = 0,
      pos = start
    for (let escaped = false; pos < text2.length; pos++) {
      let ch = text2.charCodeAt(pos)
      if (space$2(ch)) {
        break
      } else if (escaped) {
        escaped = false
      } else if (ch == 40) {
        depth++
      } else if (ch == 41) {
        if (!depth) break
        depth--
      } else if (ch == 92) {
        escaped = true
      }
    }
    return pos > start
      ? elt(Type.URL, start + offset, pos + offset)
      : pos == text2.length
        ? null
        : false
  }
}
function parseLinkTitle(text2, start, offset) {
  let next = text2.charCodeAt(start)
  if (next != 39 && next != 34 && next != 40) return false
  let end = next == 40 ? 41 : next
  for (let pos = start + 1, escaped = false; pos < text2.length; pos++) {
    let ch = text2.charCodeAt(pos)
    if (escaped) escaped = false
    else if (ch == end) return elt(Type.LinkTitle, start + offset, pos + 1 + offset)
    else if (ch == 92) escaped = true
  }
  return null
}
function parseLinkLabel(text2, start, offset, requireNonWS) {
  for (
    let escaped = false, pos = start + 1, end = Math.min(text2.length, pos + 999);
    pos < end;
    pos++
  ) {
    let ch = text2.charCodeAt(pos)
    if (escaped) escaped = false
    else if (ch == 93)
      return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset)
    else {
      if (requireNonWS && !space$2(ch)) requireNonWS = false
      if (ch == 91) return false
      else if (ch == 92) escaped = true
    }
  }
  return null
}
class InlineContext {
  /**
  @internal
  */
  constructor(parser2, text2, offset) {
    this.parser = parser2
    this.text = text2
    this.offset = offset
    this.parts = []
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset)
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(from, to) {
    return this.text.slice(from - this.offset, to - this.offset)
  }
  /**
  @internal
  */
  append(elt2) {
    this.parts.push(elt2)
    return elt2.to
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(type, from, to, open, close) {
    return this.append(new InlineDelimiter(type, from, to, (open ? 1 : 0) | (close ? 2 : 0)))
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part = this.parts[i]
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
        return true
    }
    return false
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(elt2) {
    return this.append(elt2)
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(from) {
    for (let i = from; i < this.parts.length; i++) {
      let close = this.parts[i]
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2)) continue
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk
      let closeSize = close.to - close.from
      let open,
        j = i - 1
      for (; j >= from; j--) {
        let part = this.parts[j]
        if (
          part instanceof InlineDelimiter &&
          part.side & 1 &&
          part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
          !(
            emp &&
            (close.side & 1 || part.side & 2) &&
            (part.to - part.from + closeSize) % 3 == 0 &&
            ((part.to - part.from) % 3 || closeSize % 3)
          )
        ) {
          open = part
          break
        }
      }
      if (!open) continue
      let type = close.type.resolve,
        content2 = []
      let start = open.from,
        end = close.to
      if (emp) {
        let size = Math.min(2, open.to - open.from, closeSize)
        start = open.to - size
        end = close.from + size
        type = size == 1 ? 'Emphasis' : 'StrongEmphasis'
      }
      if (open.type.mark) content2.push(this.elt(open.type.mark, start, open.to))
      for (let k2 = j + 1; k2 < i; k2++) {
        if (this.parts[k2] instanceof Element$1) content2.push(this.parts[k2])
        this.parts[k2] = null
      }
      if (close.type.mark) content2.push(this.elt(close.type.mark, close.from, end))
      let element = this.elt(type, start, end, content2)
      this.parts[j] =
        emp && open.from != start
          ? new InlineDelimiter(open.type, open.from, start, open.side)
          : null
      let keep = (this.parts[i] =
        emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null)
      if (keep) this.parts.splice(i, 0, element)
      else this.parts[i] = element
    }
    let result = []
    for (let i = from; i < this.parts.length; i++) {
      let part = this.parts[i]
      if (part instanceof Element$1) result.push(part)
    }
    return result
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(type) {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part = this.parts[i]
      if (part instanceof InlineDelimiter && part.type == type) return i
    }
    return null
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(startIndex) {
    let content2 = this.resolveMarkers(startIndex)
    this.parts.length = startIndex
    return content2
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(from) {
    return skipSpace(this.text, from - this.offset) + this.offset
  }
  elt(type, from, to, children) {
    if (typeof type == 'string') return elt(this.parser.getNodeType(type), from, to, children)
    return new TreeElement(type, from)
  }
}
function injectMarks(elements, marks) {
  if (!marks.length) return elements
  if (!elements.length) return marks
  let elts = elements.slice(),
    eI = 0
  for (let mark of marks) {
    while (eI < elts.length && elts[eI].to < mark.to) eI++
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e2 = elts[eI]
      if (e2 instanceof Element$1)
        elts[eI] = new Element$1(e2.type, e2.from, e2.to, injectMarks(e2.children, [mark]))
    } else {
      elts.splice(eI++, 0, mark)
    }
  }
  return elts
}
const NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList]
let FragmentCursor$1 = class FragmentCursor2 {
  constructor(fragments, input) {
    this.fragments = fragments
    this.input = input
    this.i = 0
    this.fragment = null
    this.fragmentEnd = -1
    this.cursor = null
    if (fragments.length) this.fragment = fragments[this.i++]
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null
    this.cursor = null
    this.fragmentEnd = -1
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos) this.nextFragment()
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0)) return false
    if (this.fragmentEnd < 0) {
      let end = this.fragment.to
      while (end > 0 && this.input.read(end - 1, end) != '\n') end--
      this.fragmentEnd = end ? end - 1 : 0
    }
    let c = this.cursor
    if (!c) {
      c = this.cursor = this.fragment.tree.cursor()
      c.firstChild()
    }
    let rPos = pos + this.fragment.offset
    while (c.to <= rPos) if (!c.parent()) return false
    for (;;) {
      if (c.from >= rPos) return this.fragment.from <= lineStart
      if (!c.childAfter(rPos)) return false
    }
  }
  matches(hash2) {
    let tree = this.cursor.tree
    return tree && tree.prop(NodeProp.contextHash) == hash2
  }
  takeNodes(cx) {
    let cur2 = this.cursor,
      off = this.fragment.offset,
      fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0)
    let start = cx.absoluteLineStart,
      end = start,
      blockI = cx.block.children.length
    let prevEnd = end,
      prevI = blockI
    for (;;) {
      if (cur2.to - off > fragEnd) {
        if (cur2.type.isAnonymous && cur2.firstChild()) continue
        break
      }
      let pos = toRelative(cur2.from - off, cx.ranges)
      if (cur2.to - off <= cx.ranges[cx.rangeI].to) {
        cx.addNode(cur2.tree, pos)
      } else {
        let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp)
        cx.reusePlaceholders.set(dummy, cur2.tree)
        cx.addNode(dummy, pos)
      }
      if (cur2.type.is('Block')) {
        if (NotLast.indexOf(cur2.type.id) < 0) {
          end = cur2.to - off
          blockI = cx.block.children.length
        } else {
          end = prevEnd
          blockI = prevI
          prevEnd = cur2.to - off
          prevI = cx.block.children.length
        }
      }
      if (!cur2.nextSibling()) break
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop()
      cx.block.positions.pop()
    }
    return end - start
  }
}
function toRelative(abs, ranges) {
  let pos = abs
  for (let i = 1; i < ranges.length; i++) {
    let gapFrom = ranges[i - 1].to,
      gapTo = ranges[i].from
    if (gapFrom < abs) pos -= gapTo - gapFrom
  }
  return pos
}
const markdownHighlighting = styleTags({
  'Blockquote/...': tags$1.quote,
  HorizontalRule: tags$1.contentSeparator,
  'ATXHeading1/... SetextHeading1/...': tags$1.heading1,
  'ATXHeading2/... SetextHeading2/...': tags$1.heading2,
  'ATXHeading3/...': tags$1.heading3,
  'ATXHeading4/...': tags$1.heading4,
  'ATXHeading5/...': tags$1.heading5,
  'ATXHeading6/...': tags$1.heading6,
  'Comment CommentBlock': tags$1.comment,
  Escape: tags$1.escape,
  Entity: tags$1.character,
  'Emphasis/...': tags$1.emphasis,
  'StrongEmphasis/...': tags$1.strong,
  'Link/... Image/...': tags$1.link,
  'OrderedList/... BulletList/...': tags$1.list,
  'BlockQuote/...': tags$1.quote,
  'InlineCode CodeText': tags$1.monospace,
  'URL Autolink': tags$1.url,
  'HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark':
    tags$1.processingInstruction,
  'CodeInfo LinkLabel': tags$1.labelName,
  LinkTitle: tags$1.string,
  Paragraph: tags$1.content
})
const parser$6 = new MarkdownParser(
  new NodeSet(nodeTypes).extend(markdownHighlighting),
  Object.keys(DefaultBlockParsers).map((n2) => DefaultBlockParsers[n2]),
  Object.keys(DefaultBlockParsers).map((n2) => DefaultLeafBlocks[n2]),
  Object.keys(DefaultBlockParsers),
  DefaultEndLeaf,
  DefaultSkipMarkup,
  Object.keys(DefaultInline).map((n2) => DefaultInline[n2]),
  Object.keys(DefaultInline),
  []
)
function leftOverSpace(node, from, to) {
  let ranges = []
  for (let n2 = node.firstChild, pos = from; ; n2 = n2.nextSibling) {
    let nextPos = n2 ? n2.from : to
    if (nextPos > pos) ranges.push({ from: pos, to: nextPos })
    if (!n2) break
    pos = n2.to
  }
  return ranges
}
function parseCode(config2) {
  let { codeParser, htmlParser } = config2
  let wrap = parseMixed((node, input) => {
    let id2 = node.type.id
    if (codeParser && (id2 == Type.CodeBlock || id2 == Type.FencedCode)) {
      let info = ''
      if (id2 == Type.FencedCode) {
        let infoNode = node.node.getChild(Type.CodeInfo)
        if (infoNode) info = input.read(infoNode.from, infoNode.to)
      }
      let parser2 = codeParser(info)
      if (parser2) return { parser: parser2, overlay: (node2) => node2.type.id == Type.CodeText }
    } else if (
      htmlParser &&
      (id2 == Type.HTMLBlock || id2 == Type.HTMLTag || id2 == Type.CommentBlock)
    ) {
      return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) }
    }
    return null
  })
  return { wrap }
}
const StrikethroughDelim = { resolve: 'Strikethrough', mark: 'StrikethroughMark' }
const Strikethrough = {
  defineNodes: [
    {
      name: 'Strikethrough',
      style: { 'Strikethrough/...': tags$1.strikethrough }
    },
    {
      name: 'StrikethroughMark',
      style: tags$1.processingInstruction
    }
  ],
  parseInline: [
    {
      name: 'Strikethrough',
      parse(cx, next, pos) {
        if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126) return -1
        let before = cx.slice(pos - 1, pos),
          after = cx.slice(pos + 2, pos + 3)
        let sBefore = /\s|^$/.test(before),
          sAfter = /\s|^$/.test(after)
        let pBefore = Punctuation.test(before),
          pAfter = Punctuation.test(after)
        return cx.addDelimiter(
          StrikethroughDelim,
          pos,
          pos + 2,
          !sAfter && (!pAfter || sBefore || pBefore),
          !sBefore && (!pBefore || sAfter || pAfter)
        )
      },
      after: 'Emphasis'
    }
  ]
}
function parseRow(cx, line, startI = 0, elts, offset = 0) {
  let count2 = 0,
    first = true,
    cellStart = -1,
    cellEnd = -1,
    esc = false
  let parseCell = () => {
    elts.push(
      cx.elt(
        'TableCell',
        offset + cellStart,
        offset + cellEnd,
        cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)
      )
    )
  }
  for (let i = startI; i < line.length; i++) {
    let next = line.charCodeAt(i)
    if (next == 124 && !esc) {
      if (!first || cellStart > -1) count2++
      first = false
      if (elts) {
        if (cellStart > -1) parseCell()
        elts.push(cx.elt('TableDelimiter', i + offset, i + offset + 1))
      }
      cellStart = cellEnd = -1
    } else if (esc || (next != 32 && next != 9)) {
      if (cellStart < 0) cellStart = i
      cellEnd = i + 1
    }
    esc = !esc && next == 92
  }
  if (cellStart > -1) {
    count2++
    if (elts) parseCell()
  }
  return count2
}
function hasPipe(str, start) {
  for (let i = start; i < str.length; i++) {
    let next = str.charCodeAt(i)
    if (next == 124) return true
    if (next == 92) i++
  }
  return false
}
const delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/
class TableParser {
  constructor() {
    this.rows = null
  }
  nextLine(cx, line, leaf) {
    if (this.rows == null) {
      this.rows = false
      let lineText
      if (
        (line.next == 45 || line.next == 58 || line.next == 124) &&
        delimiterLine.test((lineText = line.text.slice(line.pos)))
      ) {
        let firstRow = [],
          firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start)
        if (firstCount == parseRow(cx, lineText, line.pos))
          this.rows = [
            cx.elt('TableHeader', leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt('TableDelimiter', cx.lineStart + line.pos, cx.lineStart + line.text.length)
          ]
      }
    } else if (this.rows) {
      let content2 = []
      parseRow(cx, line.text, line.pos, content2, cx.lineStart)
      this.rows.push(
        cx.elt('TableRow', cx.lineStart + line.pos, cx.lineStart + line.text.length, content2)
      )
    }
    return false
  }
  finish(cx, leaf) {
    if (!this.rows) return false
    cx.addLeafElement(
      leaf,
      cx.elt('Table', leaf.start, leaf.start + leaf.content.length, this.rows)
    )
    return true
  }
}
const Table = {
  defineNodes: [
    { name: 'Table', block: true },
    { name: 'TableHeader', style: { 'TableHeader/...': tags$1.heading } },
    'TableRow',
    { name: 'TableCell', style: tags$1.content },
    { name: 'TableDelimiter', style: tags$1.processingInstruction }
  ],
  parseBlock: [
    {
      name: 'Table',
      leaf(_2, leaf) {
        return hasPipe(leaf.content, 0) ? new TableParser() : null
      },
      endLeaf(cx, line, leaf) {
        if (leaf.parsers.some((p) => p instanceof TableParser) || !hasPipe(line.text, line.basePos))
          return false
        let next = cx.peekLine()
        return (
          delimiterLine.test(next) &&
          parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos)
        )
      },
      before: 'SetextHeading'
    }
  ]
}
class TaskParser {
  nextLine() {
    return false
  }
  finish(cx, leaf) {
    cx.addLeafElement(
      leaf,
      cx.elt('Task', leaf.start, leaf.start + leaf.content.length, [
        cx.elt('TaskMarker', leaf.start, leaf.start + 3),
        ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
      ])
    )
    return true
  }
}
const TaskList = {
  defineNodes: [
    { name: 'Task', block: true, style: tags$1.list },
    { name: 'TaskMarker', style: tags$1.atom }
  ],
  parseBlock: [
    {
      name: 'TaskList',
      leaf(cx, leaf) {
        return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == 'ListItem'
          ? new TaskParser()
          : null
      },
      after: 'SetextHeading'
    }
  ]
}
const autolinkRE = /(www\.)|(https?:\/\/)|([\w.+-]{1,100}@)|(mailto:|xmpp:)/gy
const urlRE = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy
const lastTwoDomainWords = /[\w-]+\.[\w-]+($|\/)/
const emailRE = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy
const xmppResourceRE = /\/[a-zA-Z\d@.]+/gy
function count(str, from, to, ch) {
  let result = 0
  for (let i = from; i < to; i++) if (str[i] == ch) result++
  return result
}
function autolinkURLEnd(text2, from) {
  urlRE.lastIndex = from
  let m = urlRE.exec(text2)
  if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf('_') > -1) return -1
  let end = from + m[0].length
  for (;;) {
    let last = text2[end - 1],
      m2
    if (
      /[?!.,:*_~]/.test(last) ||
      (last == ')' && count(text2, from, end, ')') > count(text2, from, end, '('))
    )
      end--
    else if (last == ';' && (m2 = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(text2.slice(from, end))))
      end = from + m2.index
    else break
  }
  return end
}
function autolinkEmailEnd(text2, from) {
  emailRE.lastIndex = from
  let m = emailRE.exec(text2)
  if (!m) return -1
  let last = m[0][m[0].length - 1]
  return last == '_' || last == '-' ? -1 : from + m[0].length - (last == '.' ? 1 : 0)
}
const Autolink = {
  parseInline: [
    {
      name: 'Autolink',
      parse(cx, next, absPos) {
        let pos = absPos - cx.offset
        if (pos && /\w/.test(cx.text[pos - 1])) return -1
        autolinkRE.lastIndex = pos
        let m = autolinkRE.exec(cx.text),
          end = -1
        if (!m) return -1
        if (m[1] || m[2]) {
          end = autolinkURLEnd(cx.text, pos + m[0].length)
          if (end > -1 && cx.hasOpenLink) {
            let noBracket = /([^\[\]]|\[[^\]]*\])*/.exec(cx.text.slice(pos, end))
            end = pos + noBracket[0].length
          }
        } else if (m[3]) {
          end = autolinkEmailEnd(cx.text, pos)
        } else {
          end = autolinkEmailEnd(cx.text, pos + m[0].length)
          if (end > -1 && m[0] == 'xmpp:') {
            xmppResourceRE.lastIndex = end
            m = xmppResourceRE.exec(cx.text)
            if (m) end = m.index + m[0].length
          }
        }
        if (end < 0) return -1
        cx.addElement(cx.elt('URL', absPos, end + cx.offset))
        return end + cx.offset
      }
    }
  ]
}
const GFM = [Table, TaskList, Strikethrough, Autolink]
function parseSubSuper(ch, node, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch) return -1
    let elts = [cx.elt(mark, pos, pos + 1)]
    for (let i = pos + 1; i < cx.end; i++) {
      let next2 = cx.char(i)
      if (next2 == ch)
        return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))))
      if (next2 == 92) elts.push(cx.elt('Escape', i, i++ + 2))
      if (space$2(next2)) break
    }
    return -1
  }
}
const Superscript = {
  defineNodes: [
    { name: 'Superscript', style: tags$1.special(tags$1.content) },
    { name: 'SuperscriptMark', style: tags$1.processingInstruction }
  ],
  parseInline: [
    {
      name: 'Superscript',
      parse: parseSubSuper(94, 'Superscript', 'SuperscriptMark')
    }
  ]
}
const Subscript = {
  defineNodes: [
    { name: 'Subscript', style: tags$1.special(tags$1.content) },
    { name: 'SubscriptMark', style: tags$1.processingInstruction }
  ],
  parseInline: [
    {
      name: 'Subscript',
      parse: parseSubSuper(126, 'Subscript', 'SubscriptMark')
    }
  ]
}
const Emoji = {
  defineNodes: [{ name: 'Emoji', style: tags$1.character }],
  parseInline: [
    {
      name: 'Emoji',
      parse(cx, next, pos) {
        let match2
        if (next != 58 || !(match2 = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end)))) return -1
        return cx.addElement(cx.elt('Emoji', pos, pos + 1 + match2[0].length))
      }
    }
  ]
}
var define_process_env_default = {}
class Stack {
  /**
  @internal
  */
  constructor(
    p,
    stack,
    state,
    reducePos,
    pos,
    score2,
    buffer,
    bufferBase,
    curContext,
    lookAhead = 0,
    parent
  ) {
    this.p = p
    this.stack = stack
    this.state = state
    this.reducePos = reducePos
    this.pos = pos
    this.score = score2
    this.buffer = buffer
    this.bufferBase = bufferBase
    this.curContext = curContext
    this.lookAhead = lookAhead
    this.parent = parent
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_2, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? '!' + this.score : ''}`
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx = p.parser.context
    return new Stack(
      p,
      [],
      state,
      pos,
      pos,
      0,
      [],
      0,
      cx ? new StackContext(cx, cx.start) : null,
      0,
      null
    )
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)
    this.state = state
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a2
    let depth = action >> 19,
      type = action & 65535
    let { parser: parser2 } = this.p
    let lookaheadRecord = this.reducePos < this.pos - 25
    if (lookaheadRecord) this.setLookAhead(this.pos)
    let dPrec = parser2.dynamicPrecedence(type)
    if (dPrec) this.score += dPrec
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos)
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true)
      this.reduceContext(type, this.reducePos)
      return
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0)
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from,
      size = this.reducePos - start
    if (
      size >= 2e3 &&
      !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0
        ? void 0
        : _a2.isAnonymous)
    ) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++
        this.p.lastBigReductionSize = size
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1
        this.p.lastBigReductionStart = start
        this.p.lastBigReductionSize = size
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0,
      count2 = this.bufferBase + this.buffer.length - bufferBase
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      )
        ? this.pos
        : this.reducePos
      this.storeNode(type, start, pos, count2 + 4, true)
    }
    if (action & 262144) {
      this.state = this.stack[base2]
    } else {
      let baseStateID = this.stack[base2 - 3]
      this.state = parser2.getGoto(baseStateID, type, true)
    }
    while (this.stack.length > base2) this.stack.pop()
    this.reduceContext(type, start)
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (
      term == 0 &&
      (!this.stack.length ||
        this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)
    ) {
      let cur2 = this,
        top2 = this.buffer.length
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase
        cur2 = cur2.parent
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end) return
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end
          return
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size)
    } else {
      let index2 = this.buffer.length
      if (index2 > 0 && this.buffer[index2 - 4] != 0) {
        let mustMove = false
        for (let scan = index2; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true
            break
          }
        }
        if (mustMove)
          while (index2 > 0 && this.buffer[index2 - 2] > end) {
            this.buffer[index2] = this.buffer[index2 - 4]
            this.buffer[index2 + 1] = this.buffer[index2 - 3]
            this.buffer[index2 + 2] = this.buffer[index2 - 2]
            this.buffer[index2 + 3] = this.buffer[index2 - 1]
            index2 -= 4
            if (size > 4) size -= 4
          }
      }
      this.buffer[index2] = term
      this.buffer[index2 + 1] = start
      this.buffer[index2 + 2] = end
      this.buffer[index2 + 3] = size
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos)
    } else if ((action & 262144) == 0) {
      let nextState = action,
        { parser: parser2 } = this.p
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end
        if (
          !parser2.stateFlag(
            nextState,
            1
            /* StateFlag.Skipped */
          )
        )
          this.reducePos = end
      }
      this.pushState(nextState, start)
      this.shiftContext(type, start)
      if (type <= parser2.maxNode) this.buffer.push(type, start, end, 4)
    } else {
      this.pos = end
      this.shiftContext(type, start)
      if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4)
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536) this.reduce(action)
    else this.shift(action, next, nextStart, nextEnd)
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index2 = this.p.reused.length - 1
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value)
      index2++
    }
    let start = this.pos
    this.reducePos = this.pos = start + value.length
    this.pushState(next, start)
    this.buffer.push(
      index2,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    )
    if (this.curContext)
      this.updateContext(
        this.curContext.tracker.reuse(
          this.curContext.context,
          value,
          this,
          this.p.stream.reset(this.pos - value.length)
        )
      )
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this
    let off = parent.buffer.length
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4
    let buffer = parent.buffer.slice(off),
      base2 = parent.bufferBase + off
    while (parent && base2 == parent.bufferBase) parent = parent.parent
    return new Stack(
      this.p,
      this.stack.slice(),
      this.state,
      this.reducePos,
      this.pos,
      this.score,
      buffer,
      base2,
      this.curContext,
      this.lookAhead,
      parent
    )
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode3 = next <= this.p.parser.maxNode
    if (isNode3) this.storeNode(next, this.pos, nextEnd, 4)
    this.storeNode(0, this.pos, nextEnd, isNode3 ? 8 : 4)
    this.pos = this.reducePos = nextEnd
    this.score -= 190
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action =
        this.p.parser.stateSlot(
          sim.state,
          4
          /* ParseState.DefaultReduce */
        ) || this.p.parser.hasAction(sim.state, term)
      if (action == 0) return false
      if ((action & 65536) == 0) return true
      sim.reduce(action)
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300) return []
    let nextStates = this.p.parser.nextStates(this.state)
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = []
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s)
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1]
          if (!best.some((v, i2) => i2 & 1 && v == s)) best.push(nextStates[i], s)
        }
      nextStates = best
    }
    let result = []
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1]
      if (s == this.state) continue
      let stack = this.split()
      stack.pushState(s, this.pos)
      stack.storeNode(0, stack.pos, stack.pos, 4, true)
      stack.shiftContext(nextStates[i], this.pos)
      stack.reducePos = this.pos
      stack.score -= 200
      result.push(stack)
    }
    return result
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p
    let reduce = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    )
    if ((reduce & 65536) == 0) return false
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19,
        term = reduce & 65535
      let target = this.stack.length - depth * 3
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction()
        if (backup == null) return false
        reduce = backup
      }
      this.storeNode(0, this.pos, this.pos, 4, true)
      this.score -= 100
    }
    this.reducePos = this.pos
    this.reduce(reduce)
    return true
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p,
      seen = []
    let explore = (state, depth) => {
      if (seen.includes(state)) return
      seen.push(state)
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072));
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth
          if (rDepth > 1) {
            let term = action & 65535,
              target = this.stack.length - rDepth * 3
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return (rDepth << 19) | 65536 | term
          }
        } else {
          let found = explore(action, depth + 1)
          if (found != null) return found
        }
      })
    }
    return explore(this.state, 0)
  }
  /**
  @internal
  */
  forceAll() {
    while (
      !this.p.parser.stateFlag(
        this.state,
        2
        /* StateFlag.Accepting */
      )
    ) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true)
        break
      }
    }
    return this
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3) return false
    let { parser: parser2 } = this.p
    return (
      parser2.data[
        parser2.stateSlot(
          this.state,
          1
          /* ParseState.Actions */
        )
      ] == 65535 &&
      !parser2.stateSlot(
        this.state,
        4
        /* ParseState.DefaultReduce */
      )
    )
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true)
    this.state = this.stack[0]
    this.stack.length = 0
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length) return false
    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false
    return true
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID]
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(
        this.curContext.tracker.shift(
          this.curContext.context,
          term,
          this,
          this.p.stream.reset(start)
        )
      )
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(
        this.curContext.tracker.reduce(
          this.curContext.context,
          term,
          this,
          this.p.stream.reset(start)
        )
      )
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context)
      if (newCx.hash != this.curContext.hash) this.emitContext()
      this.curContext = newCx
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead()
      this.lookAhead = lookAhead
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict) this.emitContext()
    if (this.lookAhead > 0) this.emitLookAhead()
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker
    this.context = context
    this.hash = tracker.strict ? tracker.hash(context) : 0
  }
}
class SimulatedStack {
  constructor(start) {
    this.start = start
    this.state = start.state
    this.stack = start.stack
    this.base = this.stack.length
  }
  reduce(action) {
    let term = action & 65535,
      depth = action >> 19
    if (depth == 0) {
      if (this.stack == this.start.stack) this.stack = this.stack.slice()
      this.stack.push(this.state, 0, 0)
      this.base += 3
    } else {
      this.base -= (depth - 1) * 3
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true)
    this.state = goto
  }
}
class StackBufferCursor {
  constructor(stack, pos, index2) {
    this.stack = stack
    this.pos = pos
    this.index = index2
    this.buffer = stack.buffer
    if (this.index == 0) this.maybeNext()
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase)
  }
  maybeNext() {
    let next = this.stack.parent
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase
      this.stack = next
      this.buffer = next.buffer
    }
  }
  get id() {
    return this.buffer[this.index - 4]
  }
  get start() {
    return this.buffer[this.index - 3]
  }
  get end() {
    return this.buffer[this.index - 2]
  }
  get size() {
    return this.buffer[this.index - 1]
  }
  next() {
    this.index -= 4
    this.pos -= 4
    if (this.index == 0) this.maybeNext()
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index)
  }
}
function decodeArray(input, Type2 = Uint16Array) {
  if (typeof input != 'string') return input
  let array = null
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0
    for (;;) {
      let next = input.charCodeAt(pos++),
        stop = false
      if (next == 126) {
        value = 65535
        break
      }
      if (next >= 92) next--
      if (next >= 34) next--
      let digit = next - 32
      if (digit >= 46) {
        digit -= 46
        stop = true
      }
      value += digit
      if (stop) break
      value *= 46
    }
    if (array) array[out++] = value
    else array = new Type2(value)
  }
  return array
}
class CachedToken {
  constructor() {
    this.start = -1
    this.value = -1
    this.end = -1
    this.extended = -1
    this.lookAhead = 0
    this.mask = 0
    this.context = 0
  }
}
const nullToken = new CachedToken()
class InputStream {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input
    this.ranges = ranges
    this.chunk = ''
    this.chunkOff = 0
    this.chunk2 = ''
    this.chunk2Pos = 0
    this.next = -1
    this.token = nullToken
    this.rangeIndex = 0
    this.pos = this.chunkPos = ranges[0].from
    this.range = ranges[0]
    this.end = ranges[ranges.length - 1].to
    this.readNext()
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range,
      index2 = this.rangeIndex
    let pos = this.pos + offset
    while (pos < range.from) {
      if (!index2) return null
      let next = this.ranges[--index2]
      pos -= range.from - next.to
      range = next
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index2 == this.ranges.length - 1) return null
      let next = this.ranges[++index2]
      pos += next.from - range.to
      range = next
    }
    return pos
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to) return pos
    for (let range of this.ranges) if (range.to > pos) return Math.max(pos, range.from)
    return this.end
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset,
      pos,
      result
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset
      result = this.chunk.charCodeAt(idx)
    } else {
      let resolved = this.resolveOffset(offset, 1)
      if (resolved == null) return -1
      pos = resolved
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos)
      } else {
        let i = this.rangeIndex,
          range = this.range
        while (range.to <= pos) range = this.ranges[++i]
        this.chunk2 = this.input.chunk((this.chunk2Pos = pos))
        if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos)
        result = this.chunk2.charCodeAt(0)
      }
    }
    if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1
    return result
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos
    if (end == null || end < this.token.start) throw new RangeError('Token end out of bounds')
    this.token.value = token
    this.token.end = end
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token
    this.token.end = endPos
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this
      this.chunk = this.chunk2
      this.chunkPos = this.chunk2Pos
      this.chunk2 = chunk
      this.chunk2Pos = chunkPos
      this.chunkOff = this.pos - this.chunkPos
    } else {
      this.chunk2 = this.chunk
      this.chunk2Pos = this.chunkPos
      let nextChunk = this.input.chunk(this.pos)
      let end = this.pos + nextChunk.length
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk
      this.chunkPos = this.pos
      this.chunkOff = 0
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk()
      if (this.chunkOff == this.chunk.length) return (this.next = -1)
    }
    return (this.next = this.chunk.charCodeAt(this.chunkOff))
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n2 = 1) {
    this.chunkOff += n2
    while (this.pos + n2 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone()
      n2 -= this.range.to - this.pos
      this.range = this.ranges[++this.rangeIndex]
      this.pos = this.range.from
    }
    this.pos += n2
    if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1
    return this.readNext()
  }
  setDone() {
    this.pos = this.chunkPos = this.end
    this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]
    this.chunk = ''
    return (this.next = -1)
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token
      token.start = pos
      token.lookAhead = pos + 1
      token.value = token.extended = -1
    } else {
      this.token = nullToken
    }
    if (this.pos != pos) {
      this.pos = pos
      if (pos == this.end) {
        this.setDone()
        return this
      }
      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex]
      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex]
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos
      } else {
        this.chunk = ''
        this.chunkOff = 0
      }
      this.readNext()
    }
    return this
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos)
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos)
    if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to)
    let result = ''
    for (let r2 of this.ranges) {
      if (r2.from >= to) break
      if (r2.to > from) result += this.input.read(Math.max(r2.from, from), Math.min(r2.to, to))
    }
    return result
  }
}
class TokenGroup {
  constructor(data2, id2) {
    this.data = data2
    this.id = id2
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable)
  }
}
TokenGroup.prototype.contextual =
  TokenGroup.prototype.fallback =
  TokenGroup.prototype.extend =
    false
class LocalTokenGroup {
  constructor(data2, precTable, elseToken) {
    this.precTable = precTable
    this.elseToken = elseToken
    this.data = typeof data2 == 'string' ? decodeArray(data2) : data2
  }
  token(input, stack) {
    let start = input.pos,
      skipped = 0
    for (;;) {
      let atEof = input.next < 0,
        nextPos = input.resolveOffset(1, 1)
      readToken(this.data, input, stack, 0, this.data, this.precTable)
      if (input.token.value > -1) break
      if (this.elseToken == null) return
      if (!atEof) skipped++
      if (nextPos == null) break
      input.reset(nextPos, input.token)
    }
    if (skipped) {
      input.reset(start, input.token)
      input.acceptToken(this.elseToken, skipped)
    }
  }
}
LocalTokenGroup.prototype.contextual =
  TokenGroup.prototype.fallback =
  TokenGroup.prototype.extend =
    false
class ExternalTokenizer {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token
    this.contextual = !!options.contextual
    this.fallback = !!options.fallback
    this.extend = !!options.extend
  }
}
function readToken(data2, input, stack, group, precTable, precOffset) {
  let state = 0,
    groupMask = 1 << group,
    { dialect } = stack.p.parser
  scan: for (;;) {
    if ((groupMask & data2[state]) == 0) break
    let accEnd = data2[state + 1]
    for (let i = state + 3; i < accEnd; i += 2)
      if ((data2[i + 1] & groupMask) > 0) {
        let term = data2[i]
        if (
          dialect.allows(term) &&
          (input.token.value == -1 ||
            input.token.value == term ||
            overrides(term, input.token.value, precTable, precOffset))
        ) {
          input.acceptToken(term)
          break
        }
      }
    let next = input.next,
      low = 0,
      high = data2[state + 2]
    if (input.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535) {
      state = data2[accEnd + high * 3 - 1]
      continue scan
    }
    for (; low < high; ) {
      let mid = (low + high) >> 1
      let index2 = accEnd + mid + (mid << 1)
      let from = data2[index2],
        to = data2[index2 + 1] || 65536
      if (next < from) high = mid
      else if (next >= to) low = mid + 1
      else {
        state = data2[index2 + 2]
        input.advance()
        continue scan
      }
    }
    break
  }
}
function findOffset(data2, start, term) {
  for (let i = start, next; (next = data2[i]) != 65535; i++) if (next == term) return i - start
  return -1
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev)
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev
}
const verbose =
  typeof process != 'undefined' &&
  define_process_env_default &&
  /\bparse\b/.test(define_process_env_default.LOG)
let stackIDs = null
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous)
  cursor2.moveTo(pos)
  for (;;) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (;;) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0
            ? Math.max(
                0,
                Math.min(
                  cursor2.to - 1,
                  pos - 25
                  /* Lookahead.Margin */
                )
              )
            : Math.min(
                tree.length,
                Math.max(
                  cursor2.from + 1,
                  pos + 25
                  /* Lookahead.Margin */
                )
              )
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling()) break
        if (!cursor2.parent()) return side < 0 ? 0 : tree.length
      }
  }
}
class FragmentCursor3 {
  constructor(fragments, nodeSet2) {
    this.fragments = fragments
    this.nodeSet = nodeSet2
    this.i = 0
    this.fragment = null
    this.safeFrom = -1
    this.safeTo = -1
    this.trees = []
    this.start = []
    this.index = []
    this.nextFragment()
  }
  nextFragment() {
    let fr = (this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++])
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to
      while (this.trees.length) {
        this.trees.pop()
        this.start.pop()
        this.index.pop()
      }
      this.trees.push(fr.tree)
      this.start.push(-fr.offset)
      this.index.push(0)
      this.nextStart = this.safeFrom
    } else {
      this.nextStart = 1e9
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart) return null
    while (this.fragment && this.safeTo <= pos) this.nextFragment()
    if (!this.fragment) return null
    for (;;) {
      let last = this.trees.length - 1
      if (last < 0) {
        this.nextFragment()
        return null
      }
      let top2 = this.trees[last],
        index2 = this.index[last]
      if (index2 == top2.children.length) {
        this.trees.pop()
        this.start.pop()
        this.index.pop()
        continue
      }
      let next = top2.children[index2]
      let start = this.start[last] + top2.positions[index2]
      if (start > pos) {
        this.nextStart = start
        return null
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom) return null
          let end = start + next.length
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead)
            if (!lookAhead || end + lookAhead < this.fragment.to) return next
          }
        }
        this.index[last]++
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next)
          this.start.push(start)
          this.index.push(0)
        }
      } else {
        this.index[last]++
        this.nextStart = start + next.length
      }
    }
  }
}
class TokenCache {
  constructor(parser2, stream) {
    this.stream = stream
    this.tokens = []
    this.mainToken = null
    this.actions = []
    this.tokens = parser2.tokenizers.map((_2) => new CachedToken())
  }
  getActions(stack) {
    let actionIndex = 0
    let main = null
    let { parser: parser2 } = stack.p,
      { tokenizers } = parser2
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    )
    let context = stack.curContext ? stack.curContext.hash : 0
    let lookAhead = 0
    for (let i = 0; i < tokenizers.length; i++) {
      if (((1 << i) & mask) == 0) continue
      let tokenizer = tokenizers[i],
        token = this.tokens[i]
      if (main && !tokenizer.fallback) continue
      if (
        tokenizer.contextual ||
        token.start != stack.pos ||
        token.mask != mask ||
        token.context != context
      ) {
        this.updateCachedToken(token, tokenizer, stack)
        token.mask = mask
        token.context = context
      }
      if (token.lookAhead > token.end + 25) lookAhead = Math.max(token.lookAhead, lookAhead)
      if (token.value != 0) {
        let startIndex = actionIndex
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex)
        if (!tokenizer.extend) {
          main = token
          if (actionIndex > startIndex) break
        }
      }
    }
    while (this.actions.length > actionIndex) this.actions.pop()
    if (lookAhead) stack.setLookAhead(lookAhead)
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken()
      main.value = stack.p.parser.eofTerm
      main.start = main.end = stack.pos
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex)
    }
    this.mainToken = main
    return this.actions
  }
  getMainToken(stack) {
    if (this.mainToken) return this.mainToken
    let main = new CachedToken(),
      { pos, p } = stack
    main.start = pos
    main.end = Math.min(pos + 1, p.stream.end)
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0
    return main
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos)
    tokenizer.token(this.stream.reset(start, token), stack)
    if (token.value > -1) {
      let { parser: parser2 } = stack.p
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack)
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0) token.value = result >> 1
            else token.extended = result >> 1
            break
          }
        }
    } else {
      token.value = 0
      token.end = this.stream.clipPos(start + 1)
    }
  }
  putAction(action, token, end, index2) {
    for (let i = 0; i < index2; i += 3) if (this.actions[i] == action) return index2
    this.actions[index2++] = action
    this.actions[index2++] = token
    this.actions[index2++] = end
    return index2
  }
  addActions(stack, token, end, index2) {
    let { state } = stack,
      { parser: parser2 } = stack.p,
      { data: data2 } = parser2
    for (let set2 = 0; set2 < 2; set2++) {
      for (
        let i = parser2.stateSlot(
          state,
          set2 ? 2 : 1
          /* ParseState.Actions */
        );
        ;
        i += 3
      ) {
        if (data2[i] == 65535) {
          if (data2[i + 1] == 1) {
            i = pair(data2, i + 2)
          } else {
            if (index2 == 0 && data2[i + 1] == 2)
              index2 = this.putAction(pair(data2, i + 2), token, end, index2)
            break
          }
        }
        if (data2[i] == token) index2 = this.putAction(pair(data2, i + 1), token, end, index2)
      }
    }
    return index2
  }
}
class Parse2 {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2
    this.input = input
    this.ranges = ranges
    this.recovering = 0
    this.nextStackID = 9812
    this.minStackPos = 0
    this.reused = []
    this.stoppedAt = null
    this.lastBigReductionStart = -1
    this.lastBigReductionSize = 0
    this.bigReductionCount = 0
    this.stream = new InputStream(input, ranges)
    this.tokens = new TokenCache(parser2, this.stream)
    this.topTerm = parser2.top[1]
    let { from } = ranges[0]
    this.stacks = [Stack.start(this, parser2.top[0], from)]
    this.fragments =
      fragments.length && this.stream.end - from > parser2.bufferLength * 4
        ? new FragmentCursor3(fragments, parser2.nodeSet)
        : null
  }
  get parsedPos() {
    return this.minStackPos
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks,
      pos = this.minStackPos
    let newStacks = (this.stacks = [])
    let stopped, stoppedTokens
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks
      while (
        s.forceReduce() &&
        s.stack.length &&
        s.stack[s.stack.length - 2] >= this.lastBigReductionStart
      ) {}
      this.bigReductionCount = this.lastBigReductionSize = 0
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i]
      for (;;) {
        this.tokens.mainToken = null
        if (stack.pos > pos) {
          newStacks.push(stack)
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue
        } else {
          if (!stopped) {
            stopped = []
            stoppedTokens = []
          }
          stopped.push(stack)
          let tok = this.tokens.getMainToken(stack)
          stoppedTokens.push(tok.value, tok.end)
        }
        break
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped)
      if (finished) {
        if (verbose) console.log('Finish with ' + this.stackID(finished))
        return this.stackToTree(finished)
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log(
            'Stuck with token ' +
              (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : 'none')
          )
        throw new SyntaxError('No parse at ' + pos)
      }
      if (!this.recovering) this.recovering = 5
    }
    if (this.recovering && stopped) {
      let finished =
        this.stoppedAt != null && stopped[0].pos > this.stoppedAt
          ? stopped[0]
          : this.runRecovery(stopped, stoppedTokens, newStacks)
      if (finished) {
        if (verbose) console.log('Force-finish ' + this.stackID(finished))
        return this.stackToTree(finished.forceAll())
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score)
        while (newStacks.length > maxRemaining) newStacks.pop()
      }
      if (newStacks.some((s) => s.reducePos > pos)) this.recovering--
    } else if (newStacks.length > 1) {
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i]
        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j]
          if (stack.sameState(other) || (stack.buffer.length > 500 && other.buffer.length > 500)) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1)
            } else {
              newStacks.splice(i--, 1)
              continue outer
            }
          }
        }
      }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        )
    }
    this.minStackPos = newStacks[0].pos
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos
    return null
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward")
    this.stoppedAt = pos
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos,
      { parser: parser2 } = this
    let base2 = verbose ? this.stackID(stack) + ' -> ' : ''
    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict,
        cxHash = strictCx ? stack.curContext.hash : 0
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match2 =
          this.parser.nodeSet.types[cached.type.id] == cached.type
            ? parser2.getGoto(stack.state, cached.type.id)
            : -1
        if (
          match2 > -1 &&
          cached.length &&
          (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)
        ) {
          stack.useNode(cached, match2)
          if (verbose)
            console.log(
              base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`
            )
          return true
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break
        let inner = cached.children[0]
        if (inner instanceof Tree && cached.positions[0] == 0) cached = inner
        else break
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    )
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce)
      if (verbose)
        console.log(
          base2 +
            this.stackID(stack) +
            ` (via always-reduce ${parser2.getName(
              defaultReduce & 65535
              /* Action.ValueMask */
            )})`
        )
      return true
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {}
    }
    let actions = this.tokens.getActions(stack)
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++],
        term = actions[i++],
        end = actions[i++]
      let last = i == actions.length || !split
      let localStack = last ? stack : stack.split()
      let main = this.tokens.mainToken
      localStack.apply(action, term, main ? main.start : localStack.pos, end)
      if (verbose)
        console.log(
          base2 +
            this.stackID(localStack) +
            ` (via ${
              (action & 65536) == 0
                ? 'shift'
                : `reduce of ${parser2.getName(
                    action & 65535
                    /* Action.ValueMask */
                  )}`
            } for ${parser2.getName(term)} @ ${start}${localStack == stack ? '' : ', split'})`
        )
      if (last) return true
      else if (localStack.pos > start) stacks.push(localStack)
      else split.push(localStack)
    }
    return false
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos
    for (;;) {
      if (!this.advanceStack(stack, null, null)) return false
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks)
        return true
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null,
      restarted = false
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i],
        token = tokens[i << 1],
        tokenEnd = tokens[(i << 1) + 1]
      let base2 = verbose ? this.stackID(stack) + ' -> ' : ''
      if (stack.deadEnd) {
        if (restarted) continue
        restarted = true
        stack.restart()
        if (verbose) console.log(base2 + this.stackID(stack) + ' (restarted)')
        let done = this.advanceFully(stack, newStacks)
        if (done) continue
      }
      let force = stack.split(),
        forceBase = base2
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose) console.log(forceBase + this.stackID(force) + ' (via force-reduce)')
        let done = this.advanceFully(force, newStacks)
        if (done) break
        if (verbose) forceBase = this.stackID(force) + ' -> '
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose) console.log(base2 + this.stackID(insert2) + ' (via recover-insert)')
        this.advanceFully(insert2, newStacks)
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++
          token = 0
        }
        stack.recoverByDelete(token, tokenEnd)
        if (verbose)
          console.log(
            base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`
          )
        pushStackDedup(stack, newStacks)
      } else if (!finished || finished.score < stack.score) {
        finished = stack
      }
    }
    return finished
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close()
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    })
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack)
    if (!id2) stackIDs.set(stack, (id2 = String.fromCodePoint(this.nextStackID++)))
    return id2 + stack
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i]
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score) newStacks[i] = stack
      return
    }
  }
  newStacks.push(stack)
}
class Dialect {
  constructor(source, flags, disabled) {
    this.source = source
    this.flags = flags
    this.disabled = disabled
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0
  }
}
const id = (x2) => x2
class ContextTracker {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start
    this.shift = spec.shift || id
    this.reduce = spec.reduce || id
    this.reuse = spec.reuse || id
    this.hash = spec.hash || (() => 0)
    this.strict = spec.strict !== false
  }
}
class LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super()
    this.wrappers = []
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`)
    let nodeNames = spec.nodeNames.split(' ')
    this.minRepeatTerm = nodeNames.length
    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push('')
    let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1])
    let nodeProps = []
    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([])
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))])
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0]
        if (typeof prop == 'string') prop = NodeProp[prop]
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++]
          if (next >= 0) {
            setProp(next, prop, propSpec[i++])
          } else {
            let value = propSpec[i + -next]
            for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value)
            i++
          }
        }
      }
    this.nodeSet = new NodeSet(
      nodeNames.map((name2, i) =>
        NodeType.define({
          name: i >= this.minRepeatTerm ? void 0 : name2,
          id: i,
          props: nodeProps[i],
          top: topTerms.indexOf(i) > -1,
          error: i == 0,
          skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })
      )
    )
    if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources)
    this.strict = false
    this.bufferLength = DefaultBufferLength
    let tokenArray = decodeArray(spec.tokenData)
    this.context = spec.context
    this.specializerSpecs = spec.specialized || []
    this.specialized = new Uint16Array(this.specializerSpecs.length)
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term
    this.specializers = this.specializerSpecs.map(getSpecializer)
    this.states = decodeArray(spec.states, Uint32Array)
    this.data = decodeArray(spec.stateData)
    this.goto = decodeArray(spec.goto)
    this.maxTerm = spec.maxTerm
    this.tokenizers = spec.tokenizers.map((value) =>
      typeof value == 'number' ? new TokenGroup(tokenArray, value) : value
    )
    this.topRules = spec.topRules
    this.dialects = spec.dialects || {}
    this.dynamicPrecedences = spec.dynamicPrecedences || null
    this.tokenPrecTable = spec.tokenPrec
    this.termNames = spec.termNames || null
    this.maxNode = this.nodeSet.types.length - 1
    this.dialect = this.parseDialect()
    this.top = this.topRules[Object.keys(this.topRules)[0]]
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse2(this, input, fragments, ranges)
    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges)
    return parse
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table2 = this.goto
    if (term >= table2[0]) return -1
    for (let pos = table2[term + 1]; ; ) {
      let groupTag = table2[pos++],
        last = groupTag & 1
      let target = table2[pos++]
      if (last && loose) return target
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table2[pos] == state) return target
      if (last) return -1
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data2 = this.data
    for (let set2 = 0; set2 < 2; set2++) {
      for (
        let i = this.stateSlot(
            state,
            set2 ? 2 : 1
            /* ParseState.Actions */
          ),
          next;
        ;
        i += 3
      ) {
        if ((next = data2[i]) == 65535) {
          if (data2[i + 1] == 1) next = data2[(i = pair(data2, i + 2))]
          else if (data2[i + 1] == 2) return pair(data2, i + 2)
          else break
        }
        if (next == terminal || next == 0) return pair(data2, i + 1)
      }
    }
    return 0
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot]
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (
      (this.stateSlot(
        state,
        0
        /* ParseState.Flags */
      ) &
        flag) >
      0
    )
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a) => (a == action ? true : null))
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    )
    let result = deflt ? action(deflt) : void 0
    for (
      let i = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      );
      result == null;
      i += 3
    ) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1) i = pair(this.data, i + 2)
        else break
      }
      result = action(pair(this.data, i + 1))
    }
    return result
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = []
    for (
      let i = this.stateSlot(
        state,
        1
        /* ParseState.Actions */
      );
      ;
      i += 3
    ) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1) i = pair(this.data, i + 2)
        else break
      }
      if ((this.data[i + 2] & (65536 >> 16)) == 0) {
        let value = this.data[i + 1]
        if (!result.some((v, i2) => i2 & 1 && v == value)) result.push(this.data[i], value)
      }
    }
    return result
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy = Object.assign(Object.create(LRParser.prototype), this)
    if (config2.props) copy.nodeSet = this.nodeSet.extend(...config2.props)
    if (config2.top) {
      let info = this.topRules[config2.top]
      if (!info) throw new RangeError(`Invalid top rule name ${config2.top}`)
      copy.top = info
    }
    if (config2.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config2.tokenizers.find((r2) => r2.from == t2)
        return found ? found.to : t2
      })
    if (config2.specializers) {
      copy.specializers = this.specializers.slice()
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config2.specializers.find((r2) => r2.from == s.external)
        if (!found) return s
        let spec = Object.assign(Object.assign({}, s), { external: found.to })
        copy.specializers[i] = getSpecializer(spec)
        return spec
      })
    }
    if (config2.contextTracker) copy.context = config2.contextTracker
    if (config2.dialect) copy.dialect = this.parseDialect(config2.dialect)
    if (config2.strict != null) copy.strict = config2.strict
    if (config2.wrap) copy.wrappers = copy.wrappers.concat(config2.wrap)
    if (config2.bufferLength != null) copy.bufferLength = config2.bufferLength
    return copy
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames
      ? this.termNames[term]
      : String((term <= this.maxNode && this.nodeSet.types[term].name) || term)
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]]
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences
    return prec2 == null ? 0 : prec2[term] || 0
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects),
      flags = values2.map(() => false)
    if (dialect)
      for (let part of dialect.split(' ')) {
        let id2 = values2.indexOf(part)
        if (id2 >= 0) flags[id2] = true
      }
    let disabled = null
    for (let i = 0; i < values2.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values2[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1
      }
    return new Dialect(dialect, flags, disabled)
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new LRParser(spec)
  }
}
function pair(data2, off) {
  return data2[off] | (data2[off + 1] << 16)
}
function findFinished(stacks) {
  let best = null
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt
    if (
      (stack.pos == stack.p.stream.end || (stopped != null && stack.pos > stopped)) &&
      stack.p.parser.stateFlag(
        stack.state,
        2
        /* StateFlag.Accepting */
      ) &&
      (!best || best.score < stack.score)
    )
      best = stack
  }
  return best
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0
    return (value, stack) => (spec.external(value, stack) << 1) | mask
  }
  return spec.get
}
const scriptText = 54,
  StartCloseScriptTag = 1,
  styleText = 55,
  StartCloseStyleTag = 2,
  textareaText = 56,
  StartCloseTextareaTag = 3,
  EndTag = 4,
  SelfClosingEndTag = 5,
  StartTag = 6,
  StartScriptTag = 7,
  StartStyleTag = 8,
  StartTextareaTag = 9,
  StartSelfClosingTag = 10,
  StartCloseTag = 11,
  NoMatchStartCloseTag = 12,
  MismatchedStartCloseTag = 13,
  missingCloseTag = 57,
  IncompleteCloseTag = 14,
  commentContent$1 = 58,
  Element2 = 20,
  TagName = 22,
  Attribute = 23,
  AttributeName = 24,
  AttributeValue = 26,
  UnquotedAttributeValue = 27,
  ScriptText = 28,
  StyleText = 31,
  TextareaText = 34,
  OpenTag = 36,
  CloseTag = 37,
  Dialect_noMatch = 0,
  Dialect_selfClosing = 1
const selfClosers$1 = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
}
const implicitlyClosed = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
}
const closeOnOpen = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
}
function nameChar(ch) {
  return (
    ch == 45 ||
    ch == 46 ||
    ch == 58 ||
    (ch >= 65 && ch <= 90) ||
    ch == 95 ||
    (ch >= 97 && ch <= 122) ||
    ch >= 161
  )
}
function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}
let cachedName = null,
  cachedInput = null,
  cachedPos = 0
function tagNameAfter(input, offset) {
  let pos = input.pos + offset
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset)
  while (isSpace(next)) next = input.peek(++offset)
  let name2 = ''
  for (;;) {
    if (!nameChar(next)) break
    name2 += String.fromCharCode(next)
    next = input.peek(++offset)
  }
  cachedInput = input
  cachedPos = pos
  return (cachedName = name2
    ? name2.toLowerCase()
    : next == question$1 || next == bang
      ? void 0
      : null)
}
const lessThan = 60,
  greaterThan = 62,
  slash$1 = 47,
  question$1 = 63,
  bang = 33,
  dash$1 = 45
function ElementContext(name2, parent) {
  this.name = name2
  this.parent = parent
}
const startTagTerms = [
  StartTag,
  StartSelfClosingTag,
  StartScriptTag,
  StartStyleTag,
  StartTextareaTag
]
const elementContext = new ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1
      ? new ElementContext(tagNameAfter(input, 1) || '', context)
      : context
  },
  reduce(context, term) {
    return term == Element2 && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || '', context)
      : context
  },
  strict: false
})
const tagStart = new ExternalTokenizer(
  (input, stack) => {
    if (input.next != lessThan) {
      if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag)
      return
    }
    input.advance()
    let close = input.next == slash$1
    if (close) input.advance()
    let name2 = tagNameAfter(input, 0)
    if (name2 === void 0) return
    if (!name2) return input.acceptToken(close ? IncompleteCloseTag : StartTag)
    let parent = stack.context ? stack.context.name : null
    if (close) {
      if (name2 == parent) return input.acceptToken(StartCloseTag)
      if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
      if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
      for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name2) return
      input.acceptToken(MismatchedStartCloseTag)
    } else {
      if (name2 == 'script') return input.acceptToken(StartScriptTag)
      if (name2 == 'style') return input.acceptToken(StartStyleTag)
      if (name2 == 'textarea') return input.acceptToken(StartTextareaTag)
      if (selfClosers$1.hasOwnProperty(name2)) return input.acceptToken(StartSelfClosingTag)
      if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2])
        input.acceptToken(missingCloseTag, -1)
      else input.acceptToken(StartTag)
    }
  },
  { contextual: true }
)
const commentContent = new ExternalTokenizer((input) => {
  for (let dashes = 0, i = 0; ; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1)
      break
    }
    if (input.next == dash$1) {
      dashes++
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i >= 3) input.acceptToken(commentContent$1, -2)
      break
    } else {
      dashes = 0
    }
    input.advance()
  }
})
function inForeignElement(context) {
  for (; context; context = context.parent)
    if (context.name == 'svg' || context.name == 'math') return true
  return false
}
const endTag = new ExternalTokenizer((input, stack) => {
  if (input.next == slash$1 && input.peek(1) == greaterThan) {
    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context)
    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2)
  } else if (input.next == greaterThan) {
    input.acceptToken(EndTag, 1)
  }
})
function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length
  return new ExternalTokenizer((input) => {
    for (let state = 0, matchedLen = 0, i = 0; ; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken)
        break
      }
      if (
        (state == 0 && input.next == lessThan) ||
        (state == 1 && input.next == slash$1) ||
        (state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2))
      ) {
        state++
        matchedLen++
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen) input.acceptToken(textToken, -matchedLen)
        else input.acceptToken(endToken, -(matchedLen - 2))
        break
      } else if ((input.next == 10 || input.next == 13) && i) {
        input.acceptToken(textToken, 1)
        break
      } else {
        state = matchedLen = 0
      }
      input.advance()
    }
  })
}
const scriptTokens = contentTokenizer('script', scriptText, StartCloseScriptTag)
const styleTokens = contentTokenizer('style', styleText, StartCloseStyleTag)
const textareaTokens = contentTokenizer('textarea', textareaText, StartCloseTextareaTag)
const htmlHighlighting = styleTags({
  'Text RawText': tags$1.content,
  'StartTag StartCloseTag SelfClosingEndTag EndTag': tags$1.angleBracket,
  TagName: tags$1.tagName,
  'MismatchedCloseTag/TagName': [tags$1.tagName, tags$1.invalid],
  AttributeName: tags$1.attributeName,
  'AttributeValue UnquotedAttributeValue': tags$1.attributeValue,
  Is: tags$1.definitionOperator,
  'EntityReference CharacterReference': tags$1.character,
  Comment: tags$1.blockComment,
  ProcessingInst: tags$1.processingInstruction,
  DoctypeDecl: tags$1.documentMeta
})
const parser$5 = LRParser.deserialize({
  version: 14,
  states:
    ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData:
    ',]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~',
  goto: '%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp',
  nodeNames:
    '⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl',
  maxTerm: 67,
  context: elementContext,
  nodeProps: [
    [
      'closedBy',
      -10,
      1,
      2,
      3,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      'EndTag',
      6,
      'EndTag SelfClosingEndTag',
      -4,
      21,
      30,
      33,
      36,
      'CloseTag'
    ],
    ['openedBy', 4, 'StartTag StartCloseTag', 5, 'StartTag', -4, 29, 32, 35, 37, 'OpenTag'],
    [
      'group',
      -9,
      14,
      17,
      18,
      19,
      20,
      39,
      40,
      41,
      42,
      'Entity',
      16,
      'Entity TextContent',
      -3,
      28,
      31,
      34,
      'TextContent Entity'
    ],
    ['isolate', -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, 'ltr', -3, 26, 27, 39, '']
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData:
    "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [
    scriptTokens,
    styleTokens,
    textareaTokens,
    endTag,
    tagStart,
    commentContent,
    0,
    1,
    2,
    3,
    4,
    5
  ],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
})
function getAttrs$1(openTag, input) {
  let attrs = /* @__PURE__ */ Object.create(null)
  for (let att of openTag.getChildren(Attribute)) {
    let name2 = att.getChild(AttributeName),
      value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue)
    if (name2)
      attrs[input.read(name2.from, name2.to)] = !value
        ? ''
        : value.type.id == AttributeValue
          ? input.read(value.from + 1, value.to - 1)
          : input.read(value.from, value.to)
  }
  return attrs
}
function findTagName(openTag, input) {
  let tagNameNode = openTag.getChild(TagName)
  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : ' '
}
function maybeNest(node, input, tags2) {
  let attrs
  for (let tag of tags2) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs$1(node.node.parent.firstChild, input))))
      return { parser: tag.parser }
  }
  return null
}
function configureNesting(tags2 = [], attributes = []) {
  let script = [],
    style = [],
    textarea = [],
    other = []
  for (let tag of tags2) {
    let array =
      tag.tag == 'script'
        ? script
        : tag.tag == 'style'
          ? style
          : tag.tag == 'textarea'
            ? textarea
            : other
    array.push(tag)
  }
  let attrs = attributes.length ? /* @__PURE__ */ Object.create(null) : null
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr)
  return parseMixed((node, input) => {
    let id2 = node.type.id
    if (id2 == ScriptText) return maybeNest(node, input, script)
    if (id2 == StyleText) return maybeNest(node, input, style)
    if (id2 == TextareaText) return maybeNest(node, input, textarea)
    if (id2 == Element2 && other.length) {
      let n2 = node.node,
        open = n2.firstChild,
        tagName = open && findTagName(open, input),
        attrs2
      if (tagName)
        for (let tag of other) {
          if (
            tag.tag == tagName &&
            (!tag.attrs || tag.attrs(attrs2 || (attrs2 = getAttrs$1(open, input))))
          ) {
            let close = n2.lastChild
            let to = close.type.id == CloseTag ? close.from : n2.to
            if (to > open.to) return { parser: tag.parser, overlay: [{ from: open.to, to }] }
          }
        }
    }
    if (attrs && id2 == Attribute) {
      let n2 = node.node,
        nameNode
      if ((nameNode = n2.firstChild)) {
        let matches = attrs[input.read(nameNode.from, nameNode.to)]
        if (matches)
          for (let attr of matches) {
            if (attr.tagName && attr.tagName != findTagName(n2.parent, input)) continue
            let value = n2.lastChild
            if (value.type.id == AttributeValue) {
              let from = value.from + 1
              let last = value.lastChild,
                to = value.to - (last && last.isError ? 0 : 1)
              if (to > from) return { parser: attr.parser, overlay: [{ from, to }] }
            } else if (value.type.id == UnquotedAttributeValue) {
              return { parser: attr.parser, overlay: [{ from: value.from, to: value.to }] }
            }
          }
      }
    }
    return null
  })
}
const descendantOp = 122,
  Unit = 1,
  identifier$2 = 123,
  callee = 124,
  VariableName = 2,
  queryIdentifier = 125,
  queryVariableName = 3,
  QueryCallee = 4
const space$1 = [
  9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201,
  8202, 8232, 8233, 8239, 8287, 12288
]
const colon = 58,
  parenL = 40,
  underscore = 95,
  bracketL$1 = 91,
  dash = 45,
  period = 46,
  hash = 35,
  percent = 37,
  ampersand = 38,
  backslash = 92,
  newline$1 = 10,
  asterisk = 42
function isAlpha(ch) {
  return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) || ch >= 161
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57
}
function isHex(ch) {
  return isDigit(ch) || (ch >= 97 && ch <= 102) || (ch >= 65 && ch <= 70)
}
const identifierTokens = (id2, varName, callee2) => (input, stack) => {
  for (let inside2 = false, dashes = 0, i = 0; ; i++) {
    let { next } = input
    if (isAlpha(next) || next == dash || next == underscore || (inside2 && isDigit(next))) {
      if (!inside2 && (next != dash || i > 0)) inside2 = true
      if (dashes === i && next == dash) dashes++
      input.advance()
    } else if (next == backslash && input.peek(1) != newline$1) {
      input.advance()
      if (isHex(input.next)) {
        do {
          input.advance()
        } while (isHex(input.next))
        if (input.next == 32) input.advance()
      } else if (input.next > -1) {
        input.advance()
      }
      inside2 = true
    } else {
      if (inside2)
        input.acceptToken(
          dashes == 2 && stack.canShift(VariableName) ? varName : next == parenL ? callee2 : id2
        )
      break
    }
  }
}
const identifiers = new ExternalTokenizer(identifierTokens(identifier$2, VariableName, callee))
const queryIdentifiers = new ExternalTokenizer(
  identifierTokens(queryIdentifier, queryVariableName, QueryCallee)
)
const descendant = new ExternalTokenizer((input) => {
  if (space$1.includes(input.peek(-1))) {
    let { next } = input
    if (
      isAlpha(next) ||
      next == underscore ||
      next == hash ||
      next == period ||
      next == asterisk ||
      next == bracketL$1 ||
      (next == colon && isAlpha(input.peek(1))) ||
      next == dash ||
      next == ampersand
    )
      input.acceptToken(descendantOp)
  }
})
const unitToken = new ExternalTokenizer((input) => {
  if (!space$1.includes(input.peek(-1))) {
    let { next } = input
    if (next == percent) {
      input.advance()
      input.acceptToken(Unit)
    }
    if (isAlpha(next)) {
      do {
        input.advance()
      } while (isAlpha(input.next) || isDigit(input.next))
      input.acceptToken(Unit)
    }
  }
})
const cssHighlighting = styleTags({
  'AtKeyword import charset namespace keyframes media supports': tags$1.definitionKeyword,
  'from to selector': tags$1.keyword,
  NamespaceName: tags$1.namespace,
  KeyframeName: tags$1.labelName,
  KeyframeRangeName: tags$1.operatorKeyword,
  TagName: tags$1.tagName,
  ClassName: tags$1.className,
  PseudoClassName: tags$1.constant(tags$1.className),
  IdName: tags$1.labelName,
  'FeatureName PropertyName': tags$1.propertyName,
  AttributeName: tags$1.attributeName,
  NumberLiteral: tags$1.number,
  KeywordQuery: tags$1.keyword,
  UnaryQueryOp: tags$1.operatorKeyword,
  'CallTag ValueName': tags$1.atom,
  VariableName: tags$1.variableName,
  Callee: tags$1.operatorKeyword,
  Unit: tags$1.unit,
  'UniversalSelector NestingSelector': tags$1.definitionOperator,
  'MatchOp CompareOp': tags$1.compareOperator,
  'ChildOp SiblingOp, LogicOp': tags$1.logicOperator,
  BinOp: tags$1.arithmeticOperator,
  Important: tags$1.modifier,
  Comment: tags$1.blockComment,
  ColorLiteral: tags$1.color,
  'ParenthesizedContent StringLiteral': tags$1.string,
  ':': tags$1.punctuation,
  'PseudoOp #': tags$1.derefOperator,
  '; ,': tags$1.separator,
  '( )': tags$1.paren,
  '[ ]': tags$1.squareBracket,
  '{ }': tags$1.brace
})
const spec_callee = {
  __proto__: null,
  lang: 38,
  'nth-child': 38,
  'nth-last-child': 38,
  'nth-of-type': 38,
  'nth-last-of-type': 38,
  dir: 38,
  'host-context': 38,
  if: 84,
  url: 124,
  'url-prefix': 124,
  domain: 124,
  regexp: 124
}
const spec_queryIdentifier = { __proto__: null, or: 98, and: 98, not: 106, only: 106, layer: 170 }
const spec_QueryCallee = { __proto__: null, selector: 112, layer: 166 }
const spec_AtKeyword = {
  __proto__: null,
  '@import': 162,
  '@media': 174,
  '@charset': 178,
  '@namespace': 182,
  '@keyframes': 188,
  '@supports': 200,
  '@scope': 204
}
const spec_identifier$1 = { __proto__: null, to: 207 }
const parser$4 = LRParser.deserialize({
  version: 14,
  states:
    "EbQYQdOOO#qQdOOP#xO`OOOOQP'#Cf'#CfOOQP'#Ce'#CeO#}QdO'#ChO$nQaO'#CcO$xQdO'#CkO%TQdO'#DpO%YQdO'#DrO%_QdO'#DuO%_QdO'#DxOOQP'#FV'#FVO&eQhO'#EhOOQS'#FU'#FUOOQS'#Ek'#EkQYQdOOO&lQdO'#EOO&PQhO'#EUO&lQdO'#EWO'aQdO'#EYO'lQdO'#E]O'tQhO'#EcO(VQdO'#EeO(bQaO'#CfO)VQ`O'#D{O)[Q`O'#F`O)gQdO'#F`QOQ`OOP)qO&jO'#CaPOOO)C@t)C@tOOQP'#Cj'#CjOOQP,59S,59SO#}QdO,59SO)|QdO,59VO%TQdO,5:[O%YQdO,5:^O%_QdO,5:aO%_QdO,5:cO%_QdO,5:dO%_QdO'#ErO*XQ`O,58}O*aQdO'#DzOOQS,58},58}OOQP'#Cn'#CnOOQO'#Dn'#DnOOQP,59V,59VO*hQ`O,59VO*mQ`O,59VOOQP'#Dq'#DqOOQP,5:[,5:[OOQO'#Ds'#DsO*rQpO,5:^O+]QaO,5:aO+sQaO,5:dOOQW'#DZ'#DZO,ZQhO'#DdO,xQhO'#FaO'tQhO'#DbO-WQ`O'#DhOOQW'#F['#F[O-]Q`O,5;SO-eQ`O'#DeOOQS-E8i-E8iOOQ['#Cs'#CsO-jQdO'#CtO.QQdO'#CzO.hQdO'#C}O/OQ!pO'#DPO1RQ!jO,5:jOOQO'#DU'#DUO*mQ`O'#DTO1cQ!nO'#FXO3`Q`O'#DVO3eQ`O'#DkOOQ['#FX'#FXO-`Q`O,5:pO3jQ!bO,5:rOOQS'#E['#E[O3rQ`O,5:tO3wQdO,5:tOOQO'#E_'#E_O4PQ`O,5:wO4UQhO,5:}O%_QdO'#DgOOQS,5;P,5;PO-eQ`O,5;PO4^QdO,5;PO4fQdO,5:gO4vQdO'#EtO5TQ`O,5;zO5TQ`O,5;zPOOO'#Ej'#EjP5`O&jO,58{POOO,58{,58{OOQP1G.n1G.nOOQP1G.q1G.qO*hQ`O1G.qO*mQ`O1G.qOOQP1G/v1G/vO5kQpO1G/xO5sQaO1G/{O6ZQaO1G/}O6qQaO1G0OO7XQaO,5;^OOQO-E8p-E8pOOQS1G.i1G.iO7cQ`O,5:fO7hQdO'#DoO7oQdO'#CrOOQP1G/x1G/xO&lQdO1G/xO7vQ!jO'#DZO8UQ!bO,59vO8^QhO,5:OOOQO'#F]'#F]O8XQ!bO,59zO'tQhO,59xO8fQhO'#EvO8sQ`O,5;{O9OQhO,59|O9uQhO'#DiOOQW,5:S,5:SOOQS1G0n1G0nOOQW,5:P,5:PO9|Q!fO'#FYOOQS'#FY'#FYOOQS'#Em'#EmO;^QdO,59`OOQ[,59`,59`O;tQdO,59fOOQ[,59f,59fO<[QdO,59iOOQ[,59i,59iOOQ[,59k,59kO&lQdO,59mO<rQhO'#EQOOQW'#EQ'#EQO=WQ`O1G0UO1[QhO1G0UOOQ[,59o,59oO'tQhO'#DXOOQ[,59q,59qO=]Q#tO,5:VOOQS1G0[1G0[OOQS1G0^1G0^OOQS1G0`1G0`O=hQ`O1G0`O=mQdO'#E`OOQS1G0c1G0cOOQS1G0i1G0iO=xQaO,5:RO-`Q`O1G0kOOQS1G0k1G0kO-eQ`O1G0kO>PQ!fO1G0ROOQO1G0R1G0ROOQO,5;`,5;`O>gQdO,5;`OOQO-E8r-E8rO>tQ`O1G1fPOOO-E8h-E8hPOOO1G.g1G.gOOQP7+$]7+$]OOQP7+%d7+%dO&lQdO7+%dOOQS1G0Q1G0QO?PQaO'#F_O?ZQ`O,5:ZO?`Q!fO'#ElO@^QdO'#FWO@hQ`O,59^O@mQ!bO7+%dO&lQdO1G/bO@uQhO1G/fOOQW1G/j1G/jOOQW1G/d1G/dOAWQhO,5;bOOQO-E8t-E8tOAfQhO'#DZOAtQhO'#F^OBPQ`O'#F^OBUQ`O,5:TOOQS-E8k-E8kOOQ[1G.z1G.zOOQ[1G/Q1G/QOOQ[1G/T1G/TOOQ[1G/X1G/XOBZQdO,5:lOOQS7+%p7+%pOB`Q`O7+%pOBeQhO'#DYOBmQ`O,59sO'tQhO,59sOOQ[1G/q1G/qOBuQ`O1G/qOOQS7+%z7+%zOBzQbO'#DPOOQO'#Eb'#EbOCYQ`O'#EaOOQO'#Ea'#EaOCeQ`O'#EwOCmQdO,5:zOOQS,5:z,5:zOOQ[1G/m1G/mOOQS7+&V7+&VO-`Q`O7+&VOCxQ!fO'#EsO&lQdO'#EsOEPQdO7+%mOOQO7+%m7+%mOOQO1G0z1G0zOEdQ!bO<<IOOElQdO'#EqOEvQ`O,5;yOOQP1G/u1G/uOOQS-E8j-E8jOFOQdO'#EpOFYQ`O,5;rOOQ]1G.x1G.xOOQP<<IO<<IOOFbQdO7+$|OOQO'#D]'#D]OFiQ!bO7+%QOFqQhO'#EoOF{Q`O,5;xO&lQdO,5;xOOQW1G/o1G/oOOQO'#ES'#ESOGTQ`O1G0WOOQS<<I[<<I[O&lQdO,59tOGnQhO1G/_OOQ[1G/_1G/_OGuQ`O1G/_OOQW-E8l-E8lOOQ[7+%]7+%]OOQO,5:{,5:{O=pQdO'#ExOCeQ`O,5;cOOQS,5;c,5;cOOQS-E8u-E8uOOQS1G0f1G0fOOQS<<Iq<<IqOG}Q!fO,5;_OOQS-E8q-E8qOOQO<<IX<<IXOOQPAN>jAN>jOIUQaO,5;]OOQO-E8o-E8oOI`QdO,5;[OOQO-E8n-E8nOOQW<<Hh<<HhOOQW<<Hl<<HlOIjQhO<<HlOI{QhO,5;ZOJWQ`O,5;ZOOQO-E8m-E8mOJ]QdO1G1dOBZQdO'#EuOJgQ`O7+%rOOQW7+%r7+%rOJoQ!bO1G/`OOQ[7+$y7+$yOJzQhO7+$yPKRQ`O'#EnOOQO,5;d,5;dOOQO-E8v-E8vOOQS1G0}1G0}OKWQ`OAN>WO&lQdO1G0uOK]Q`O7+'OOOQO,5;a,5;aOOQO-E8s-E8sOOQW<<I^<<I^OOQ[<<He<<HePOQW,5;Y,5;YOOQWG23rG23rOKeQdO7+&a",
  stateData:
    "Kx~O#sOS#tQQ~OW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#oRO~OQiOW[OZ[O]TO`VOaVOi]OjWOmXO!jYO!mZO!saO!ybO!{cO!}dO#QeO#WfO#YgO#ohO~O#m$SP~P!dO#tmO~O#ooO~O]qO`rOarOjsOmtO!juO!mwO#nvO~OpzO!^xO~P$SOc!QO#o|O#p}O~O#o!RO~O#o!TO~OW[OZ[O]TO`VOaVOjWOmXO!jYO!mZO#oRO~OS!]Oe!YO!V![O!Y!`O#q!XOp$TP~Ok$TP~P&POQ!jOe!cOm!dOp!eOr!mOt!mOz!kO!`!lO#o!bO#p!hO#}!fO~Ot!qO!`!lO#o!pO~Ot!sO#o!sO~OS!]Oe!YO!V![O!Y!`O#q!XO~Oe!vOpzO#Z!xO~O]YX`YX`!pXaYXjYXmYXpYX!^YX!jYX!mYX#nYX~O`!zO~Ok!{O#m$SXo$SX~O#m$SXo$SX~P!dO#u#OO#v#OO#w#QO~Oc#UO#o|O#p}O~OpzO!^xO~Oo$SP~P!dOe#`O~Oe#aO~Ol#bO!h#cO~O]qO`rOarOjsOmtO~Op!ia!^!ia!j!ia!m!ia#n!iad!ia~P*zOp!la!^!la!j!la!m!la#n!lad!la~P*zOR#gOS!]Oe!YOr#gOt#gO!V![O!Y!`O#q#dO#}!fO~O!R#iO!^#jOk$TXp$TX~Oe#mO~Ok#oOpzO~Oe!vO~O]#rO`#rOd#uOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl#wO~P&lO]#rO`#rOi#rOj#rOk#rOo#yO~P&lOP#zOSsXesXksXvsX!VsX!YsX!usX!wsX#qsX!TsXQsX]sX`sXdsXisXjsXmsXpsXrsXtsXzsX!`sX#osX#psX#}sXlsXosX!^sX!qsX#msX~Ov#{O!u#|O!w#}Ok$TP~P'tOe#aOS#{Xk#{Xv#{X!V#{X!Y#{X!u#{X!w#{X#q#{XQ#{X]#{X`#{Xd#{Xi#{Xj#{Xm#{Xp#{Xr#{Xt#{Xz#{X!`#{X#o#{X#p#{X#}#{Xl#{Xo#{X!^#{X!q#{X#m#{X~Oe$RO~Oe$TO~Ok$VOv#{O~Ok$WO~Ot$XO!`!lO~Op$YO~OpzO!R#iO~OpzO#Z$`O~O!q$bOk!oa#m!oao!oa~P&lOk#hX#m#hXo#hX~P!dOk!{O#m$Sao$Sa~O#u#OO#v#OO#w$hO~Ol$jO!h$kO~Op!ii!^!ii!j!ii!m!ii#n!iid!ii~P*zOp!ki!^!ki!j!ki!m!ki#n!kid!ki~P*zOp!li!^!li!j!li!m!li#n!lid!li~P*zOp#fa!^#fa~P$SOo$lO~Od$RP~P%_Od#zP~P&lO`!PXd}X!R}X!T!PX~O`$sO!T$tO~Od$uO!R#iO~Ok#jXp#jX!^#jX~P'tO!^#jOk$Tap$Ta~O!R#iOk!Uap!Ua!^!Uad!Ua`!Ua~OS!]Oe!YO!V![O!Y!`O#q$yO~Od$QP~P9dOv#{OQ#|X]#|X`#|Xd#|Xe#|Xi#|Xj#|Xk#|Xm#|Xp#|Xr#|Xt#|Xz#|X!`#|X#o#|X#p#|X#}#|Xl#|Xo#|X~O]#rO`#rOd%OOi#rOj#rOk#rO~P&lO]#rO`#rOi#rOj#rOk#rOl%PO~P&lO]#rO`#rOi#rOj#rOk#rOo%QO~P&lOe%SOS!tXk!tX!V!tX!Y!tX#q!tX~Ok%TO~Od%YOt%ZO!a%ZO~Ok%[O~Oo%cO#o%^O#}%]O~Od%dO~P$SOv#{O!^%hO!q%jOk!oi#m!oio!oi~P&lOk#ha#m#hao#ha~P!dOk!{O#m$Sio$Si~O!^%mOd$RX~P$SOd%oO~Ov#{OQ#`Xd#`Xe#`Xm#`Xp#`Xr#`Xt#`Xz#`X!^#`X!`#`X#o#`X#p#`X#}#`X~O!^%qOd#zX~P&lOd%sO~Ol%tOv#{O~OR#gOr#gOt#gO#q%vO#}!fO~O!R#iOk#jap#ja!^#ja~O`!PXd}X!R}X!^}X~O!R#iO!^%xOd$QX~O`%zO~Od%{O~O#o%|O~Ok&OO~O`&PO!R#iO~Od&ROk&QO~Od&UO~OP#zOpsX!^sXdsX~O#}%]Op#TX!^#TX~OpzO!^&WO~Oo&[O#o%^O#}%]O~Ov#{OQ#gXe#gXk#gXm#gXp#gXr#gXt#gXz#gX!^#gX!`#gX!q#gX#m#gX#o#gX#p#gX#}#gXo#gX~O!^%hO!q&`Ok!oq#m!oqo!oq~P&lOl&aOv#{O~Od#eX!^#eX~P%_O!^%mOd$Ra~Od#dX!^#dX~P&lO!^%qOd#za~Od&fO~P&lOd&gO!T&hO~Od#cX!^#cX~P9dO!^%xOd$Qa~O]&mOd&oO~OS#bae#ba!V#ba!Y#ba#q#ba~Od&qO~PG]Od&qOk&rO~Ov#{OQ#gae#gak#gam#gap#gar#gat#gaz#ga!^#ga!`#ga!q#ga#m#ga#o#ga#p#ga#}#gao#ga~Od#ea!^#ea~P$SOd#da!^#da~P&lOR#gOr#gOt#gO#q%vO#}%]O~O!R#iOd#ca!^#ca~O`&xO~O!^%xOd$Qi~P&lO]&mOd&|O~Ov#{Od|ik|i~Od&}O~PG]Ok'OO~Od'PO~O!^%xOd$Qq~Od#cq!^#cq~P&lO#s!a#t#}]#}v!m~",
  goto: "2h$UPPPPP$VP$YP$c$uP$cP%X$cPP%_PPP%e%o%oPPPPP%oPP%oP&]P%oP%o'W%oP't'w'}'}(^'}P'}P'}P'}'}P(m'}(yP(|PP)p)v$c)|$c*SP$cP$c$cP*Y*{+YP$YP+aP+dP$YP$YP$YP+j$YP+m+p+s+z$YP$YPP$YP,P,V,f,|-[-b-l-r-x.O.U.`.f.l.rPPPPPPPPPPP.x/R/w/z0|P1U1u2O2R2U2[RnQ_^OP`kz!{$dq[OPYZ`kuvwxz!v!{#`$d%mqSOPYZ`kuvwxz!v!{#`$d%mQpTR#RqQ!OVR#SrQ#S!QS$Q!i!jR$i#U!V!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'Q!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QU#g!Y$t&hU%`$Y%b&WR&V%_!V!iac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QR$S!kQ%W$RR&S%Xk!^]bf!Y![!g#i#j#m$P$R%X%xQ#e!YQ${#mQ%w$tQ&j%xR&w&hQ!ygQ#p!`Q$^!xR%f$`R#n!]!U!mac!c!d!e!z#a#c#t#v#x#{$a$k$p$s%h%i%q%u%z&P&d&l&x'QQ!qdR$X!rQ!PVR#TrQ#S!PR$i#TQ!SWR#VsQ!UXR#WtQ{UQ!wgQ#^yQ#o!_Q$U!nQ$[!uQ$_!yQ%e$^Q&Y%aQ&]%fR&v&XSjPzQ!}kQ$c!{R%k$dZiPkz!{$dR$P!gQ%}%SR&z&mR!rdR!teR$Z!tS%a$Y%bR&t&WV%_$Y%b&WQ#PmR$g#PQ`OSkPzU!a`k$dR$d!{Q$p#aY%p$p%u&d&l'QQ%u$sQ&d%qQ&l%zR'Q&xQ#t!cQ#v!dQ#x!eV$}#t#v#xQ%X$RR&T%XQ%y$zS&k%y&yR&y&lQ%r$pR&e%rQ%n$mR&c%nQyUR#]yQ%i$aR&_%iQ!|jS$e!|$fR$f!}Q&n%}R&{&nQ#k!ZR$x#kQ%b$YR&Z%bQ&X%aR&u&X__OP`kz!{$d^UOP`kz!{$dQ!VYQ!WZQ#XuQ#YvQ#ZwQ#[xQ$]!vQ$m#`R&b%mR$q#aQ!gaQ!oc[#q!c!d!e#t#v#xQ$a!zd$o#a$p$s%q%u%z&d&l&x'QQ$r#cQ%R#{S%g$a%iQ%l$kQ&^%hR&p&P]#s!c!d!e#t#v#xW!Z]b!g$PQ!ufQ#f!YQ#l![Q$v#iQ$w#jQ$z#mS%V$R%XR&i%xQ#h!YQ%w$tR&w&hR$|#mR$n#`QlPR#_zQ!_]Q!nbQ$O!gR%U$P",
  nodeNames:
    '⚠ Unit VariableName VariableName QueryCallee Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector . ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue AtKeyword # ; ] [ BracketedValue } { BracedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee IfExpression if ArgList IfBranch KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp ComparisonQuery CompareOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector ParenthesizedSelector CallQuery ArgList , CallLiteral CallTag ParenthesizedContent PseudoClassName ArgList IdSelector IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp Block Declaration PropertyName Important ImportStatement import Layer layer LayerName layer MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports ScopeStatement scope to AtRule Styles',
  maxTerm: 143,
  nodeProps: [
    ['isolate', -2, 5, 36, ''],
    ['openedBy', 20, '(', 28, '[', 31, '{'],
    ['closedBy', 21, ')', 29, ']', 32, '}']
  ],
  propSources: [cssHighlighting],
  skippedNodes: [0, 5, 106],
  repeatNodeCount: 15,
  tokenData:
    "JQ~R!YOX$qX^%i^p$qpq%iqr({rs-ust/itu6Wuv$qvw7Qwx7cxy9Qyz9cz{9h{|:R|}>t}!O?V!O!P?t!P!Q@]!Q![AU![!]BP!]!^B{!^!_C^!_!`DY!`!aDm!a!b$q!b!cEn!c!}$q!}#OG{#O#P$q#P#QH^#Q#R6W#R#o$q#o#pHo#p#q6W#q#rIQ#r#sIc#s#y$q#y#z%i#z$f$q$f$g%i$g#BY$q#BY#BZ%i#BZ$IS$q$IS$I_%i$I_$I|$q$I|$JO%i$JO$JT$q$JT$JU%i$JU$KV$q$KV$KW%i$KW&FU$q&FU&FV%i&FV;'S$q;'S;=`Iz<%lO$q`$tSOy%Qz;'S%Q;'S;=`%c<%lO%Q`%VS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q`%fP;=`<%l%Q~%nh#s~OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Q~'ah#s~!a`OX%QX^'Y^p%Qpq'Yqy%Qz#y%Q#y#z'Y#z$f%Q$f$g'Y$g#BY%Q#BY#BZ'Y#BZ$IS%Q$IS$I_'Y$I_$I|%Q$I|$JO'Y$JO$JT%Q$JT$JU'Y$JU$KV%Q$KV$KW'Y$KW&FU%Q&FU&FV'Y&FV;'S%Q;'S;=`%c<%lO%Qj)OUOy%Qz#]%Q#]#^)b#^;'S%Q;'S;=`%c<%lO%Qj)gU!a`Oy%Qz#a%Q#a#b)y#b;'S%Q;'S;=`%c<%lO%Qj*OU!a`Oy%Qz#d%Q#d#e*b#e;'S%Q;'S;=`%c<%lO%Qj*gU!a`Oy%Qz#c%Q#c#d*y#d;'S%Q;'S;=`%c<%lO%Qj+OU!a`Oy%Qz#f%Q#f#g+b#g;'S%Q;'S;=`%c<%lO%Qj+gU!a`Oy%Qz#h%Q#h#i+y#i;'S%Q;'S;=`%c<%lO%Qj,OU!a`Oy%Qz#T%Q#T#U,b#U;'S%Q;'S;=`%c<%lO%Qj,gU!a`Oy%Qz#b%Q#b#c,y#c;'S%Q;'S;=`%c<%lO%Qj-OU!a`Oy%Qz#h%Q#h#i-b#i;'S%Q;'S;=`%c<%lO%Qj-iS!qY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Q~-xWOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c<%lO-u~.gOt~~.jRO;'S-u;'S;=`.s;=`O-u~.vXOY-uZr-urs.bs#O-u#O#P.g#P;'S-u;'S;=`/c;=`<%l-u<%lO-u~/fP;=`<%l-uj/nYjYOy%Qz!Q%Q!Q![0^![!c%Q!c!i0^!i#T%Q#T#Z0^#Z;'S%Q;'S;=`%c<%lO%Qj0cY!a`Oy%Qz!Q%Q!Q![1R![!c%Q!c!i1R!i#T%Q#T#Z1R#Z;'S%Q;'S;=`%c<%lO%Qj1WY!a`Oy%Qz!Q%Q!Q![1v![!c%Q!c!i1v!i#T%Q#T#Z1v#Z;'S%Q;'S;=`%c<%lO%Qj1}YrY!a`Oy%Qz!Q%Q!Q![2m![!c%Q!c!i2m!i#T%Q#T#Z2m#Z;'S%Q;'S;=`%c<%lO%Qj2tYrY!a`Oy%Qz!Q%Q!Q![3d![!c%Q!c!i3d!i#T%Q#T#Z3d#Z;'S%Q;'S;=`%c<%lO%Qj3iY!a`Oy%Qz!Q%Q!Q![4X![!c%Q!c!i4X!i#T%Q#T#Z4X#Z;'S%Q;'S;=`%c<%lO%Qj4`YrY!a`Oy%Qz!Q%Q!Q![5O![!c%Q!c!i5O!i#T%Q#T#Z5O#Z;'S%Q;'S;=`%c<%lO%Qj5TY!a`Oy%Qz!Q%Q!Q![5s![!c%Q!c!i5s!i#T%Q#T#Z5s#Z;'S%Q;'S;=`%c<%lO%Qj5zSrY!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qd6ZUOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qd6tS!hS!a`Oy%Qz;'S%Q;'S;=`%c<%lO%Qb7VSZQOy%Qz;'S%Q;'S;=`%c<%lO%Q~7fWOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z<%lO7c~8RRO;'S7c;'S;=`8[;=`O7c~8_XOY7cZw7cwx.bx#O7c#O#P8O#P;'S7c;'S;=`8z;=`<%l7c<%lO7c~8}P;=`<%l7cj9VSeYOy%Qz;'S%Q;'S;=`%c<%lO%Q~9hOd~n9oUWQvWOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Qj:YWvW!mQOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj:wU!a`Oy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Qj;bY!a`#}YOy%Qz!Q%Q!Q![;Z![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj<VY!a`Oy%Qz{%Q{|<u|}%Q}!O<u!O!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj<zU!a`Oy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj=eU!a`#}YOy%Qz!Q%Q!Q![=^![;'S%Q;'S;=`%c<%lO%Qj>O[!a`#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%Qj>yS!^YOy%Qz;'S%Q;'S;=`%c<%lO%Qj?[WvWOy%Qz!O%Q!O!P:r!P!Q%Q!Q![=w![;'S%Q;'S;=`%c<%lO%Qj?yU]YOy%Qz!Q%Q!Q![;Z![;'S%Q;'S;=`%c<%lO%Q~@bTvWOy%Qz{@q{;'S%Q;'S;=`%c<%lO%Q~@xS!a`#t~Oy%Qz;'S%Q;'S;=`%c<%lO%QjAZ[#}YOy%Qz!O%Q!O!P;Z!P!Q%Q!Q![=w![!g%Q!g!h<Q!h#X%Q#X#Y<Q#Y;'S%Q;'S;=`%c<%lO%QjBUU`YOy%Qz![%Q![!]Bh!];'S%Q;'S;=`%c<%lO%QbBoSaQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjCQSkYOy%Qz;'S%Q;'S;=`%c<%lO%QhCcU!TWOy%Qz!_%Q!_!`Cu!`;'S%Q;'S;=`%c<%lO%QhC|S!TW!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QlDaS!TW!hSOy%Qz;'S%Q;'S;=`%c<%lO%QjDtV!jQ!TWOy%Qz!_%Q!_!`Cu!`!aEZ!a;'S%Q;'S;=`%c<%lO%QbEbS!jQ!a`Oy%Qz;'S%Q;'S;=`%c<%lO%QjEqYOy%Qz}%Q}!OFa!O!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjFfW!a`Oy%Qz!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjGV[iY!a`Oy%Qz}%Q}!OGO!O!Q%Q!Q![GO![!c%Q!c!}GO!}#T%Q#T#oGO#o;'S%Q;'S;=`%c<%lO%QjHQSmYOy%Qz;'S%Q;'S;=`%c<%lO%QnHcSl^Oy%Qz;'S%Q;'S;=`%c<%lO%QjHtSpYOy%Qz;'S%Q;'S;=`%c<%lO%QjIVSoYOy%Qz;'S%Q;'S;=`%c<%lO%QfIhU!mQOy%Qz!_%Q!_!`6m!`;'S%Q;'S;=`%c<%lO%Q`I}P;=`<%l$q",
  tokenizers: [
    descendant,
    unitToken,
    identifiers,
    queryIdentifiers,
    1,
    2,
    3,
    4,
    new LocalTokenGroup('m~RRYZ[z{a~~g~aO#v~~dP!P!Qg~lO#w~~', 28, 129)
  ],
  topRules: { StyleSheet: [0, 6], Styles: [1, 105] },
  specialized: [
    { term: 124, get: (value) => spec_callee[value] || -1 },
    { term: 125, get: (value) => spec_queryIdentifier[value] || -1 },
    { term: 4, get: (value) => spec_QueryCallee[value] || -1 },
    { term: 25, get: (value) => spec_AtKeyword[value] || -1 },
    { term: 123, get: (value) => spec_identifier$1[value] || -1 }
  ],
  tokenPrec: 1963
})
let _properties = null
function properties() {
  if (!_properties && typeof document == 'object' && document.body) {
    let { style } = document.body,
      names = [],
      seen = /* @__PURE__ */ new Set()
    for (let prop in style)
      if (prop != 'cssText' && prop != 'cssFloat') {
        if (typeof style[prop] == 'string') {
          if (/[A-Z]/.test(prop)) prop = prop.replace(/[A-Z]/g, (ch) => '-' + ch.toLowerCase())
          if (!seen.has(prop)) {
            names.push(prop)
            seen.add(prop)
          }
        }
      }
    _properties = names
      .sort()
      .map((name2) => ({ type: 'property', label: name2, apply: name2 + ': ' }))
  }
  return _properties || []
}
const pseudoClasses = /* @__PURE__ */ [
  'active',
  'after',
  'any-link',
  'autofill',
  'backdrop',
  'before',
  'checked',
  'cue',
  'default',
  'defined',
  'disabled',
  'empty',
  'enabled',
  'file-selector-button',
  'first',
  'first-child',
  'first-letter',
  'first-line',
  'first-of-type',
  'focus',
  'focus-visible',
  'focus-within',
  'fullscreen',
  'has',
  'host',
  'host-context',
  'hover',
  'in-range',
  'indeterminate',
  'invalid',
  'is',
  'lang',
  'last-child',
  'last-of-type',
  'left',
  'link',
  'marker',
  'modal',
  'not',
  'nth-child',
  'nth-last-child',
  'nth-last-of-type',
  'nth-of-type',
  'only-child',
  'only-of-type',
  'optional',
  'out-of-range',
  'part',
  'placeholder',
  'placeholder-shown',
  'read-only',
  'read-write',
  'required',
  'right',
  'root',
  'scope',
  'selection',
  'slotted',
  'target',
  'target-text',
  'valid',
  'visited',
  'where'
].map((name2) => ({ type: 'class', label: name2 }))
const values = /* @__PURE__ */ [
  'above',
  'absolute',
  'activeborder',
  'additive',
  'activecaption',
  'after-white-space',
  'ahead',
  'alias',
  'all',
  'all-scroll',
  'alphabetic',
  'alternate',
  'always',
  'antialiased',
  'appworkspace',
  'asterisks',
  'attr',
  'auto',
  'auto-flow',
  'avoid',
  'avoid-column',
  'avoid-page',
  'avoid-region',
  'axis-pan',
  'background',
  'backwards',
  'baseline',
  'below',
  'bidi-override',
  'blink',
  'block',
  'block-axis',
  'bold',
  'bolder',
  'border',
  'border-box',
  'both',
  'bottom',
  'break',
  'break-all',
  'break-word',
  'bullets',
  'button',
  'button-bevel',
  'buttonface',
  'buttonhighlight',
  'buttonshadow',
  'buttontext',
  'calc',
  'capitalize',
  'caps-lock-indicator',
  'caption',
  'captiontext',
  'caret',
  'cell',
  'center',
  'checkbox',
  'circle',
  'cjk-decimal',
  'clear',
  'clip',
  'close-quote',
  'col-resize',
  'collapse',
  'color',
  'color-burn',
  'color-dodge',
  'column',
  'column-reverse',
  'compact',
  'condensed',
  'contain',
  'content',
  'contents',
  'content-box',
  'context-menu',
  'continuous',
  'copy',
  'counter',
  'counters',
  'cover',
  'crop',
  'cross',
  'crosshair',
  'currentcolor',
  'cursive',
  'cyclic',
  'darken',
  'dashed',
  'decimal',
  'decimal-leading-zero',
  'default',
  'default-button',
  'dense',
  'destination-atop',
  'destination-in',
  'destination-out',
  'destination-over',
  'difference',
  'disc',
  'discard',
  'disclosure-closed',
  'disclosure-open',
  'document',
  'dot-dash',
  'dot-dot-dash',
  'dotted',
  'double',
  'down',
  'e-resize',
  'ease',
  'ease-in',
  'ease-in-out',
  'ease-out',
  'element',
  'ellipse',
  'ellipsis',
  'embed',
  'end',
  'ethiopic-abegede-gez',
  'ethiopic-halehame-aa-er',
  'ethiopic-halehame-gez',
  'ew-resize',
  'exclusion',
  'expanded',
  'extends',
  'extra-condensed',
  'extra-expanded',
  'fantasy',
  'fast',
  'fill',
  'fill-box',
  'fixed',
  'flat',
  'flex',
  'flex-end',
  'flex-start',
  'footnotes',
  'forwards',
  'from',
  'geometricPrecision',
  'graytext',
  'grid',
  'groove',
  'hand',
  'hard-light',
  'help',
  'hidden',
  'hide',
  'higher',
  'highlight',
  'highlighttext',
  'horizontal',
  'hsl',
  'hsla',
  'hue',
  'icon',
  'ignore',
  'inactiveborder',
  'inactivecaption',
  'inactivecaptiontext',
  'infinite',
  'infobackground',
  'infotext',
  'inherit',
  'initial',
  'inline',
  'inline-axis',
  'inline-block',
  'inline-flex',
  'inline-grid',
  'inline-table',
  'inset',
  'inside',
  'intrinsic',
  'invert',
  'italic',
  'justify',
  'keep-all',
  'landscape',
  'large',
  'larger',
  'left',
  'level',
  'lighter',
  'lighten',
  'line-through',
  'linear',
  'linear-gradient',
  'lines',
  'list-item',
  'listbox',
  'listitem',
  'local',
  'logical',
  'loud',
  'lower',
  'lower-hexadecimal',
  'lower-latin',
  'lower-norwegian',
  'lowercase',
  'ltr',
  'luminosity',
  'manipulation',
  'match',
  'matrix',
  'matrix3d',
  'medium',
  'menu',
  'menutext',
  'message-box',
  'middle',
  'min-intrinsic',
  'mix',
  'monospace',
  'move',
  'multiple',
  'multiple_mask_images',
  'multiply',
  'n-resize',
  'narrower',
  'ne-resize',
  'nesw-resize',
  'no-close-quote',
  'no-drop',
  'no-open-quote',
  'no-repeat',
  'none',
  'normal',
  'not-allowed',
  'nowrap',
  'ns-resize',
  'numbers',
  'numeric',
  'nw-resize',
  'nwse-resize',
  'oblique',
  'opacity',
  'open-quote',
  'optimizeLegibility',
  'optimizeSpeed',
  'outset',
  'outside',
  'outside-shape',
  'overlay',
  'overline',
  'padding',
  'padding-box',
  'painted',
  'page',
  'paused',
  'perspective',
  'pinch-zoom',
  'plus-darker',
  'plus-lighter',
  'pointer',
  'polygon',
  'portrait',
  'pre',
  'pre-line',
  'pre-wrap',
  'preserve-3d',
  'progress',
  'push-button',
  'radial-gradient',
  'radio',
  'read-only',
  'read-write',
  'read-write-plaintext-only',
  'rectangle',
  'region',
  'relative',
  'repeat',
  'repeating-linear-gradient',
  'repeating-radial-gradient',
  'repeat-x',
  'repeat-y',
  'reset',
  'reverse',
  'rgb',
  'rgba',
  'ridge',
  'right',
  'rotate',
  'rotate3d',
  'rotateX',
  'rotateY',
  'rotateZ',
  'round',
  'row',
  'row-resize',
  'row-reverse',
  'rtl',
  'run-in',
  'running',
  's-resize',
  'sans-serif',
  'saturation',
  'scale',
  'scale3d',
  'scaleX',
  'scaleY',
  'scaleZ',
  'screen',
  'scroll',
  'scrollbar',
  'scroll-position',
  'se-resize',
  'self-start',
  'self-end',
  'semi-condensed',
  'semi-expanded',
  'separate',
  'serif',
  'show',
  'single',
  'skew',
  'skewX',
  'skewY',
  'skip-white-space',
  'slide',
  'slider-horizontal',
  'slider-vertical',
  'sliderthumb-horizontal',
  'sliderthumb-vertical',
  'slow',
  'small',
  'small-caps',
  'small-caption',
  'smaller',
  'soft-light',
  'solid',
  'source-atop',
  'source-in',
  'source-out',
  'source-over',
  'space',
  'space-around',
  'space-between',
  'space-evenly',
  'spell-out',
  'square',
  'start',
  'static',
  'status-bar',
  'stretch',
  'stroke',
  'stroke-box',
  'sub',
  'subpixel-antialiased',
  'svg_masks',
  'super',
  'sw-resize',
  'symbolic',
  'symbols',
  'system-ui',
  'table',
  'table-caption',
  'table-cell',
  'table-column',
  'table-column-group',
  'table-footer-group',
  'table-header-group',
  'table-row',
  'table-row-group',
  'text',
  'text-bottom',
  'text-top',
  'textarea',
  'textfield',
  'thick',
  'thin',
  'threeddarkshadow',
  'threedface',
  'threedhighlight',
  'threedlightshadow',
  'threedshadow',
  'to',
  'top',
  'transform',
  'translate',
  'translate3d',
  'translateX',
  'translateY',
  'translateZ',
  'transparent',
  'ultra-condensed',
  'ultra-expanded',
  'underline',
  'unidirectional-pan',
  'unset',
  'up',
  'upper-latin',
  'uppercase',
  'url',
  'var',
  'vertical',
  'vertical-text',
  'view-box',
  'visible',
  'visibleFill',
  'visiblePainted',
  'visibleStroke',
  'visual',
  'w-resize',
  'wait',
  'wave',
  'wider',
  'window',
  'windowframe',
  'windowtext',
  'words',
  'wrap',
  'wrap-reverse',
  'x-large',
  'x-small',
  'xor',
  'xx-large',
  'xx-small'
]
  .map((name2) => ({ type: 'keyword', label: name2 }))
  .concat(
    /* @__PURE__ */ [
      'aliceblue',
      'antiquewhite',
      'aqua',
      'aquamarine',
      'azure',
      'beige',
      'bisque',
      'black',
      'blanchedalmond',
      'blue',
      'blueviolet',
      'brown',
      'burlywood',
      'cadetblue',
      'chartreuse',
      'chocolate',
      'coral',
      'cornflowerblue',
      'cornsilk',
      'crimson',
      'cyan',
      'darkblue',
      'darkcyan',
      'darkgoldenrod',
      'darkgray',
      'darkgreen',
      'darkkhaki',
      'darkmagenta',
      'darkolivegreen',
      'darkorange',
      'darkorchid',
      'darkred',
      'darksalmon',
      'darkseagreen',
      'darkslateblue',
      'darkslategray',
      'darkturquoise',
      'darkviolet',
      'deeppink',
      'deepskyblue',
      'dimgray',
      'dodgerblue',
      'firebrick',
      'floralwhite',
      'forestgreen',
      'fuchsia',
      'gainsboro',
      'ghostwhite',
      'gold',
      'goldenrod',
      'gray',
      'grey',
      'green',
      'greenyellow',
      'honeydew',
      'hotpink',
      'indianred',
      'indigo',
      'ivory',
      'khaki',
      'lavender',
      'lavenderblush',
      'lawngreen',
      'lemonchiffon',
      'lightblue',
      'lightcoral',
      'lightcyan',
      'lightgoldenrodyellow',
      'lightgray',
      'lightgreen',
      'lightpink',
      'lightsalmon',
      'lightseagreen',
      'lightskyblue',
      'lightslategray',
      'lightsteelblue',
      'lightyellow',
      'lime',
      'limegreen',
      'linen',
      'magenta',
      'maroon',
      'mediumaquamarine',
      'mediumblue',
      'mediumorchid',
      'mediumpurple',
      'mediumseagreen',
      'mediumslateblue',
      'mediumspringgreen',
      'mediumturquoise',
      'mediumvioletred',
      'midnightblue',
      'mintcream',
      'mistyrose',
      'moccasin',
      'navajowhite',
      'navy',
      'oldlace',
      'olive',
      'olivedrab',
      'orange',
      'orangered',
      'orchid',
      'palegoldenrod',
      'palegreen',
      'paleturquoise',
      'palevioletred',
      'papayawhip',
      'peachpuff',
      'peru',
      'pink',
      'plum',
      'powderblue',
      'purple',
      'rebeccapurple',
      'red',
      'rosybrown',
      'royalblue',
      'saddlebrown',
      'salmon',
      'sandybrown',
      'seagreen',
      'seashell',
      'sienna',
      'silver',
      'skyblue',
      'slateblue',
      'slategray',
      'snow',
      'springgreen',
      'steelblue',
      'tan',
      'teal',
      'thistle',
      'tomato',
      'turquoise',
      'violet',
      'wheat',
      'white',
      'whitesmoke',
      'yellow',
      'yellowgreen'
    ].map((name2) => ({ type: 'constant', label: name2 }))
  )
const tags = /* @__PURE__ */ [
  'a',
  'abbr',
  'address',
  'article',
  'aside',
  'b',
  'bdi',
  'bdo',
  'blockquote',
  'body',
  'br',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'col',
  'colgroup',
  'dd',
  'del',
  'details',
  'dfn',
  'dialog',
  'div',
  'dl',
  'dt',
  'em',
  'figcaption',
  'figure',
  'footer',
  'form',
  'header',
  'hgroup',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'hr',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'label',
  'legend',
  'li',
  'main',
  'meter',
  'nav',
  'ol',
  'output',
  'p',
  'pre',
  'ruby',
  'section',
  'select',
  'small',
  'source',
  'span',
  'strong',
  'sub',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'template',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'tr',
  'u',
  'ul'
].map((name2) => ({ type: 'type', label: name2 }))
const atRules = /* @__PURE__ */ [
  '@charset',
  '@color-profile',
  '@container',
  '@counter-style',
  '@font-face',
  '@font-feature-values',
  '@font-palette-values',
  '@import',
  '@keyframes',
  '@layer',
  '@media',
  '@namespace',
  '@page',
  '@position-try',
  '@property',
  '@scope',
  '@starting-style',
  '@supports',
  '@view-transition'
].map((label) => ({ type: 'keyword', label }))
const identifier$1 = /^(\w[\w-]*|-\w[\w-]*|)$/,
  variable = /^-(-[\w-]*)?$/
function isVarArg(node, doc2) {
  var _a2
  if (node.name == '(' || node.type.isError) node = node.parent || node
  if (node.name != 'ArgList') return false
  let callee2 = (_a2 = node.parent) === null || _a2 === void 0 ? void 0 : _a2.firstChild
  if ((callee2 === null || callee2 === void 0 ? void 0 : callee2.name) != 'Callee') return false
  return doc2.sliceString(callee2.from, callee2.to) == 'var'
}
const VariablesByNode = /* @__PURE__ */ new NodeWeakMap()
const declSelector = ['Declaration']
function astTop(node) {
  for (let cur2 = node; ; ) {
    if (cur2.type.isTop) return cur2
    if (!(cur2 = cur2.parent)) return node
  }
}
function variableNames(doc2, node, isVariable) {
  if (node.to - node.from > 4096) {
    let known = VariablesByNode.get(node)
    if (known) return known
    let result = [],
      seen = /* @__PURE__ */ new Set(),
      cursor2 = node.cursor(IterMode.IncludeAnonymous)
    if (cursor2.firstChild())
      do {
        for (let option of variableNames(doc2, cursor2.node, isVariable))
          if (!seen.has(option.label)) {
            seen.add(option.label)
            result.push(option)
          }
      } while (cursor2.nextSibling())
    VariablesByNode.set(node, result)
    return result
  } else {
    let result = [],
      seen = /* @__PURE__ */ new Set()
    node.cursor().iterate((node2) => {
      var _a2
      if (
        isVariable(node2) &&
        node2.matchContext(declSelector) &&
        ((_a2 = node2.node.nextSibling) === null || _a2 === void 0 ? void 0 : _a2.name) == ':'
      ) {
        let name2 = doc2.sliceString(node2.from, node2.to)
        if (!seen.has(name2)) {
          seen.add(name2)
          result.push({ label: name2, type: 'variable' })
        }
      }
    })
    return result
  }
}
const defineCSSCompletionSource = (isVariable) => (context) => {
  let { state, pos } = context,
    node = syntaxTree(state).resolveInner(pos, -1)
  let isDash =
    node.type.isError &&
    node.from == node.to - 1 &&
    state.doc.sliceString(node.from, node.to) == '-'
  if (
    node.name == 'PropertyName' ||
    ((isDash || node.name == 'TagName') && /^(Block|Styles)$/.test(node.resolve(node.to).name))
  )
    return { from: node.from, options: properties(), validFor: identifier$1 }
  if (node.name == 'ValueName') return { from: node.from, options: values, validFor: identifier$1 }
  if (node.name == 'PseudoClassName')
    return { from: node.from, options: pseudoClasses, validFor: identifier$1 }
  if (isVariable(node) || ((context.explicit || isDash) && isVarArg(node, state.doc)))
    return {
      from: isVariable(node) || isDash ? node.from : pos,
      options: variableNames(state.doc, astTop(node), isVariable),
      validFor: variable
    }
  if (node.name == 'TagName') {
    for (let { parent } = node; parent; parent = parent.parent)
      if (parent.name == 'Block')
        return { from: node.from, options: properties(), validFor: identifier$1 }
    return { from: node.from, options: tags, validFor: identifier$1 }
  }
  if (node.name == 'AtKeyword') return { from: node.from, options: atRules, validFor: identifier$1 }
  if (!context.explicit) return null
  let above = node.resolve(pos),
    before = above.childBefore(pos)
  if (before && before.name == ':' && above.name == 'PseudoClassSelector')
    return { from: pos, options: pseudoClasses, validFor: identifier$1 }
  if ((before && before.name == ':' && above.name == 'Declaration') || above.name == 'ArgList')
    return { from: pos, options: values, validFor: identifier$1 }
  if (above.name == 'Block' || above.name == 'Styles')
    return { from: pos, options: properties(), validFor: identifier$1 }
  return null
}
const cssCompletionSource = /* @__PURE__ */ defineCSSCompletionSource(
  (n2) => n2.name == 'VariableName'
)
const cssLanguage = /* @__PURE__ */ LRLanguage.define({
  name: 'css',
  parser: /* @__PURE__ */ parser$4.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Declaration: /* @__PURE__ */ continuedIndent()
      }),
      /* @__PURE__ */ foldNodeProp.add({
        'Block KeyframeList': foldInside
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: '/*', close: '*/' } },
    indentOnInput: /^\s*\}$/,
    wordChars: '-'
  }
})
function css$1() {
  return new LanguageSupport(
    cssLanguage,
    cssLanguage.data.of({ autocomplete: cssCompletionSource })
  )
}
const index$3 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      css: css$1,
      cssCompletionSource,
      cssLanguage,
      defineCSSCompletionSource
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const noSemi = 315,
  noSemiType = 316,
  incdec = 1,
  incdecPrefix = 2,
  questionDot = 3,
  JSXStartTag = 4,
  insertSemi = 317,
  spaces = 319,
  newline = 320,
  LineComment = 5,
  BlockComment = 6,
  Dialect_jsx = 0
const space = [
  9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201,
  8202, 8232, 8233, 8239, 8287, 12288
]
const braceR = 125,
  semicolon = 59,
  slash = 47,
  star = 42,
  plus = 43,
  minus = 45,
  lt = 60,
  comma = 44,
  question = 63,
  dot = 46,
  bracketL = 91
const trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline
  },
  strict: false
})
const insertSemicolon = new ExternalTokenizer(
  (input, stack) => {
    let { next } = input
    if (next == braceR || next == -1 || stack.context) input.acceptToken(insertSemi)
  },
  { contextual: true, fallback: true }
)
const noSemicolon = new ExternalTokenizer(
  (input, stack) => {
    let { next } = input,
      after
    if (space.indexOf(next) > -1) return
    if (next == slash && ((after = input.peek(1)) == slash || after == star)) return
    if (next != braceR && next != semicolon && next != -1 && !stack.context)
      input.acceptToken(noSemi)
  },
  { contextual: true }
)
const noSemicolonType = new ExternalTokenizer(
  (input, stack) => {
    if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType)
  },
  { contextual: true }
)
const operatorToken = new ExternalTokenizer(
  (input, stack) => {
    let { next } = input
    if (next == plus || next == minus) {
      input.advance()
      if (next == input.next) {
        input.advance()
        let mayPostfix = !stack.context && stack.canShift(incdec)
        input.acceptToken(mayPostfix ? incdec : incdecPrefix)
      }
    } else if (next == question && input.peek(1) == dot) {
      input.advance()
      input.advance()
      if (input.next < 48 || input.next > 57) input.acceptToken(questionDot)
    }
  },
  { contextual: true }
)
function identifierChar(ch, start) {
  return (
    (ch >= 65 && ch <= 90) ||
    (ch >= 97 && ch <= 122) ||
    ch == 95 ||
    ch >= 192 ||
    (!start && ch >= 48 && ch <= 57)
  )
}
const jsx = new ExternalTokenizer((input, stack) => {
  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return
  input.advance()
  if (input.next == slash) return
  let back = 0
  while (space.indexOf(input.next) > -1) {
    input.advance()
    back++
  }
  if (identifierChar(input.next, true)) {
    input.advance()
    back++
    while (identifierChar(input.next, false)) {
      input.advance()
      back++
    }
    while (space.indexOf(input.next) > -1) {
      input.advance()
      back++
    }
    if (input.next == comma) return
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!identifierChar(input.next, true)) return
        break
      }
      if (input.next != 'extends'.charCodeAt(i)) break
      input.advance()
      back++
    }
  }
  input.acceptToken(JSXStartTag, -back)
})
const jsHighlight = styleTags({
  'get set async static': tags$1.modifier,
  'for while do if else switch try catch finally return throw break continue default case':
    tags$1.controlKeyword,
  'in of await yield void typeof delete instanceof as satisfies': tags$1.operatorKeyword,
  'let var const using function class extends': tags$1.definitionKeyword,
  'import export from': tags$1.moduleKeyword,
  'with debugger new': tags$1.keyword,
  TemplateString: tags$1.special(tags$1.string),
  super: tags$1.atom,
  BooleanLiteral: tags$1.bool,
  this: tags$1.self,
  null: tags$1.null,
  Star: tags$1.modifier,
  VariableName: tags$1.variableName,
  'CallExpression/VariableName TaggedTemplateExpression/VariableName': tags$1.function(
    tags$1.variableName
  ),
  VariableDefinition: tags$1.definition(tags$1.variableName),
  Label: tags$1.labelName,
  PropertyName: tags$1.propertyName,
  PrivatePropertyName: tags$1.special(tags$1.propertyName),
  'CallExpression/MemberExpression/PropertyName': tags$1.function(tags$1.propertyName),
  'FunctionDeclaration/VariableDefinition': tags$1.function(tags$1.definition(tags$1.variableName)),
  'ClassDeclaration/VariableDefinition': tags$1.definition(tags$1.className),
  'NewExpression/VariableName': tags$1.className,
  PropertyDefinition: tags$1.definition(tags$1.propertyName),
  PrivatePropertyDefinition: tags$1.definition(tags$1.special(tags$1.propertyName)),
  UpdateOp: tags$1.updateOperator,
  'LineComment Hashbang': tags$1.lineComment,
  BlockComment: tags$1.blockComment,
  Number: tags$1.number,
  String: tags$1.string,
  Escape: tags$1.escape,
  ArithOp: tags$1.arithmeticOperator,
  LogicOp: tags$1.logicOperator,
  BitOp: tags$1.bitwiseOperator,
  CompareOp: tags$1.compareOperator,
  RegExp: tags$1.regexp,
  Equals: tags$1.definitionOperator,
  Arrow: tags$1.function(tags$1.punctuation),
  ': Spread': tags$1.punctuation,
  '( )': tags$1.paren,
  '[ ]': tags$1.squareBracket,
  '{ }': tags$1.brace,
  'InterpolationStart InterpolationEnd': tags$1.special(tags$1.brace),
  '.': tags$1.derefOperator,
  ', ;': tags$1.separator,
  '@': tags$1.meta,
  TypeName: tags$1.typeName,
  TypeDefinition: tags$1.definition(tags$1.typeName),
  'type enum interface implements namespace module declare': tags$1.definitionKeyword,
  'abstract global Privacy readonly override': tags$1.modifier,
  'is keyof unique infer asserts': tags$1.operatorKeyword,
  JSXAttributeValue: tags$1.attributeValue,
  JSXText: tags$1.content,
  'JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag': tags$1.angleBracket,
  'JSXIdentifier JSXNameSpacedName': tags$1.tagName,
  'JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName': tags$1.attributeName,
  'JSXBuiltin/JSXIdentifier': tags$1.standard(tags$1.tagName)
})
const spec_identifier = {
  __proto__: null,
  export: 20,
  as: 25,
  from: 33,
  default: 36,
  async: 41,
  function: 42,
  in: 52,
  out: 55,
  const: 56,
  extends: 60,
  this: 64,
  true: 72,
  false: 72,
  null: 84,
  void: 88,
  typeof: 92,
  super: 108,
  new: 142,
  delete: 154,
  yield: 163,
  await: 167,
  class: 172,
  public: 235,
  private: 235,
  protected: 235,
  readonly: 237,
  instanceof: 256,
  satisfies: 259,
  import: 292,
  keyof: 349,
  unique: 353,
  infer: 359,
  asserts: 395,
  is: 397,
  abstract: 417,
  implements: 419,
  type: 421,
  let: 424,
  var: 426,
  using: 429,
  interface: 435,
  enum: 439,
  namespace: 445,
  module: 447,
  declare: 451,
  global: 455,
  for: 474,
  of: 483,
  while: 486,
  with: 490,
  do: 494,
  if: 498,
  else: 500,
  switch: 504,
  case: 510,
  try: 516,
  catch: 520,
  finally: 524,
  return: 528,
  throw: 532,
  break: 536,
  continue: 540,
  debugger: 544
}
const spec_word = {
  __proto__: null,
  async: 129,
  get: 131,
  set: 133,
  declare: 195,
  public: 197,
  private: 197,
  protected: 197,
  static: 199,
  abstract: 201,
  override: 203,
  readonly: 209,
  accessor: 211,
  new: 401
}
const spec_LessThan = { __proto__: null, '<': 193 }
const parser$3 = LRParser.deserialize({
  version: 14,
  states:
    "$EOQ%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Ik'#IkO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JqO6[Q!0MxO'#JrO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO7eQMhO'#F|O9[Q`O'#F{OOQ!0Lf'#Jr'#JrOOQ!0Lb'#Jq'#JqO9aQ`O'#GwOOQ['#K^'#K^O9lQ`O'#IXO9qQ!0LrO'#IYOOQ['#J_'#J_OOQ['#I^'#I^Q`QlOOQ`QlOOO9yQ!L^O'#DvO:QQlO'#EOO:XQlO'#EQO9gQ`O'#GsO:`QMhO'#CoO:nQ`O'#EnO:yQ`O'#EyO;OQMhO'#FeO;mQ`O'#GsOOQO'#K_'#K_O;rQ`O'#K_O<QQ`O'#G{O<QQ`O'#G|O<QQ`O'#HOO9gQ`O'#HRO<wQ`O'#HUO>`Q`O'#CeO>pQ`O'#HbO>xQ`O'#HhO>xQ`O'#HjO`QlO'#HlO>xQ`O'#HnO>xQ`O'#HqO>}Q`O'#HwO?SQ!0LsO'#H}O%[QlO'#IPO?_Q!0LsO'#IRO?jQ!0LsO'#ITO9qQ!0LrO'#IVO?uQ!0MxO'#CiO@wQpO'#DlQOQ`OOO%[QlO'#EQOA_Q`O'#ETO:`QMhO'#EnOAjQ`O'#EnOAuQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Ju'#JuO%[QlO'#JuOOQO'#Jx'#JxOOQO'#Ig'#IgOBuQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J|'#J|OCqQ!0MSO'#EgOC{QpO'#EWOOQO'#Jw'#JwODaQpO'#JxOEnQpO'#EWOC{QpO'#EgPE{O&2DjO'#CbPOOO)CD|)CD|OOOO'#I_'#I_OFWO#tO,59UOOQ!0Lh,59U,59UOOOO'#I`'#I`OFfO&jO,59UOFtQ!L^O'#DcOOOO'#Ib'#IbOF{O#@ItO,59{OOQ!0Lf,59{,59{OGZQlO'#IcOGnQ`O'#JsOImQ!fO'#JsO+}QlO'#JsOItQ`O,5:ROJ[Q`O'#EpOJiQ`O'#KSOJtQ`O'#KROJtQ`O'#KROJ|Q`O,5;^OKRQ`O'#KQOOQ!0Ln,5:^,5:^OKYQlO,5:^OMWQ!0MxO,5:fOMwQ`O,5:nONbQ!0LrO'#KPONiQ`O'#KOO9aQ`O'#KOON}Q`O'#KOO! VQ`O,5;]O! [Q`O'#KOO!#aQ!fO'#JrOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$PQ!fO,5:sOOQS'#Jy'#JyOOQO-E<i-E<iO9gQ`O,5=_O!$gQ`O,5=_O!$lQlO,5;ZO!&oQMhO'#EkO!(YQ`O,5;ZO!(_QlO'#DyO!(iQpO,5;dO!(qQpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)PQlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IoO!+SQ!0LrO,5<iO%[QlO,5;eO!&oQMhO,5;eO!+qQMhO,5;eO!-cQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-jQ,UO'#FjO!.gQ,UO'#KWO!.RQ,UO'#KWO!.nQ,UO'#KWOOQO'#KW'#KWO!/SQ,UO,5<SOOOW,5<`,5<`O!/eQlO'#FvOOOW'#In'#InO7VO7dO,5<QO!/lQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0]Q$IUO'#CyOOQ!0Lh'#C}'#C}O!0pO#@ItO'#DRO!1^QMjO,5<eO!1eQ`O,5<hO!3QQ(CWO'#GXO!3_Q`O'#GYO!3dQ`O'#GYO!5SQ(CWO'#G^O!6XQpO'#GbOOQO'#Gn'#GnO!+xQMhO'#GmOOQO'#Gp'#GpO!+xQMhO'#GoO!6zQ$IUO'#JkOOQ!0Lh'#Jk'#JkO!7UQ`O'#JjO!7dQ`O'#JiO!7lQ`O'#CuOOQ!0Lh'#C{'#C{O!7}Q`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO1SQ`O'#DZO!+xQMhO'#GPO!+xQMhO'#GRO!8SQ`O'#GTO!8XQ`O'#GUO!3dQ`O'#G[O!+xQMhO'#GaO<QQ`O'#JjO!8^Q`O'#EqO!8{Q`O,5<gOOQ!0Lb'#Cr'#CrO!9TQ`O'#ErO!9}QpO'#EsOOQ!0Lb'#KQ'#KQO!:UQ!0LrO'#K`O9qQ!0LrO,5=cO`QlO,5>sOOQ['#Jg'#JgOOQ[,5>t,5>tOOQ[-E<[-E<[O!<TQ!0MxO,5:bO!9xQpO,5:`O!>nQ!0MxO,5:jO%[QlO,5:jO!AUQ!0MxO,5:lOOQO,5@y,5@yO!AuQMhO,5=_O!BTQ!0LrO'#JhO9[Q`O'#JhO!BfQ!0LrO,59ZO!BqQpO,59ZO!ByQMhO,59ZO:`QMhO,59ZO!CUQ`O,5;ZO!C^Q`O'#HaO!CrQ`O'#KcO%[QlO,5;}O!9xQpO,5<PO!CzQ`O,5=zO!DPQ`O,5=zO!DUQ`O,5=zO9qQ!0LrO,5=zO<QQ`O,5=jOOQO'#Cy'#CyO!DdQpO,5=gO!DlQMhO,5=hO!DwQ`O,5=jO!D|Q!bO,5=mO!EUQ`O'#K_O>}Q`O'#HWO9gQ`O'#HYO!EZQ`O'#HYO:`QMhO'#H[O!E`Q`O'#H[OOQ[,5=p,5=pO!EeQ`O'#H]O!EvQ`O'#CoO!E{Q`O,59PO!FVQ`O,59PO!H[QlO,59POOQ[,59P,59PO!HlQ!0LrO,59PO%[QlO,59PO!JwQlO'#HdOOQ['#He'#HeOOQ['#Hf'#HfO`QlO,5=|O!K_Q`O,5=|O`QlO,5>SO`QlO,5>UO!KdQ`O,5>WO`QlO,5>YO!KiQ`O,5>]O!KnQlO,5>cOOQ[,5>i,5>iO%[QlO,5>iO9qQ!0LrO,5>kOOQ[,5>m,5>mO# xQ`O,5>mOOQ[,5>o,5>oO# xQ`O,5>oOOQ[,5>q,5>qO#!fQpO'#D_O%[QlO'#JuO##XQpO'#JuO##cQpO'#DmO##tQpO'#DmO#&VQlO'#DmO#&^Q`O'#JtO#&fQ`O,5:WO#&kQ`O'#EtO#&yQ`O'#KTO#'RQ`O,5;_O#'WQpO'#DmO#'eQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#'lQ`O,5:oO>}Q`O,5;YO!BqQpO,5;YO!ByQMhO,5;YO:`QMhO,5;YO#'tQ`O,5@aO#'yQ07dO,5:sOOQO-E<e-E<eO#)PQ!0MSO,5;ROC{QpO,5:rO#)ZQpO,5:rOC{QpO,5;RO!BfQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#)hQ!0LrO,5;RO#)sQ!0LrO,5;RO!BqQpO,5:rOOQO,5;X,5;XO#*RQ!0LrO,5;RPOOO'#I]'#I]P#*gO&2DjO,58|POOO,58|,58|OOOO-E<]-E<]OOQ!0Lh1G.p1G.pOOOO-E<^-E<^OOOO,59},59}O#*rQ!bO,59}OOOO-E<`-E<`OOQ!0Lf1G/g1G/gO#*wQ!fO,5>}O+}QlO,5>}OOQO,5?T,5?TO#+RQlO'#IcOOQO-E<a-E<aO#+`Q`O,5@_O#+hQ!fO,5@_O#+oQ`O,5@mOOQ!0Lf1G/m1G/mO%[QlO,5@nO#+wQ`O'#IiOOQO-E<g-E<gO#+oQ`O,5@mOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@kO#,]Q!0LrO,5@kO#,nQ!0LrO,5@kO#,uQ`O,5@jO9aQ`O,5@jO#,}Q`O,5@jO#-]Q`O'#IlO#,uQ`O,5@jOOQ!0Lb1G0w1G0wO!(iQpO,5:uO!(tQpO,5:uOOQS,5:w,5:wO#-}QdO,5:wO#.VQMhO1G2yO9gQ`O1G2yOOQ!0Lf1G0u1G0uO#.eQ!0MxO1G0uO#/jQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0WQ!0MzO'#JkO!$lQlO1G0uO#2cQ!fO'#JvO%[QlO'#JvO#2mQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#2rQ`O1G1OO#5WQ!0MxO1G1PO#5_Q!0MxO1G1PO#7uQ!0MxO1G1PO#7|Q!0MxO1G1PO#:dQ!0MxO1G1PO#<zQ!0MxO1G1PO#=RQ!0MxO1G1PO#=YQ!0MxO1G1PO#?pQ!0MxO1G1PO#?wQ!0MxO1G1PO#BUQ?MtO'#CiO#DPQ?MtO1G1`O#DWQ?MtO'#JrO#DkQ!0MxO,5?ZOOQ!0Lb-E<m-E<mO#FxQ!0MxO1G1PO#GuQ!0MzO1G1POOQ!0Lf1G1P1G1PO#HxQMjO'#J{O#ISQ`O,5:xO#IXQ!0MxO1G1cO#I{Q,UO,5<WO#JTQ,UO,5<XO#J]Q,UO'#FoO#JtQ`O'#FnOOQO'#KX'#KXOOQO'#Im'#ImO#JyQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#K[Q?MtO'#JqO#KfQ`O,5<bO!)PQlO,5<bOOOW-E<l-E<lOOQ!0Lf1G1l1G1lO#KkQpO'#KWOOQ!0Lf,5<d,5<dO#KsQpO,5<dO#KxQMhO'#DTOOOO'#Ia'#IaO#LPO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8XQ`O'#IqO#L[Q`O,5<zOOQ!0Lh,5<w,5<wO!+xQMhO'#ItO#LxQMjO,5=XO!+xQMhO'#IvO#MkQMjO,5=ZO!&oQMhO,5=]OOQO1G2S1G2SO#MuQ!dO'#CrO#NYQ(CWO'#ErO$ _QpO'#GbO$ uQ!dO,5<sO$ |Q`O'#KZO9aQ`O'#KZO$![Q`O,5<uO!+xQMhO,5<tO$!aQ`O'#GZO$!rQ`O,5<tO$!wQ!dO'#GWO$#UQ!dO'#K[O$#`Q`O'#K[O!&oQMhO'#K[O$#eQ`O,5<xO$#jQlO'#JuO$#tQpO'#GcO##tQpO'#GcO$$VQ`O'#GgO!3dQ`O'#GkO$$[Q!0LrO'#IsO$$gQpO,5<|OOQ!0Lp,5<|,5<|O$$nQpO'#GcO$${QpO'#GdO$%^QpO'#GdO$%cQMjO,5=XO$%sQMjO,5=ZOOQ!0Lh,5=^,5=^O!+xQMhO,5@UO!+xQMhO,5@UO$&TQ`O'#IxO$&iQ`O,5@TO$&qQ`O,59aOOQ!0Lh,59i,59iO$'hQ$IYO,59uOOQ!0Lh'#Jo'#JoO$(ZQMjO,5<kO$(|QMjO,5<mO@oQ`O,5<oOOQ!0Lh,5<p,5<pO$)WQ`O,5<vO$)]QMjO,5<{O$)mQ`O,5@UO$){Q`O'#KOO!$lQlO1G2RO$*QQ`O1G2RO9aQ`O'#KRO9aQ`O'#EtO%[QlO'#EtO9aQ`O'#IzO$*VQ!0LrO,5@zOOQ[1G2}1G2}OOQ[1G4_1G4_OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$,XQ!0MxO1G0UOOQ[1G2y1G2yO!&oQMhO1G2yO%[QlO1G2yO#.YQ`O1G2yO$.]QMhO'#EkOOQ!0Lb,5@S,5@SO$.jQ!0LrO,5@SOOQ[1G.u1G.uO!BfQ!0LrO1G.uO!BqQpO1G.uO!ByQMhO1G.uO$.{Q`O1G0uO$/QQ`O'#CiO$/]Q`O'#KdO$/eQ`O,5={O$/jQ`O'#KdO$/oQ`O'#KdO$/}Q`O'#JQO$0]Q`O,5@}O$0eQ!fO1G1iOOQ!0Lf1G1k1G1kO9gQ`O1G3fO@oQ`O1G3fO$0lQ`O1G3fO$0qQ`O1G3fOOQ[1G3f1G3fO!DwQ`O1G3UO!&oQMhO1G3RO$0vQ`O1G3ROOQ[1G3S1G3SO!&oQMhO1G3SO$0{Q`O1G3SO$1TQpO'#HQOOQ[1G3U1G3UO!6SQpO'#I|O!D|Q!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$1]QMhO,5=tO9gQ`O,5=tO$$VQ`O,5=vO9[Q`O,5=vO!BqQpO,5=vO!ByQMhO,5=vO:`QMhO,5=vO$1kQ`O'#KbO$1vQ`O,5=wOOQ[1G.k1G.kO$1{Q!0LrO1G.kO@oQ`O1G.kO$2WQ`O1G.kO9qQ!0LrO1G.kO$4`Q!fO,5APO$4mQ`O,5APO9aQ`O,5APO$4xQlO,5>OO$5PQ`O,5>OOOQ[1G3h1G3hO`QlO1G3hOOQ[1G3n1G3nOOQ[1G3p1G3pO>xQ`O1G3rO$5UQlO1G3tO$9YQlO'#HsOOQ[1G3w1G3wO$9gQ`O'#HyO>}Q`O'#H{OOQ[1G3}1G3}O$9oQlO1G3}O9qQ!0LrO1G4TOOQ[1G4V1G4VOOQ!0Lb'#G_'#G_O9qQ!0LrO1G4XO9qQ!0LrO1G4ZO$=vQ`O,5@aO!)PQlO,5;`O9aQ`O,5;`O>}Q`O,5:XO!)PQlO,5:XO!BqQpO,5:XO$={Q?MtO,5:XOOQO,5;`,5;`O$>VQpO'#IdO$>mQ`O,5@`OOQ!0Lf1G/r1G/rO$>uQpO'#IjO$?PQ`O,5@oOOQ!0Lb1G0y1G0yO##tQpO,5:XOOQO'#If'#IfO$?XQpO,5:qOOQ!0Ln,5:q,5:qO#'oQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO>}Q`O1G0tO!BqQpO1G0tO!ByQMhO1G0tOOQ!0Lb1G5{1G5{O!BfQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$?`Q!0LrO1G0mO$?kQ!0LrO1G0mO!BqQpO1G0^OC{QpO1G0^O$?yQ!0LrO1G0mOOQO1G0^1G0^O$@_Q!0MxO1G0mPOOO-E<Z-E<ZPOOO1G.h1G.hOOOO1G/i1G/iO$@iQ!bO,5<iO$@qQ!fO1G4iOOQO1G4o1G4oO%[QlO,5>}O$@{Q`O1G5yO$ATQ`O1G6XO$A]Q!fO1G6YO9aQ`O,5?TO$AgQ!0MxO1G6VO%[QlO1G6VO$AwQ!0LrO1G6VO$BYQ`O1G6UO$BYQ`O1G6UO9aQ`O1G6UO$BbQ`O,5?WO9aQ`O,5?WOOQO,5?W,5?WO$BvQ`O,5?WO$){Q`O,5?WOOQO-E<j-E<jOOQS1G0a1G0aOOQS1G0c1G0cO#.QQ`O1G0cOOQ[7+(e7+(eO!&oQMhO7+(eO%[QlO7+(eO$CUQ`O7+(eO$CaQMhO7+(eO$CoQ!0MzO,5=XO$EzQ!0MzO,5=ZO$HVQ!0MzO,5=XO$JhQ!0MzO,5=ZO$LyQ!0MzO,59uO% OQ!0MzO,5<kO%#ZQ!0MzO,5<mO%%fQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%'wQ!0MxO7+&aO%(kQlO'#IeO%(xQ`O,5@bO%)QQ!fO,5@bOOQ!0Lf1G0P1G0PO%)[Q`O7+&jOOQ!0Lf7+&j7+&jO%)aQ?MtO,5:fO%[QlO7+&zO%)kQ?MtO,5:bO%)xQ?MtO,5:jO%*SQ?MtO,5:lO%*^QMhO'#IhO%*hQ`O,5@gOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%*pQ!jO,5<ZO!)PQlO,5<YOOQO-E<k-E<kOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%*{Q`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%+QQ!dO,59oOOOO-E<_-E<_OOQ!0Lh1G/X1G/XO%+XQ!0MxO7+'kOOQ!0Lh,5?],5?]O%+{QMhO1G2fP%,SQ`O'#IqPOQ!0Lh-E<o-E<oO%,pQMjO,5?`OOQ!0Lh-E<r-E<rO%-cQMjO,5?bOOQ!0Lh-E<t-E<tO%-mQ!dO1G2wO%-tQ!dO'#CrO%.[QMhO'#KRO$#jQlO'#JuOOQ!0Lh1G2_1G2_O%.cQ`O'#IpO%.wQ`O,5@uO%.wQ`O,5@uO%/PQ`O,5@uO%/[Q`O,5@uOOQO1G2a1G2aO%/jQMjO1G2`O!+xQMhO1G2`O%/zQ(CWO'#IrO%0XQ`O,5@vO!&oQMhO,5@vO%0aQ!dO,5@vOOQ!0Lh1G2d1G2dO%2qQ!fO'#CiO%2{Q`O,5=POOQ!0Lb,5<},5<}O%3TQpO,5<}OOQ!0Lb,5=O,5=OOClQ`O,5<}O%3`QpO,5<}OOQ!0Lb,5=R,5=RO$){Q`O,5=VOOQO,5?_,5?_OOQO-E<q-E<qOOQ!0Lp1G2h1G2hO##tQpO,5<}O$#jQlO,5=PO%3nQ`O,5=OO%3yQpO,5=OO!+xQMhO'#ItO%4sQMjO1G2sO!+xQMhO'#IvO%5fQMjO1G2uO%5pQMjO1G5pO%5zQMjO1G5pOOQO,5?d,5?dOOQO-E<v-E<vOOQO1G.{1G.{O!9xQpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%6XQ`O1G2ZO!+xQMhO1G2bO!+xQMhO1G5pO!+xQMhO1G5pO%6^Q!0MxO7+'mOOQ!0Lf7+'m7+'mO!$lQlO7+'mO%7QQ`O,5;`OOQ!0Lb,5?f,5?fOOQ!0Lb-E<x-E<xO%7VQ!dO'#K]O#'oQ`O7+(eO4UQ!fO7+(eO$CXQ`O7+(eO%7aQ!0MvO'#CiO%7tQ!0MvO,5=SO%8fQ`O,5=SO%8nQ`O,5=SOOQ!0Lb1G5n1G5nOOQ[7+$a7+$aO!BfQ!0LrO7+$aO!BqQpO7+$aO!$lQlO7+&aO%8sQ`O'#JPO%9[Q`O,5AOOOQO1G3g1G3gO9gQ`O,5AOO%9[Q`O,5AOO%9dQ`O,5AOOOQO,5?l,5?lOOQO-E=O-E=OOOQ!0Lf7+'T7+'TO%9iQ`O7+)QO9qQ!0LrO7+)QO9gQ`O7+)QO@oQ`O7+)QOOQ[7+(p7+(pO%9nQ!0MvO7+(mO!&oQMhO7+(mO!DrQ`O7+(nOOQ[7+(n7+(nO!&oQMhO7+(nO%9xQ`O'#KaO%:TQ`O,5=lOOQO,5?h,5?hOOQO-E<z-E<zOOQ[7+(s7+(sO%;gQpO'#HZOOQ[1G3`1G3`O!&oQMhO1G3`O%[QlO1G3`O%;nQ`O1G3`O%;yQMhO1G3`O9qQ!0LrO1G3bO$$VQ`O1G3bO9[Q`O1G3bO!BqQpO1G3bO!ByQMhO1G3bO%<XQ`O'#JOO%<mQ`O,5@|O%<uQpO,5@|OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@oQ`O7+$VO9qQ!0LrO7+$VO%=QQ`O7+$VO%[QlO1G6kO%[QlO1G6lO%=VQ!0LrO1G6kO%=aQlO1G3jO%=hQ`O1G3jO%=mQlO1G3jOOQ[7+)S7+)SO9qQ!0LrO7+)^O`QlO7+)`OOQ['#Kg'#KgOOQ['#JR'#JRO%=tQlO,5>_OOQ[,5>_,5>_O%[QlO'#HtO%>RQ`O'#HvOOQ[,5>e,5>eO9aQ`O,5>eOOQ[,5>g,5>gOOQ[7+)i7+)iOOQ[7+)o7+)oOOQ[7+)s7+)sOOQ[7+)u7+)uO%>WQpO1G5{O%>rQ?MtO1G0zO%>|Q`O1G0zOOQO1G/s1G/sO%?XQ?MtO1G/sO>}Q`O1G/sO!)PQlO'#DmOOQO,5?O,5?OOOQO-E<b-E<bOOQO,5?U,5?UOOQO-E<h-E<hO!BqQpO1G/sOOQO-E<d-E<dOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#'oQ`O7+%uOOQ!0Lf7+&`7+&`O>}Q`O7+&`O!BqQpO7+&`OOQO7+%x7+%xO$@_Q!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%?cQ!0LrO7+&XO!BfQ!0LrO7+%xO!BqQpO7+%xO%?nQ!0LrO7+&XO%?|Q!0MxO7++qO%[QlO7++qO%@^Q`O7++pO%@^Q`O7++pOOQO1G4r1G4rO9aQ`O1G4rO%@fQ`O1G4rOOQS7+%}7+%}O#'oQ`O<<LPO4UQ!fO<<LPO%@tQ`O<<LPOOQ[<<LP<<LPO!&oQMhO<<LPO%[QlO<<LPO%@|Q`O<<LPO%AXQ!0MzO,5?`O%CdQ!0MzO,5?bO%EoQ!0MzO1G2`O%HQQ!0MzO1G2sO%J]Q!0MzO1G2uO%LhQ!fO,5?PO%[QlO,5?POOQO-E<c-E<cO%LrQ`O1G5|OOQ!0Lf<<JU<<JUO%LzQ?MtO1G0uO& RQ?MtO1G1PO& YQ?MtO1G1PO&#ZQ?MtO1G1PO&#bQ?MtO1G1PO&%cQ?MtO1G1PO&'dQ?MtO1G1PO&'kQ?MtO1G1PO&'rQ?MtO1G1PO&)sQ?MtO1G1PO&)zQ?MtO1G1PO&*RQ!0MxO<<JfO&+yQ?MtO1G1PO&,vQ?MvO1G1PO&-yQ?MvO'#JkO&0PQ?MtO1G1cO&0^Q?MtO1G0UO&0hQMjO,5?SOOQO-E<f-E<fO!)PQlO'#FqOOQO'#KY'#KYOOQO1G1u1G1uO&0rQ`O1G1tO&0wQ?MtO,5?ZOOOW7+'h7+'hOOOO1G/Z1G/ZO&1RQ!dO1G4wOOQ!0Lh7+(Q7+(QP!&oQMhO,5?]O!+xQMhO7+(cO&1YQ`O,5?[O9aQ`O,5?[OOQO-E<n-E<nO&1hQ`O1G6aO&1hQ`O1G6aO&1pQ`O1G6aO&1{QMjO7+'zO&2]Q!dO,5?^O&2gQ`O,5?^O!&oQMhO,5?^OOQO-E<p-E<pO&2lQ!dO1G6bO&2vQ`O1G6bO&3OQ`O1G2kO!&oQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%3TQpO1G2iO!BqQpO1G2iOClQ`O1G2iOOQ!0Lb1G2q1G2qO&3TQpO1G2iO&3cQ`O1G2kO$){Q`O1G2jOClQ`O1G2jO$#jQlO1G2kO&3kQ`O1G2jO&4_QMjO,5?`OOQ!0Lh-E<s-E<sO&5QQMjO,5?bOOQ!0Lh-E<u-E<uO!+xQMhO7++[OOQ!0Lh1G/c1G/cO&5[Q`O1G/cOOQ!0Lh7+'u7+'uO&5aQMjO7+'|O&5qQMjO7++[O&5{QMjO7++[O&6YQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&6|Q`O1G0zO!&oQMhO'#IyO&7RQ`O,5@wO&9TQ!fO<<LPO!&oQMhO1G2nO&9[Q!0LrO1G2nOOQ[<<G{<<G{O!BfQ!0LrO<<G{O&9mQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?k,5?kO&:aQ`O,5?kO&:fQ`O,5?kOOQO-E<}-E<}O&:tQ`O1G6jO&:tQ`O1G6jO9gQ`O1G6jO@oQ`O<<LlOOQ[<<Ll<<LlO&:|Q`O<<LlO9qQ!0LrO<<LlOOQ[<<LX<<LXO%9nQ!0MvO<<LXOOQ[<<LY<<LYO!DrQ`O<<LYO&;RQpO'#I{O&;^Q`O,5@{O!)PQlO,5@{OOQ[1G3W1G3WOOQO'#I}'#I}O9qQ!0LrO'#I}O&;fQpO,5=uOOQ[,5=u,5=uO&;mQpO'#EgO&;tQpO'#GeO&;yQ`O7+(zO&<OQ`O7+(zOOQ[7+(z7+(zO!&oQMhO7+(zO%[QlO7+(zO&<WQ`O7+(zOOQ[7+(|7+(|O9qQ!0LrO7+(|O$$VQ`O7+(|O9[Q`O7+(|O!BqQpO7+(|O&<cQ`O,5?jOOQO-E<|-E<|OOQO'#H^'#H^O&<nQ`O1G6hO9qQ!0LrO<<GqOOQ[<<Gq<<GqO@oQ`O<<GqO&<vQ`O7+,VO&<{Q`O7+,WO%[QlO7+,VO%[QlO7+,WOOQ[7+)U7+)UO&=QQ`O7+)UO&=VQlO7+)UO&=^Q`O7+)UOOQ[<<Lx<<LxOOQ[<<Lz<<LzOOQ[-E=P-E=POOQ[1G3y1G3yO&=cQ`O,5>`OOQ[,5>b,5>bO&=hQ`O1G4PO9aQ`O7+&fO!)PQlO7+&fOOQO7+%_7+%_O&=mQ?MtO1G6YO>}Q`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO>}Q`O<<IzOOQO<<Is<<IsO$@_Q!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!BfQ!0LrO<<IdO&=wQ!0LrO<<IsO&>SQ!0MxO<= ]O&>dQ`O<= [OOQO7+*^7+*^O9aQ`O7+*^OOQ[ANAkANAkO&>lQ!fOANAkO!&oQMhOANAkO#'oQ`OANAkO4UQ!fOANAkO&>sQ`OANAkO%[QlOANAkO&>{Q!0MzO7+'zO&A^Q!0MzO,5?`O&CiQ!0MzO,5?bO&EtQ!0MzO7+'|O&HVQ!fO1G4kO&HaQ?MtO7+&aO&JeQ?MvO,5=XO&LlQ?MvO,5=ZO&L|Q?MvO,5=XO&M^Q?MvO,5=ZO&MnQ?MvO,59uO' tQ?MvO,5<kO'#wQ?MvO,5<mO'&]Q?MvO,5<{O'(RQ?MtO7+'kO'(`Q?MtO7+'mO'(mQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*c7+*cO'(rQMjO<<K}OOQO1G4v1G4vO'(yQ`O1G4vO')UQ`O1G4vO')dQ`O7++{O')dQ`O7++{O!&oQMhO1G4xO')lQ!dO1G4xO')vQ`O7++|O'*OQ`O7+(VO'*ZQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!BqQpO7+(TOClQ`O7+(TO'*eQ`O7+(VO!&oQMhO7+(VO$){Q`O7+(UO'*jQ`O7+(VOClQ`O7+(UO'*rQMjO<<NvOOQ!0Lh7+$}7+$}O!+xQMhO<<NvO'*|Q!dO,5?eOOQO-E<w-E<wO'+WQ!0MvO7+(YO!&oQMhO7+(YOOQ[AN=gAN=gO9gQ`O1G5VOOQO1G5V1G5VO'+hQ`O1G5VO'+mQ`O7+,UO'+mQ`O7+,UO9qQ!0LrOANBWO@oQ`OANBWOOQ[ANBWANBWOOQ[ANAsANAsOOQ[ANAtANAtO'+uQ`O,5?gOOQO-E<y-E<yO',QQ?MtO1G6gOOQO,5?i,5?iOOQO-E<{-E<{OOQ[1G3a1G3aO',[Q`O,5=POOQ[<<Lf<<LfO!&oQMhO<<LfO&;yQ`O<<LfO',aQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9qQ!0LrO<<LhO$$VQ`O<<LhO9[Q`O<<LhO',iQpO1G5UO',tQ`O7+,SOOQ[AN=]AN=]O9qQ!0LrOAN=]OOQ[<= q<= qOOQ[<= r<= rO',|Q`O<= qO'-RQ`O<= rOOQ[<<Lp<<LpO'-WQ`O<<LpO'-]QlO<<LpOOQ[1G3z1G3zO>}Q`O7+)kO'-dQ`O<<JQO'-oQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$@_Q!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<Mx<<MxOOQ[G27VG27VO!&oQMhOG27VO#'oQ`OG27VO'-yQ!fOG27VO4UQ!fOG27VO'.QQ`OG27VO'.YQ?MtO<<JfO'.gQ?MvO1G2`O'0]Q?MvO,5?`O'2`Q?MvO,5?bO'4cQ?MvO1G2sO'6fQ?MvO1G2uO'8iQ?MtO<<KXO'8vQ?MtO<<I{OOQO1G1w1G1wO!+xQMhOANAiOOQO7+*b7+*bO'9TQ`O7+*bO'9`Q`O<= gO'9hQ!dO7+*dOOQ!0Lb<<Kq<<KqO$){Q`O<<KqOClQ`O<<KqO'9rQ`O<<KqO!&oQMhO<<KqOOQ!0Lb<<Ko<<KoO!BqQpO<<KoO'9}Q!dO<<KqOOQ!0Lb<<Kp<<KpO':XQ`O<<KqO!&oQMhO<<KqO$){Q`O<<KpO':^QMjOANDbO':hQ!0MvO<<KtOOQO7+*q7+*qO9gQ`O7+*qO':xQ`O<= pOOQ[G27rG27rO9qQ!0LrOG27rO!)PQlO1G5RO';QQ`O7+,RO';YQ`O1G2kO&;yQ`OANBQOOQ[ANBQANBQO!&oQMhOANBQO';_Q`OANBQOOQ[ANBSANBSO9qQ!0LrOANBSO$$VQ`OANBSOOQO'#H_'#H_OOQO7+*p7+*pOOQ[G22wG22wOOQ[ANE]ANE]OOQ[ANE^ANE^OOQ[ANB[ANB[O';gQ`OANB[OOQ[<<MV<<MVO!)PQlOAN?lOOQOG24yG24yO$@_Q!0MxOG24yO#'oQ`OLD,qOOQ[LD,qLD,qO!&oQMhOLD,qO';lQ!fOLD,qO';sQ?MvO7+'zO'=iQ?MvO,5?`O'?lQ?MvO,5?bO'AoQ?MvO7+'|O'CeQMjOG27TOOQO<<M|<<M|OOQ!0LbANA]ANA]O$){Q`OANA]OClQ`OANA]O'CuQ!dOANA]OOQ!0LbANAZANAZO'C|Q`OANA]O!&oQMhOANA]O'DXQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N]<<N]OOQ[LD-^LD-^O'DcQ?MtO7+*mOOQO'#Gf'#GfOOQ[G27lG27lO&;yQ`OG27lO!&oQMhOG27lOOQ[G27nG27nO9qQ!0LrOG27nOOQ[G27vG27vO'DmQ?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#'oQ`O!$(!]O!&oQMhO!$(!]O'DwQ!0MzOG27TOOQ!0LbG26wG26wO$){Q`OG26wO'GYQ`OG26wOClQ`OG26wO'GeQ!dOG26wO!&oQMhOG26wOOQ[LD-WLD-WO&;yQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#'oQ`O!)9EwOOQ!0LbLD,cLD,cO$){Q`OLD,cOClQ`OLD,cO'GlQ`OLD,cO'GwQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'HOQ?MvOG27TOOQ!0Lb!$( }!$( }O$){Q`O!$( }OClQ`O!$( }O'ItQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$){Q`O!)9EiOClQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$){Q`O!.K;TOOQ!0Lb!4/0o!4/0oO!)PQlO'#DzO1PQ`O'#EXO'JPQ!fO'#JqO'JWQ!L^O'#DvO'J_QlO'#EOO'JfQ!fO'#CiO'L|Q!fO'#CiO!)PQlO'#EQO'M^QlO,5;ZO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO,5;eO!)PQlO'#IoO( aQ`O,5<iO!)PQlO,5;eO( iQMhO,5;eO(#SQMhO,5;eO!)PQlO,5;wO!&oQMhO'#GmO( iQMhO'#GmO!&oQMhO'#GoO( iQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&oQMhO'#GPO( iQMhO'#GPO!&oQMhO'#GRO( iQMhO'#GRO!&oQMhO'#GaO( iQMhO'#GaO!)PQlO,5:jO(#ZQpO'#D_O(#eQpO'#JuO!)PQlO,5@nO'M^QlO1G0uO(#oQ?MtO'#CiO!)PQlO1G2PO!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO(#yQ!dO'#CrO!&oQMhO,5<tO( iQMhO,5<tO'M^QlO1G2RO!)PQlO7+&zO!&oQMhO1G2`O( iQMhO1G2`O!&oQMhO'#ItO( iQMhO'#ItO!&oQMhO'#IvO( iQMhO'#IvO!&oQMhO1G2bO( iQMhO1G2bO'M^QlO7+'mO'M^QlO7+&aO!&oQMhOANAiO( iQMhOANAiO($^Q`O'#EoO($cQ`O'#EoO($kQ`O'#F]O($pQ`O'#EyO($uQ`O'#KSO(%QQ`O'#KQO(%]Q`O,5;ZO(%bQMjO,5<eO(%iQ`O'#GYO(%nQ`O'#GYO(%sQ`O,5<gO(%{Q`O,5;ZO(&TQ?MtO1G1`O(&[Q`O,5<tO(&aQ`O,5<tO(&fQ`O,5<vO(&kQ`O,5<vO(&pQ`O1G2RO(&uQ`O1G0uO(&zQMjO<<K}O('RQMjO<<K}O7eQMhO'#F|O9[Q`O'#F{OAjQ`O'#EnO!)PQlO,5;tO!3dQ`O'#GYO!3dQ`O'#GYO!3dQ`O'#G[O!3dQ`O'#G[O!+xQMhO7+(cO!+xQMhO7+(cO%-mQ!dO1G2wO%-mQ!dO1G2wO!&oQMhO,5=]O!&oQMhO,5=]",
  stateData:
    "((X~O'{OS'|OSTOS'}RQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&V!WO&]!XO&_!YO&a!ZO&c![O&f!]O&l!^O&r!_O&t!`O&v!aO&x!bO&z!cO(SSO(UTO(XUO(`VO(n[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O'}!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'y]X(`]X(q]X(x]X(y]X~O!g%RX~P(qO_!}O(U#PO(V!}O(W#PO~O_#QO(W#PO(X#PO(Y#QO~Ox#SO!U#TO(a#TO(b#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S;{O(UTO(XUO(`VO(n[O~O![#ZO!]#WO!Y(gP!Y(uP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(UTO(XUO(`VO(n[O~Op#mO![#iO!|]O#i#lO#j#iO(S;|O!k(rP~P.iO!l#oO(S#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa(eX'y(eX'v(eX!k(eX!Y(eX!_(eX%i(eX!g(eX~P1qO#S$dO#`$eO$Q$eOP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX!_(fX%i(fX~Oa(fX'y(fX'v(fX!Y(fX!k(fXv(fX!g(fX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%cOk%cOl%cOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S$sO(UTO(XUO(`$uO(x$}O(y%POg(]P~O!l%dO~O!S%gO!_%hO(S%fO~O!g%lO~Oa%mO'y%mO~O!Q%qO~P%[O(T!lO~P%[O%n%uO~P%[Oh%VO!l%dO(S%fO(T!lO~Oe%|O!l%dO(S%fO~Oj$RO~O!Q&RO!_&OO!l&QO%j&UO(S%fO(T!lO(UTO(XUO`)VP~O!x#sO~O%s&WO!S)RX!_)RX(S)RX~O(S&XO~Ol!PO!u&^O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&cOe&bO!x&`O%h&aO%{&_O~P<VOd&fOeyOl!PO!_&eO!u&^O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&iO#`&lO%j&gO(T!lO~P=[O!l&mO!u&qO~O!l#oO~O!_XO~Oa%mO'w&yO'y%mO~Oa%mO'w&|O'y%mO~Oa%mO'w'OO'y%mO~O'v]X!Y]Xv]X!k]X&Z]X!_]X%i]X!g]X~P(qO!b']O!c'UO!d'UO(T!lO(UTO(XUO~Os'SO!S'RO!['VO(d'QO!^(hP!^(wP~P@cOn'`O!_'^O(S%fO~Oe'eO!l%dO(S%fO~O!Q&RO!l&QO~Os!nO!S!oO!|;wO#T!pO#U!pO#W!pO#X!pO(T!lO(UTO(XUO(d!mO(n!sO~O!b'kO!c'jO!d'jO#V!pO#['lO#]'lO~PA}Oa%mOh%VO!g#vO!l%dO'y%mO(q'nO~O!p'rO#`'pO~PC]Os!nO!S!oO(UTO(XUO(d!mO(n!sO~O!_XOs(lX!S(lX!b(lX!c(lX!d(lX!|(lX#T(lX#U(lX#V(lX#W(lX#X(lX#[(lX#](lX(T(lX(U(lX(X(lX(d(lX(n(lX~O!c'jO!d'jO(T!lO~PC{O(O'vO(P'vO(Q'xO~O_!}O(U'zO(V!}O(W'zO~O_#QO(W'zO(X'zO(Y#QO~Ov'|O~P%[Ox#SO!U#TO(a#TO(b(PO~O![(RO!Y'VX!Y']X!]'VX!]']X~P+}O!](TO!Y(gX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](TO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~O!Y(gX~PGvO!Y(YO~O!Y(tX!](tX!g(tX!k(tX(q(tX~O#`(tX#k#dX!^(tX~PIyO#`(ZO!Y(vX!](vX~O!]([O!Y(uX~O!Y(_O~O#`$eO~PIyO!^(`O~P`OR#zO!Q#yO!S#{O!l#xO(`VOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(q!na(x!na(y!na~Oa!na'y!na'v!na!Y!na!k!nav!na!_!na%i!na!g!na~PKaO!k(aO~O!g#vO#`(bO(q'nO!](sXa(sX'y(sX~O!k(sX~PM|O!S%gO!_%hO!|]O#i(gO#j(fO(S%fO~O!](hO!k(rX~O!k(jO~O!S%gO!_%hO#j(fO(S%fO~OP(fXR(fX[(fXj(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~O!g#vO!k(fX~P! jOR(lO!Q(kO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(S!{a~P!#kO!x(pO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~O#k(vO~O![(xO!k(jP~P%[O(d(zO(n[O~O!S(|O!l#xO(d(zO(n[O~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]$_Oa$qa'y$qa'v$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)bO~P!&oOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%[O!S${O!_$|O!i%aO!l$xO#j%bO$W%_O$t%]O$v%^O$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Og(oP~P!+xO!Q)gO!g)fO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)fO!_(zX$Z(zX$](zX$_(zX$f(zX~O!Q)gO~P!.RO!Q)gO!_(zX$Z(zX$](zX$_(zX$f(zX~O!_)iO$Z)mO$])hO$_)hO$f)nO~O![)qO~P!)PO$]$hO$_$gO$f)uO~On$zX!Q$zX#S$zX'x$zX(x$zX(y$zX~OgmXg$zXnmX!]mX#`mX~P!/wOx)wO(a)xO(b)zO~On*TO!Q)|O'x)}O(x$}O(y%PO~Og){O~P!0{Og*UO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S*WO!_*XO!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~O![*[O(S*VO!k(}P~P!1jO#k*^O~O!l*_O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(S*aO(UTO(XUO(`$uO(x$}O(y%PO~O![*dO!Y)OP~P!3iOr*pOs!nO!S*fO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO(d!mO~O!^*mO~P!5^O#S$dOn(_X!Q(_X'x(_X(x(_X(y(_X!](_X#`(_X~Og(_X$O(_X~P!6`On*uO#`*tOg(^X!](^X~O!]*vOg(]X~Oj%cOk%cOl%cO(S&XOg(]P~Os*yO~O!l+OO~O(S(tO~Op+TO!S%gO![#iO!_%hO!|]O#i#lO#j#iO(S%fO!k(rP~O!g#vO#k+UO~O!S%gO![+WO!]([O!_%hO(S%fO!Y(uP~Os'YO!S+YO![+XO(UTO(XUO(d(zO~O!^(wP~P!9iO!]+ZOa)SX'y)SX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(`VO(q$YO(x#|O(y#}O~Oa!ja!]!ja'y!ja'v!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:aOR#zO!Q#yO!S#{O!l#xO(`VOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(q!ra(x!ra(y!ra~Oa!ra'y!ra'v!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!<wOR#zO!Q#yO!S#{O!l#xO(`VOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(q!ta(x!ta(y!ta~Oa!ta'y!ta'v!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?_Oh%VOn+dO!_'^O%i+cO~O!g+fOa([X!_([X'y([X!]([X~Oa%mO!_XO'y%mO~Oh%VO!l%dO~Oh%VO!l%dO(S%fO~O!g#vO#k(vO~Ob+qO%j+rO(S+nO(UTO(XUO!^)WP~O!]+sO`)VX~O[+wO~O`+xO~O!_&OO(S%fO(T!lO`)VP~Oh%VO#`+}O~Oh%VOn,QO!_$|O~O!_,SO~O!Q,UO!_XO~O%n%uO~O!x,ZO~Oe,`O~Ob,aO(S#nO(UTO(XUO!^)UP~Oe%|O~O%j!QO(S&XO~P=[O[,fO`,eO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(UTO(XUO(`VO(n[O~O!_!eO!u!gO$W!kO(S!dO~P!F_O`,eOa%mO'y%mO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(S!dO(UTO(XUO(`VO(n[O~Oa,kOl!OO!uwO%l!OO%m!OO%n!OO~P!HwO!l&mO~O&],qO~O!_,sO~O&n,uO&p,vOP&kaQ&kaS&kaY&kaa&kad&kae&kal&kap&kar&kas&kat&kaz&ka|&ka!O&ka!S&ka!W&ka!X&ka!_&ka!i&ka!l&ka!o&ka!p&ka!q&ka!s&ka!u&ka!x&ka!|&ka$W&ka$n&ka%h&ka%j&ka%l&ka%m&ka%n&ka%q&ka%s&ka%v&ka%w&ka%y&ka&V&ka&]&ka&_&ka&a&ka&c&ka&f&ka&l&ka&r&ka&t&ka&v&ka&x&ka&z&ka'v&ka(S&ka(U&ka(X&ka(`&ka(n&ka!^&ka&d&kab&ka&i&ka~O(S,{O~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P# }O!g-QO#`-POh(iX!]#hX!^#hX!g(iX!l(iX~O!](iX!^(iX~P#!pOh%VO!g-SO!l%dO!]!aX!^!aX~Os!nO!S!oO(UTO(XUO(d!mO~OP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_!eO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(UTO(XUO(`VO(n[O~O(S<rO~P#$VO!]-WO!^(hX~O!^-YO~O!g-QO#`-PO!]#hX!^#hX~O!]-ZO!^(wX~O!^-]O~O!c-^O!d-^O(T!lO~P##tO!^-aO~P'_On-dO!_'^O~O!Y-iO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(T!{a(U!{a(X!{a(d!{a(n!{a~P!#kO!p-nO#`-lO~PC]O!c-pO!d-pO(T!lO~PC{Oa%mO#`-lO'y%mO~Oa%mO!g#vO#`-lO'y%mO~Oa%mO!g#vO!p-nO#`-lO'y%mO(q'nO~O(O'vO(P'vO(Q-uO~Ov-vO~O!Y'Va!]'Va~P!:aO![-zO!Y'VX!]'VX~P%[O!](TO!Y(ga~O!Y(ga~PGvO!]([O!Y(ua~O!S%gO![.OO!_%hO(S%fO!Y']X!]']X~O#`.QO!](sa!k(saa(sa'y(sa~O!g#vO~P#,]O!](hO!k(ra~O!S%gO!_%hO#j.UO(S%fO~Op.ZO!S%gO![.WO!_%hO!|]O#i.YO#j.WO(S%fO!]'`X!k'`X~OR._O!l#xO~Oh%VOn.bO!_'^O%i.aO~Oa#ci!]#ci'y#ci'v#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:aOn=|O!Q)|O'x)}O(x$}O(y%PO~O#k#_aa#_a#`#_a'y#_a!]#_a!k#_a!_#_a!Y#_a~P#/XO#k(_XP(_XR(_X[(_Xa(_Xj(_Xr(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X'y(_X(`(_X(q(_X!k(_X!Y(_X'v(_Xv(_X!_(_X%i(_X!g(_X~P!6`O!].oO!k(jX~P!:aO!k.rO~O!Y.tO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#2wO#n$OO~P#2wOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#5fO#r$QO~P#5fOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(`VOa#mi!]#mi#x#mi#z#mi#{#mi'y#mi(q#mi(x#mi(y#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(`VO(y#}Oa#mi!]#mi#z#mi#{#mi'y#mi(q#mi(x#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#:kO#x#mi~P#:kO#v$SO~P#8TOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(`VO(x#|O(y#}Oa#mi!]#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#=aO#z$WO~P#=aOP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X!]]X!^]X~O$O]X~P#@OOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO#z<XO#{<YO(`VO(q$YO(x#|O(y#}O~O$O.vO~P#B]O#S$dO#`<`O$Q<`O$O(fX!^(fX~P! jOa'ca!]'ca'y'ca'v'ca!k'ca!Y'cav'ca!_'ca%i'ca!g'ca~P!:aO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'y#mi(q#mi'v#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(`VO(x#mi(y#mi~P#E_On=|O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P#E_O!].zOg(oX~P!0{Og.|O~Oa$Pi!]$Pi'y$Pi'v$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:aO$].}O$_.}O~O$]/OO$_/OO~O!g)fO#`/PO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/QO~O!_)iO$Z/SO$])hO$_)hO$f/TO~O!]<ZO!^(eX~P#B]O!^/UO~O!g)fO$f(zX~O$f/WO~Ov/XO~P!&oOx)wO(a)xO(b/[O~O!S/_O~O(x$}On%aa!Q%aa'x%aa(y%aa!]%aa#`%aa~Og%aa$O%aa~P#LaO(y%POn%ca!Q%ca'x%ca(x%ca!]%ca#`%ca~Og%ca$O%ca~P#MSO!]fX!gfX!kfX!k$zX(qfX~P!/wO![/hO!]([O(S/gO!Y(uP!Y)OP~P!1jOr*pO!b*nO!c*hO!d*hO!l*_O#[*oO%`*jO(T!lO(UTO(XUO~Os<oO!S/iO![+XO!^*mO(d<nO!^(wP~P#NmO!k/jO~P#/XO!]/kO!g#vO(q'nO!k(}X~O!k/pO~O!S%gO![*[O!_%hO(S%fO!k(}P~O#k/rO~O!Y$zX!]$zX!g%RX~P!/wO!]/sO!Y)OX~P#/XO!g/uO~O!Y/wO~OpkO(S/xO~P.iOh%VOr/}O!g#vO!l%dO(q'nO~O!g+fO~Oa%mO!]0RO'y%mO~O!^0TO~P!5^O!c0UO!d0UO(T!lO~P##tOs!nO!S0VO(UTO(XUO(d!mO~O#[0XO~Og%aa!]%aa#`%aa$O%aa~P!0{Og%ca!]%ca#`%ca$O%ca~P!0{Oj%cOk%cOl%cO(S&XOg'lX!]'lX~O!]*vOg(]a~Og0bO~OR0cO!Q0cO!S0dO#S$dOn}a'x}a(x}a(y}a!]}a#`}a~Og}a$O}a~P$&vO!Q)|O'x)}On$sa(x$sa(y$sa!]$sa#`$sa~Og$sa$O$sa~P$'rO!Q)|O'x)}On$ua(x$ua(y$ua!]$ua#`$ua~Og$ua$O$ua~P$(eO#k0gO~Og%Ta!]%Ta#`%Ta$O%Ta~P!0{On0iO#`0hOg(^a!](^a~O!g#vO~O#k0lO~O!]+ZOa)Sa'y)Sa~OR#zO!Q#yO!S#{O!l#xO(`VOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(q!ri(x!ri(y!ri~Oa!ri'y!ri'v!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$*bOh%VOr%XOs$tOt$tOz%YO|%ZO!O<eO!S${O!_$|O!i=vO!l$xO#j<kO$W%_O$t<gO$v<iO$y%`O(UTO(XUO(`$uO(x$}O(y%PO~Op0uO%]0vO(S0tO~P$,xO!g+fOa([a!_([a'y([a!]([a~O#k0|O~O[]X!]fX!^fX~O!]0}O!^)WX~O!^1PO~O[1QO~Ob1SO(S+nO(UTO(XUO~O!_&OO(S%fO`'tX!]'tX~O!]+sO`)Va~O!k1VO~P!:aO[1YO~O`1ZO~O#`1^O~On1aO!_$|O~O(d(zO!^)TP~Oh%VOn1jO!_1gO%i1iO~O[1tO!]1rO!^)UX~O!^1uO~O`1wOa%mO'y%mO~O(S#nO(UTO(XUO~O#S$dO#`$eO$Q$eOP(fXR(fX[(fXr(fX!Q(fX!S(fX!](fX!l(fX!p(fX#R(fX#n(fX#o(fX#p(fX#q(fX#r(fX#s(fX#t(fX#u(fX#v(fX#x(fX#z(fX#{(fX(`(fX(q(fX(x(fX(y(fX~Oj1zO&Z1{Oa(fX~P$2cOj1zO#`$eO&Z1{O~Oa1}O~P%[Oa2PO~O&d2SOP&biQ&biS&biY&bia&bid&bie&bil&bip&bir&bis&bit&biz&bi|&bi!O&bi!S&bi!W&bi!X&bi!_&bi!i&bi!l&bi!o&bi!p&bi!q&bi!s&bi!u&bi!x&bi!|&bi$W&bi$n&bi%h&bi%j&bi%l&bi%m&bi%n&bi%q&bi%s&bi%v&bi%w&bi%y&bi&V&bi&]&bi&_&bi&a&bi&c&bi&f&bi&l&bi&r&bi&t&bi&v&bi&x&bi&z&bi'v&bi(S&bi(U&bi(X&bi(`&bi(n&bi!^&bib&bi&i&bi~Ob2YO!^2WO&i2XO~P`O!_XO!l2[O~O&p,vOP&kiQ&kiS&kiY&kia&kid&kie&kil&kip&kir&kis&kit&kiz&ki|&ki!O&ki!S&ki!W&ki!X&ki!_&ki!i&ki!l&ki!o&ki!p&ki!q&ki!s&ki!u&ki!x&ki!|&ki$W&ki$n&ki%h&ki%j&ki%l&ki%m&ki%n&ki%q&ki%s&ki%v&ki%w&ki%y&ki&V&ki&]&ki&_&ki&a&ki&c&ki&f&ki&l&ki&r&ki&t&ki&v&ki&x&ki&z&ki'v&ki(S&ki(U&ki(X&ki(`&ki(n&ki!^&ki&d&kib&ki&i&ki~O!Y2bO~O!]!aa!^!aa~P#B]Os!nO!S!oO![2hO(d!mO!]'WX!^'WX~P@cO!]-WO!^(ha~O!]'^X!^'^X~P!9iO!]-ZO!^(wa~O!^2oO~P'_Oa%mO#`2xO'y%mO~Oa%mO!g#vO#`2xO'y%mO~Oa%mO!g#vO!p2|O#`2xO'y%mO(q'nO~Oa%mO'y%mO~P!:aO!]$_Ov$qa~O!Y'Vi!]'Vi~P!:aO!](TO!Y(gi~O!]([O!Y(ui~O!Y(vi!](vi~P!:aO!](si!k(sia(si'y(si~P!:aO#`3OO!](si!k(sia(si'y(si~O!](hO!k(ri~O!S%gO!_%hO!|]O#i3TO#j3SO(S%fO~O!S%gO!_%hO#j3SO(S%fO~On3[O!_'^O%i3ZO~Oh%VOn3[O!_'^O%i3ZO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aav%aa!_%aa%i%aa!g%aa~P#LaO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%cav%ca!_%ca%i%ca!g%ca~P#MSO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'y%aa(`%aa(q%aa!k%aa!Y%aa'v%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/XO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'y%ca(`%ca(q%ca!k%ca!Y%ca'v%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/XO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'y}a(`}a(q}a!k}a!Y}a'v}av}a!_}a%i}a!g}a~P$&vO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'y$sa(`$sa(q$sa!k$sa!Y$sa'v$sav$sa!_$sa%i$sa!g$sa~P$'rO#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'y$ua(`$ua(q$ua!k$ua!Y$ua'v$uav$ua!_$ua%i$ua!g$ua~P$(eO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'y%Ta(`%Ta(q%Ta!k%Ta!Y%Ta'v%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/XOa#cq!]#cq'y#cq'v#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:aO![3dO!]'XX!k'XX~P%[O!].oO!k(ja~O!].oO!k(ja~P!:aO!Y3gO~O$O!na!^!na~PKaO$O!ja!]!ja!^!ja~P#B]O$O!ra!^!ra~P!<wO$O!ta!^!ta~P!?_Og'[X!]'[X~P!+xO!].zOg(oa~OSfO!_3{O$d3|O~O!^4QO~Ov4RO~P#/XOa$mq!]$mq'y$mq'v$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:aO!Y4TO~P!&oO!S4UO~O!Q)|O'x)}O(y%POn'ha(x'ha!]'ha#`'ha~Og'ha$O'ha~P%,XO!Q)|O'x)}On'ja(x'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P%,zO(q$YO~P#/XO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!/wO(S<xO~P!1jO!S%gO![4XO!_%hO(S%fO!]'dX!k'dX~O!]/kO!k(}a~O!]/kO!g#vO!k(}a~O!]/kO!g#vO(q'nO!k(}a~Og$|i!]$|i#`$|i$O$|i~P!0{O![4aO!Y'fX!]'fX~P!3iO!]/sO!Y)Oa~O!]/sO!Y)Oa~P#/XOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~Oj%YX!g%YX~P%0kOj4fO!g#vO~Oh%VO!g#vO!l%dO~Oh%VOr4kO!l%dO(q'nO~Or4pO!g#vO(q'nO~Os!nO!S4qO(UTO(XUO(d!mO~O(x$}On%ai!Q%ai'x%ai(y%ai!]%ai#`%ai~Og%ai$O%ai~P%4[O(y%POn%ci!Q%ci'x%ci(x%ci!]%ci#`%ci~Og%ci$O%ci~P%4}Og(^i!](^i~P!0{O#`4wOg(^i!](^i~P!0{O!k4zO~Oa$oq!]$oq'y$oq'v$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:aO!Y5QO~O!]5RO!_)PX~P#/XOa$zX!_$zX%^]X'y$zX!]$zX~P!/wO%^5UOaoXnoX!QoX!_oX'xoX'yoX(xoX(yoX!]oX~Op5VO(S#nO~O%^5UO~Ob5]O%j5^O(S+nO(UTO(XUO!]'sX!^'sX~O!]0}O!^)Wa~O[5bO~O`5cO~Oa%mO'y%mO~P#/XO!]5kO#`5mO!^)TX~O!^5nO~Or5tOs!nO!S*fO!b!yO!c!vO!d!vO!|;wO#T!pO#U!pO#V!pO#W!pO#X!pO#[5sO#]!zO(T!lO(UTO(XUO(d!mO(n!sO~O!^5rO~P%:YOn5yO!_1gO%i5xO~Oh%VOn5yO!_1gO%i5xO~Ob6QO(S#nO(UTO(XUO!]'rX!^'rX~O!]1rO!^)Ua~O(UTO(XUO(d6SO~O`6WO~Oj6ZO&Z6[O~PM|O!k6]O~P%[Oa6_O~Oa6_O~P%[Ob2YO!^6dO&i2XO~P`O!g6fO~O!g6hOh(ii!](ii!^(ii!g(ii!l(iir(ii(q(ii~O!]#hi!^#hi~P#B]O#`6iO!]#hi!^#hi~O!]!ai!^!ai~P#B]Oa%mO#`6rO'y%mO~Oa%mO!g#vO#`6rO'y%mO~O!](sq!k(sqa(sq'y(sq~P!:aO!](hO!k(rq~O!S%gO!_%hO#j6yO(S%fO~O!_'^O%i6|O~On7QO!_'^O%i6|O~O#k'haP'haR'ha['haa'haj'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha'y'ha(`'ha(q'ha!k'ha!Y'ha'v'hav'ha!_'ha%i'ha!g'ha~P%,XO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'y'ja(`'ja(q'ja!k'ja!Y'ja'v'jav'ja!_'ja%i'ja!g'ja~P%,zO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'y$|i(`$|i(q$|i!k$|i!Y$|i'v$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/XO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'y%ai(`%ai(q%ai!k%ai!Y%ai'v%aiv%ai!_%ai%i%ai!g%ai~P%4[O#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'y%ci(`%ci(q%ci!k%ci!Y%ci'v%civ%ci!_%ci%i%ci!g%ci~P%4}O!]'Xa!k'Xa~P!:aO!].oO!k(ji~O$O#ci!]#ci!^#ci~P#B]OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(`VO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#n#mi~P%MXO#n<PO~P%MXOP$[OR#zOr<]O!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#r#mi~P& aO#r<RO~P& aOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O(`VO#x#mi#z#mi#{#mi$O#mi(q#mi(x#mi(y#mi!]#mi!^#mi~O#v#mi~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO(`VO(y#}O#z#mi#{#mi$O#mi(q#mi(x#mi!]#mi!^#mi~O#x<VO~P&%jO#x#mi~P&%jO#v<TO~P&#iOP$[OR#zO[<_Oj<SOr<]O!Q#yO!S#{O!l#xO!p$[O#R<SO#n<PO#o<QO#p<QO#q<QO#r<RO#s<SO#t<SO#u<^O#v<TO#x<VO(`VO(x#|O(y#}O#{#mi$O#mi(q#mi!]#mi!^#mi~O#z#mi~P&'yO#z<XO~P&'yOa#|y!]#|y'y#|y'v#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:aO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(q#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<PO#o<QO#p<QO#q<QO(`VO(x#mi(y#mi~P&*uOn=}O!Q)|O'x)}O(x$}O(y%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(`#mi~P&*uO#S$dOP(_XR(_X[(_Xj(_Xn(_Xr(_X!Q(_X!S(_X!l(_X!p(_X#R(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#t(_X#u(_X#v(_X#x(_X#z(_X#{(_X$O(_X'x(_X(`(_X(q(_X(x(_X(y(_X!](_X!^(_X~O$O$Pi!]$Pi!^$Pi~P#B]O$O!ri!^!ri~P$*bOg'[a!]'[a~P!0{O!^7dO~O!]'ca!^'ca~P#B]O!Y7eO~P#/XO!g#vO(q'nO!]'da!k'da~O!]/kO!k(}i~O!]/kO!g#vO!k(}i~Og$|q!]$|q#`$|q$O$|q~P!0{O!Y'fa!]'fa~P#/XO!g7lO~O!]/sO!Y)Oi~P#/XO!]/sO!Y)Oi~O!Y7oO~Oh%VOr7tO!l%dO(q'nO~Oj7vO!g#vO~Or7yO!g#vO(q'nO~O!Q)|O'x)}O(y%POn'ia(x'ia!]'ia#`'ia~Og'ia$O'ia~P&3vO!Q)|O'x)}On'ka(x'ka(y'ka!]'ka#`'ka~Og'ka$O'ka~P&4iO!Y7{O~Og%Oq!]%Oq#`%Oq$O%Oq~P!0{Og(^q!](^q~P!0{O#`7|Og(^q!](^q~P!0{Oa$oy!]$oy'y$oy'v$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:aO!g6hO~O!]5RO!_)Pa~O!_'^OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(`$Ta(q$Ta(x$Ta(y$Ta~O%i6|O~P&7ZO%^8QOa%[i!_%[i'y%[i!]%[i~Oa#cy!]#cy'y#cy'v#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:aO[8SO~Ob8UO(S+nO(UTO(XUO~O!]0}O!^)Wi~O`8YO~O(d(zO!]'oX!^'oX~O!]5kO!^)Ta~O!^8cO~P%:YO(n!sO~P$${O#[8dO~O!_1gO~O!_1gO%i8fO~On8iO!_1gO%i8fO~O[8nO!]'ra!^'ra~O!]1rO!^)Ui~O!k8rO~O!k8sO~O!k8vO~O!k8vO~P%[Oa8xO~O!g8yO~O!k8zO~O!](vi!^(vi~P#B]Oa%mO#`9SO'y%mO~O!](sy!k(sya(sy'y(sy~P!:aO!](hO!k(ry~O%i9VO~P&7ZO!_'^O%i9VO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'y$|q(`$|q(q$|q!k$|q!Y$|q'v$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/XO#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'y'ia(`'ia(q'ia!k'ia!Y'ia'v'iav'ia!_'ia%i'ia!g'ia~P&3vO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'y'ka(`'ka(q'ka!k'ka!Y'ka'v'kav'ka!_'ka%i'ka!g'ka~P&4iO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'y%Oq(`%Oq(q%Oq!k%Oq!Y%Oq'v%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/XO!]'Xi!k'Xi~P!:aO$O#cq!]#cq!^#cq~P#B]O(x$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(`%aa(q%aa!]%aa!^%aa~On%aa!Q%aa'x%aa(y%aa~P&HnO(y%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(`%ca(q%ca!]%ca!^%ca~On%ca!Q%ca'x%ca(x%ca~P&JuOn=}O!Q)|O'x)}O(y%PO~P&HnOn=}O!Q)|O'x)}O(x$}O~P&JuOR0cO!Q0cO!S0dO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'x}a(`}a(q}a(x}a(y}a!]}a!^}a~O!Q)|O'x)}OP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(`$sa(q$sa(x$sa(y$sa!]$sa!^$sa~O!Q)|O'x)}OP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(`$ua(q$ua(x$ua(y$ua!]$ua!^$ua~On=}O!Q)|O'x)}O(x$}O(y%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(`%Ta(q%Ta!]%Ta!^%Ta~P'%zO$O$mq!]$mq!^$mq~P#B]O$O$oq!]$oq!^$oq~P#B]O!^9dO~O$O9eO~P!0{O!g#vO!]'di!k'di~O!g#vO(q'nO!]'di!k'di~O!]/kO!k(}q~O!Y'fi!]'fi~P#/XO!]/sO!Y)Oq~Or9lO!g#vO(q'nO~O[9nO!Y9mO~P#/XO!Y9mO~Oj9tO!g#vO~Og(^y!](^y~P!0{O!]'ma!_'ma~P#/XOa%[q!_%[q'y%[q!]%[q~P#/XO[9yO~O!]0}O!^)Wq~O#`9}O!]'oa!^'oa~O!]5kO!^)Ti~P#B]O!S:PO~O!_1gO%i:SO~O(UTO(XUO(d:XO~O!]1rO!^)Uq~O!k:[O~O!k:]O~O!k:^O~O!k:^O~P%[O#`:aO!]#hy!^#hy~O!]#hy!^#hy~P#B]O%i:fO~P&7ZO!_'^O%i:fO~O$O#|y!]#|y!^#|y~P#B]OP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(`$|i(q$|i!]$|i!^$|i~P'%zO!Q)|O'x)}O(y%POP'haR'ha['haj'han'har'ha!S'ha!l'ha!p'ha#R'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#t'ha#u'ha#v'ha#x'ha#z'ha#{'ha$O'ha(`'ha(q'ha(x'ha!]'ha!^'ha~O!Q)|O'x)}OP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(`'ja(q'ja(x'ja(y'ja!]'ja!^'ja~O(x$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'x%ai(`%ai(q%ai(y%ai!]%ai!^%ai~O(y%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'x%ci(`%ci(q%ci(x%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#B]O$O#cy!]#cy!^#cy~P#B]O!g#vO!]'dq!k'dq~O!]/kO!k(}y~O!Y'fq!]'fq~P#/XOr:pO!g#vO(q'nO~O[:tO!Y:sO~P#/XO!Y:sO~Og(^!R!](^!R~P!0{Oa%[y!_%[y'y%[y!]%[y~P#/XO!]0}O!^)Wy~O!]5kO!^)Tq~O(S:zO~O!_1gO%i:}O~O!k;QO~O%i;VO~P&7ZOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(`$|q(q$|q!]$|q!^$|q~P'%zO!Q)|O'x)}O(y%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(`'ia(q'ia(x'ia!]'ia!^'ia~O!Q)|O'x)}OP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(`'ka(q'ka(x'ka(y'ka!]'ka!^'ka~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(`%Oq(q%Oq!]%Oq!^%Oq~P'%zOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!0{O!Y;ZO~P#/XOr;[O!g#vO(q'nO~O[;^O!Y;ZO~P#/XO!]'oq!^'oq~P#B]O!]#h!Z!^#h!Z~P#B]O#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'y%e!Z(`%e!Z(q%e!Z!k%e!Z!Y%e!Z'v%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/XOr;fO!g#vO(q'nO~O!Y;gO~P#/XOr;nO!g#vO(q'nO~O!Y;oO~P#/XOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(`%e!Z(q%e!Z!]%e!Z!^%e!Z~P'%zOr;rO!g#vO(q'nO~Ov(eX~P1qO!Q%qO~P!)PO(T!lO~P!)PO!YfX!]fX#`fX~P%0kOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(`]X(q]X(x]X(y]X~O!gfX!k]X!kfX(qfX~P'JsOP;vOQ;vOSfOd=rOe!iOpkOr;vOskOtkOzkO|;vO!O;vO!SWO!WkO!XkO!_XO!i;yO!lZO!o;vO!p;vO!q;vO!s;zO!u;}O!x!hO$W!kO$n=pO(S)ZO(UTO(XUO(`VO(n[O~O!]<ZO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<fO!S${O!_$|O!i=wO!l$xO#j<lO$W%_O$t<hO$v<jO$y%`O(S(tO(UTO(XUO(`$uO(x$}O(y%PO~Ol)bO~P( iOr!eX(q!eX~P# }Or(iX(q(iX~P#!pO!^]X!^fX~P'JsO!YfX!Y$zX!]fX!]$zX#`fX~P!/wO#k<OO~O!g#vO#k<OO~O#`<`O~Oj<SO~O#`<pO!](vX!^(vX~O#`<`O!](tX!^(tX~O#k<qO~Og<sO~P!0{O#k<yO~O#k<zO~O!g#vO#k<{O~O!g#vO#k<qO~O$O<|O~P#B]O#k<}O~O#k=OO~O#k=TO~O#k=UO~O#k=VO~O#k=WO~O$O=XO~P!0{O$O=YO~P!0{Ok#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~'}T#o!X'{(T#ps#n#qr!Q'|$]'|(S$_(d~",
  goto: "$8g)[PPPPPP)]PP)`P)qP+R/WPPPP6bPP6xPP<pPPP@dP@zP@zPPP@zPCSP@zP@zP@zPCWPC]PCzPHtPPPHxPPPPHxK{PPPLRLsPHxPHxPP! RHxPPPHxPHxP!#YHxP!&p!'u!(OP!(r!(v!(r!,TPPPPPPP!,t!'uPP!-U!.vP!2SHxHx!2X!5e!:R!:R!>QPPP!>YHxPPPPPPPPP!AiP!BvPPHx!DXPHxPHxHxHxHxHxPHx!EkP!HuP!K{P!LP!LZ!L_!L_P!HrP!Lc!LcP# iP# mHxPHx# s#$xCW@zP@zP@z@zP#&V@z@z#(i@z#+a@z#-m@z@z#.]#0q#0q#0v#1P#0q#1[PP#0qP@z#1t@z#5s@z@z6bPPP#9xPPP#:c#:cP#:cP#:y#:cPP#;PP#:vP#:v#;d#:v#<O#<U#<X)`#<[)`P#<c#<c#<cP)`P)`P)`P)`PP)`P#<i#<lP#<l)`P#<pP#<sP)`P)`P)`P)`P)`P)`)`PP#<y#=P#=[#=b#=h#=n#=t#>S#>Y#>d#>j#>t#>z#?[#?b#@S#@f#@l#@r#AQ#Ag#C[#Cj#Cq#E]#Ek#G]#Gk#Gq#Gw#G}#HX#H_#He#Ho#IR#IXPPPPPPPPPPP#I_PPPPPPP#JS#MZ#Ns#Nz$ SPPP$&nP$&w$)p$0Z$0^$0a$1`$1c$1j$1rP$1x$1{P$2i$2m$3e$4s$4x$5`PP$5e$5k$5o$5r$5v$5z$6v$7_$7v$7z$7}$8Q$8W$8Z$8_$8cR!|RoqOXst!Z#d%l&p&r&s&u,n,s2S2VY!vQ'^-`1g5qQ%svQ%{yQ&S|Q&h!VS'U!e-WQ'd!iS'j!r!yU*h$|*X*lQ+l%|Q+y&UQ,_&bQ-^']Q-h'eQ-p'kQ0U*nQ1q,`R<m;z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9SS#q];w!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU*{%[<e<fQ+q&OQ,a&eQ,h&mQ0r+dQ0w+fQ1S+rQ1y,fQ3W.bQ5V0vQ5]0}Q6Q1rQ7O3[Q8U5^R9Y7Q'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s!S!nQ!r!v!y!z$|'U']'^'j'k'l*h*l*n*o-W-^-`-p0U0X1g5q5s%[$ti#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q&V|Q'S!eS'Y%h-ZQ+q&OQ,a&eQ0f+OQ1S+rQ1X+xQ1x,eQ1y,fQ5]0}Q5f1ZQ6Q1rQ6T1tQ6U1wQ8U5^Q8X5cQ8q6WQ9|8YQ:Y8nR<o*XrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR,c&i&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=r=s[#]WZ#W#Z'V(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ%vxQ%zyS&P|&UQ&]!TQ'a!hQ'c!iQ(o#sS+k%{%|Q+o&OQ,Y&`Q,^&bS-g'd'eQ.d(pQ0{+lQ1R+rQ1T+sQ1W+wQ1l,ZS1p,_,`Q2t-hQ5[0}Q5`1QQ5e1YQ6P1qQ8T5^Q8W5bQ9x8SR:w9y!U$zi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y!^%xy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pQ+e%vQ,O&YQ,R&ZQ,]&bQ.c(oQ1k,YU1o,^,_,`Q3].dQ5z1lS6O1p1qQ8m6P#f=t#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o=u<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YW%Ti%V*v=pS&Y!Q&gQ&Z!RQ&[!SQ+S%cR+|&W%]%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}T)x$u)yV*{%[<e<fW'Y!e%h*X-ZS({#y#zQ+`%qQ+v&RS.](k(lQ1b,SQ4x0cR8^5k'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s$i$^c#Y#e%p%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.w.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ'W!eR2i-W!W!nQ!e!r!v!y!z$|'U']'^'j'k'l*X*h*l*n*o-W-^-`-p0U0X1g5q5sR1d,UnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&w!^Q't!xS(q#u<OQ+i%yQ,W&]Q,X&_Q-e'bQ-r'mS.m(v<qS0k+U<{Q0y+jQ1f,VQ2Z,uQ2],vQ2e-RQ2r-fQ2u-jS5P0l=VQ5W0zS5Z0|=WQ6j2gQ6n2sQ6s2zQ8R5XQ8}6lQ9O6oQ9R6tR:`8z$d$]c#Y#e%r%t(Q(W(r(w)P)Q)R)S)T)U)V)W)X)Y)[)^)`)e)o+a+u-U-s-x-}.P.n.q.u.x.y/]0j2c2f2v2}3c3h3i3j3k3l3m3n3o3p3q3r3s3t3w3x4P5O5Y6k6q6v7V7W7a7b8`8|9Q9[9b9c:c:y;R;x=gS(m#p'gQ(}#zS+_%p.wS.^(l(nR3U._'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS#q];wQ&r!XQ&s!YQ&u![Q&v!]R2R,qQ'_!hQ+b%vQ-c'aS.`(o+eQ2p-bW3Y.c.d0q0sQ6m2qW6z3V3X3]5TU9U6{6}7PU:e9W9X9ZS;T:d:gQ;b;UR;j;cU!wQ'^-`T5o1g5q!Q_OXZ`st!V!Z#d#h%d%l&g&i&p&r&s&u(h,n,s.V2S2V]!pQ!r'^-`1g5qT#q];w%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS({#y#zS.](k(l!s=^$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sU$fd)],hS(n#p'gU*s%R(u3vU0e*z.i7]Q5T0rQ6{3WQ9X7OR:g9Ym!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sQ'r!uS(d#g1|S-n'i'uQ/n*ZQ/{*gQ2|-qQ4]/oQ4i/}Q4j0OQ4o0WQ7h4WS7s4k4mS7w4p4rQ9g7iQ9k7oQ9p7tQ9u7yS:o9l9mS;Y:p:sS;e;Z;[S;m;f;gS;q;n;oR;t;rQ#wbQ'q!uS(c#g1|S(e#m+TQ+V%eQ+g%wQ+m%}U-m'i'r'uQ.R(dQ/m*ZQ/|*gQ0P*iQ0x+hQ1m,[S2y-n-qQ3R.ZS4[/n/oQ4e/yS4h/{0WQ4l0QQ5|1nQ6u2|Q7g4WQ7k4]U7r4i4o4rQ7u4nQ8k5}S9f7h7iQ9j7oQ9r7wQ9s7xQ:V8lQ:m9gS:n9k9mQ:v9uQ;P:WS;X:o:sS;d;Y;ZS;l;e;gS;p;m;oQ;s;qQ;u;tQ=a=[Q=l=eR=m=fV!wQ'^-`%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SS#wz!j!r=Z$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=a=r%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SQ%ej!^%wy!i!u%z%{%|'T'c'd'e'i's*g+k+l-T-g-h-o/{0O0{2m2t2{4i4j4m7s9pS%}z!jQ+h%xQ,[&bW1n,],^,_,`U5}1o1p1qS8l6O6PQ:W8m!r=[$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ=e=qR=f=r%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9SY#bWZ#W#Z(R!b%im#h#i#l$x%d%g([(f(g(h*W*[*_+W+X+Z,j-Q.O.U.V.W.Y/h/k2[3S3T4X6h6yQ,i&m!p=]$Z$n)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sR=`'VU'Z!e%h*XR2k-Z%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y,k,n,s-d-l-z.Q.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3d4q5y6Z6[6_6r8i8x9S!r)]$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sQ,h&mQ0r+dQ3W.bQ7O3[R9Y7Q!b$Tc#Y%p(Q(W(r(w)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!P<U)[)o-U.w2c2f3h3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!f$Vc#Y%p(Q(W(r(w)U)V)X)Y)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;x!T<W)[)o-U.w2c2f3h3n3o3q3r3w4P6k7W7a7b8`8|9[9b9c:y;R=g!^$Zc#Y%p(Q(W(r(w)^)e+u-s-x-}.P.n.q/]0j2v2}3c3s5O5Y6q6v7V9Q:c;xQ4V/fz=s)[)o-U.w2c2f3h3w4P6k7W7a7b8`8|9[9b9c:y;R=gQ=x=zR=y={'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sS$oh$pR3|/P'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$kf$qQ$ifS)h$l)lR)t$qT$jf$qT)j$l)l'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%l%s&Q&i&l&m&p&r&s&u&y'R'V'`'p(R(T(Z(b(v(x(|)q){*f+U+Y+d,k,n,s-P-S-d-l-z.Q.b.o.v/P/Q/i0V0d0l0|1j1z1{1}2P2S2V2X2h2x3O3[3d3{4q5m5y6Z6[6_6i6r7Q8i8x9S9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=sT$oh$pQ$rhR)s$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%l%s&Q&i&l&m&p&r&s&u&y'R'`'p(R(T(Z(b(v(x(|){*f+U+Y+d,k,n,s-d-l-z.Q.b.o.v/i0V0d0l0|1j1z1{1}2P2S2V2X2x3O3[3d4q5y6Z6[6_6r7Q8i8x9S!s=q$Z$n'V)q-P-S/Q2h3{5m6i9}:a;v;y;z;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<]<`<m<p<q<s<{<|=V=W=s#glOPXZst!Z!`!o#S#d#o#{$n%l&i&l&m&p&r&s&u&y'R'`(|)q*f+Y+d,k,n,s-d.b/Q/i0V0d1j1z1{1}2P2S2V2X3[3{4q5y6Z6[6_7Q8i8x!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}Q+P%`Q/^)|o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!U$yi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yQ*`$zU*i$|*X*lQ+Q%aQ0Q*j#f=c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n=d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YQ=h=tQ=i=uQ=j=vR=k=w!U%Ri$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y#f(u#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}o3v<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=YnoOXst!Z#d%l&p&r&s&u,n,s2S2VS*c${*WQ,|&|Q,}'OR4`/s%[%Si#v$b$c$d$x${%O%Q%]%^%b)w*P*R*T*W*^*d*t*u+c+f+},Q.a.z/_/h/r/s/u0Y0[0g0h0i1^1a1i3Z4U4V4a4f4w5R5U5x6|7l7v7|8Q8f9V9e9n9t:S:f:t:};V;^<^<_<a<b<c<d<g<h<i<j<k<l<t<u<v<w<y<z<}=O=P=Q=R=S=T=U=X=Y=p=x=y=|=}Q,P&ZQ1`,RQ5i1_R8]5jV*k$|*X*lU*k$|*X*lT5p1g5qS/y*f/iQ4n0VT7x4q:PQ+g%wQ0P*iQ0x+hQ1m,[Q5|1nQ8k5}Q:V8lR;P:W!U%Oi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=yx*P$v)c*Q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=oS0Y*q0Z#f<a#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<b<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!d<t(s)a*Y*b.e.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={`<u3u7X7[7`9]:h:k;kS=P.g3aT=Q7Z9`!U%Qi$d%O%Q%]%^%b*P*R*^*t*u.z/r0Y0[0g0h0i4V4w7|9e=p=x=y|*R$v)c*S*q+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=oS0[*r0]#f<c#v$b$c$x${)w*T*W*d+c+f+},Q.a/_/h/s/u1^1a1i3Z4U4a4f5R5U5x6|7l7v8Q8f9V9n9t:S:f:t:};V;^<a<c<g<i<k<t<v<y<}=P=R=T=X=|=}n<d<^<_<b<d<h<j<l<u<w<z=O=Q=S=U=Y!h<v(s)a*Y*b.f.g.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={d<w3u7Y7Z7`9]9^:h:i:k;kS=R.h3bT=S7[9arnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ&d!UR,k&mrnOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VR&d!UQ,T&[R1[+|snOXst!V!Z#d%l&g&p&r&s&u,n,s2S2VQ1h,YS5w1k1lU8e5u5v5zS:R8g8hS:{:Q:TQ;_:|R;i;`Q&k!VR,d&gR6T1tR:Y8nS&P|&UR1T+sQ&p!WR,n&qR,t&vT2T,s2VR,x&wQ,w&wR2^,xQ'w!{R-t'wSsOtQ#dXT%os#dQ#OTR'y#OQ#RUR'{#RQ)y$uR/Z)yQ#UVR(O#UQ#XWU(U#X(V-{Q(V#YR-{(WQ-X'WR2j-XQ.p(wS3e.p3fR3f.qQ-`'^R2n-`Y!rQ'^-`1g5qR'h!rQ.{)cR3z.{U#_W%g*WU(]#_(^-|Q(^#`R-|(XQ-['ZR2l-[t`OXst!V!Z#d%l&g&i&p&r&s&u,n,s2S2VS#hZ%dU#r`#h.VR.V(hQ(i#jQ.S(eW.[(i.S3P6wQ3P.TR6w3QQ)l$lR/R)lQ$phR)r$pQ$`cU)_$`-w<[Q-w;xR<[)oQ/l*ZW4Y/l4Z7j9hU4Z/m/n/oS7j4[4]R9h7k$e*O$v(s)a)c*Y*b*q*r*|*}+R.g.h.j.k.l/Y/b/d/f/q/v0^0_0p1]3^3_3`3u3y4S4^4_4c4s4u4{4|4}5h7R7S7T7U7Z7[7^7_7`7f7m7p7z7}8P9]9^9_9i9q9v9w:h:i:j:k:l:q:u;W;];h;k=b=n=o=z={Q/t*bU4b/t4d7nQ4d/vR7n4cS*l$|*XR0S*lx*Q$v)c*q*r+R/q0^0_3y4^4{4|4}7f7z9v:l=b=n=o!d.e(s)a*Y*b.g.h.l/Y/f/v0p1]3`4S4_4c5h7R7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/c*Q.e7Xa7X3u7Z7[7`9]:h:k;kQ0Z*qQ3a.gU4t0Z3a9`R9`7Z|*S$v)c*q*r+R/b/q0^0_3y4^4s4{4|4}7f7z9v:l=b=n=o!h.f(s)a*Y*b.g.h.l/Y/f/v0p1]3^3`4S4_4c5h7R7S7U7m7p7}8P9i9q9w:q:u;W;];h=z={U/e*S.f7Ye7Y3u7Z7[7`9]9^:h:i:k;kQ0]*rQ3b.hU4v0]3b9aR9a7[Q*w%UR0a*wQ5S0pR8O5SQ+[%jR0o+[Q5l1bS8_5l:OR:O8`Q,V&]R1e,VQ5q1gR8b5qQ1s,aS6R1s8oR8o6TQ1O+oW5_1O5a8V9zQ5a1RQ8V5`R9z8WQ+t&PR1U+tQ2V,sR6c2VYrOXst#dQ&t!ZQ+^%lQ,m&pQ,o&rQ,p&sQ,r&uQ2Q,nS2T,s2VR6b2SQ%npQ&x!_Q&{!aQ&}!bQ'P!cQ'o!uQ+]%kQ+i%yQ+{&VQ,c&kQ,z&zW-k'i'q'r'uQ-r'mQ0R*kQ0y+jS1v,d,gQ2_,yQ2`,|Q2a,}Q2u-jW2w-m-n-q-sQ5W0zQ5d1XQ5g1]Q5{1mQ6V1xQ6a2RU6p2v2y2|Q6s2zQ8R5XQ8Z5fQ8[5hQ8a5pQ8j5|Q8p6US9P6q6uQ9R6tQ9{8XQ:U8kQ:Z8qQ:b9QQ:x9|Q;O:VQ;S:cR;a;PQ%yyQ'b!iQ'm!uU+j%z%{%|Q-R'TU-f'c'd'eS-j'i'sQ/z*gS0z+k+lQ2g-TS2s-g-hQ2z-oS4g/{0OQ5X0{Q6l2mQ6o2tQ6t2{U7q4i4j4mQ9o7sR:r9pS$wi=pR*x%VU%Ui%V=pR0`*vQ$viS(s#v+fS)a$b$cQ)c$dQ*Y$xS*b${*WQ*q%OQ*r%QQ*|%]Q*}%^Q+R%bQ.g<aQ.h<cQ.j<gQ.k<iQ.l<kQ/Y)wQ/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*ul0p+c,Q.a1a1i3Z5x6|8f9V:S:f:};VQ1]+}Q3^<tQ3_<vQ3`<yS3u<^<_Q3y.zS4S/_4UQ4^/rQ4_/sQ4c/uQ4s0YQ4u0[Q4{0gQ4|0hQ4}0iQ5h1^Q7R<}Q7S=PQ7T=RQ7U=TQ7Z<bQ7[<dQ7^<hQ7_<jQ7`<lQ7f4VQ7m4aQ7p4fQ7z4wQ7}5RQ8P5UQ9]<zQ9^<uQ9_<wQ9i7lQ9q7vQ9v7|Q9w8QQ:h=OQ:i=QQ:j=SQ:k=UQ:l9eQ:q9nQ:u9tQ;W=XQ;]:tQ;h;^Q;k=YQ=b=pQ=n=xQ=o=yQ=z=|R={=}Q*z%[Q.i<eR7]<fnpOXst!Z#d%l&p&r&s&u,n,s2S2VQ!fPS#fZ#oQ&z!`W'f!o*f0V4qQ'}#SQ)O#{Q)p$nS,g&i&lQ,l&mQ,y&yS-O'R/iQ-b'`Q.s(|Q/V)qQ0m+YQ0s+dQ2O,kQ2q-dQ3X.bQ4O/QQ4y0dQ5v1jQ6X1zQ6Y1{Q6^1}Q6`2PQ6e2XQ7P3[Q7c3{Q8h5yQ8t6ZQ8u6[Q8w6_Q9Z7QQ:T8iR:_8x#[cOPXZst!Z!`!o#d#o#{%l&i&l&m&p&r&s&u&y'R'`(|*f+Y+d,k,n,s-d.b/i0V0d1j1z1{1}2P2S2V2X3[4q5y6Z6[6_7Q8i8xQ#YWQ#eYQ%puQ%rvS%tw!gS(Q#W(TQ(W#ZQ(r#uQ(w#xQ)P$OQ)Q$PQ)R$QQ)S$RQ)T$SQ)U$TQ)V$UQ)W$VQ)X$WQ)Y$XQ)[$ZQ)^$_Q)`$aQ)e$eW)o$n)q/Q3{Q+a%sQ+u&QS-U'V2hQ-s'pS-x(R-zQ-}(ZQ.P(bQ.n(vQ.q(xQ.u;vQ.w;yQ.x;zQ.y;}Q/]){Q0j+UQ2c-PQ2f-SQ2v-lQ2}.QQ3c.oQ3h<OQ3i<PQ3j<QQ3k<RQ3l<SQ3m<TQ3n<UQ3o<VQ3p<WQ3q<XQ3r<YQ3s.vQ3t<]Q3w<`Q3x<mQ4P<ZQ5O0lQ5Y0|Q6k<pQ6q2xQ6v3OQ7V3dQ7W<qQ7a<sQ7b<{Q8`5mQ8|6iQ9Q6rQ9[<|Q9b=VQ9c=WQ:c9SQ:y9}Q;R:aQ;x#SR=g=sR#[WR'X!el!tQ!r!v!y!z'^'j'k'l-`-p1g5q5sS'T!e-WU*g$|*X*lS-T'U']S0O*h*nQ0W*oQ2m-^Q4m0UR4r0XR(y#xQ!fQT-_'^-`]!qQ!r'^-`1g5qQ#p]R'g;wR)d$dY!uQ'^-`1g5qQ'i!rS's!v!yS'u!z5sS-o'j'kQ-q'lR2{-pT#kZ%dS#jZ%dS%jm,jU(e#h#i#lS.T(f(gQ.X(hQ0n+ZQ3Q.UU3R.V.W.YS6x3S3TR9T6yd#^W#W#Z%g(R([*W+W.O/hr#gZm#h#i#l%d(f(g(h+Z.U.V.W.Y3S3T6yS*Z$x*_Q/o*[Q1|,jQ2d-QQ4W/kQ6g2[Q7i4XQ8{6hT=_'V+XV#aW%g*WU#`W%g*WS(S#W([U(X#Z+W/hS-V'V+XT-y(R.OV'[!e%h*XQ$lfR)v$qT)k$l)lR3}/PT*]$x*_T*e${*WQ0q+cQ1_,QQ3V.aQ5j1aQ5u1iQ6}3ZQ8g5xQ9W6|Q:Q8fQ:d9VQ:|:SQ;U:fQ;`:}R;c;VnqOXst!Z#d%l&p&r&s&u,n,s2S2VQ&j!VR,c&gtmOXst!U!V!Z#d%l&g&p&r&s&u,n,s2S2VR,j&mT%km,jR1c,SR,b&eQ&T|R+z&UR+p&OT&n!W&qT&o!W&qT2U,s2V",
  nodeNames:
    '⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem',
  maxTerm: 379,
  context: trackNewline,
  nodeProps: [
    ['isolate', -8, 5, 6, 14, 37, 39, 51, 53, 55, ''],
    [
      'group',
      -26,
      9,
      17,
      19,
      68,
      207,
      211,
      215,
      216,
      218,
      221,
      224,
      234,
      236,
      242,
      244,
      246,
      248,
      251,
      257,
      263,
      265,
      267,
      269,
      271,
      273,
      274,
      'Statement',
      -34,
      13,
      14,
      32,
      35,
      36,
      42,
      51,
      54,
      55,
      57,
      62,
      70,
      72,
      76,
      80,
      82,
      84,
      85,
      110,
      111,
      120,
      121,
      136,
      139,
      141,
      142,
      143,
      144,
      145,
      147,
      148,
      167,
      169,
      171,
      'Expression',
      -23,
      31,
      33,
      37,
      41,
      43,
      45,
      173,
      175,
      177,
      178,
      180,
      181,
      182,
      184,
      185,
      186,
      188,
      189,
      190,
      201,
      203,
      205,
      206,
      'Type',
      -3,
      88,
      103,
      109,
      'ClassItem'
    ],
    [
      'openedBy',
      23,
      '<',
      38,
      'InterpolationStart',
      56,
      '[',
      60,
      '{',
      73,
      '(',
      160,
      'JSXStartCloseTag'
    ],
    [
      'closedBy',
      -2,
      24,
      168,
      '>',
      40,
      'InterpolationEnd',
      50,
      ']',
      61,
      '}',
      74,
      ')',
      165,
      'JSXEndTag'
    ]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0, 5, 6, 277],
  repeatNodeCount: 37,
  tokenData:
    "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Vp(Y!b'{0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(W#S$i&j'|0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Vp(Y!b'|0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(U':f$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Vp(Y!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Vp(Y!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Y!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Y!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(VpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(VpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Vp(Y!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(n%1l(Vp(Y!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Vp(Y!b$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Vp(Y!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Vp(Y!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(y+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(X';W$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(VpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(VpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(VpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(VpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Vp(Y!b(T%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Vp(Y!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Vp(Y!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Vp(Y!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Vp(Y!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Y!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Y!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Y!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Y!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Y!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Y!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Vp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Vp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Vp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Vp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(VpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(VpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Vp(Y!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Vp(Y!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Vp(Y!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Vp(Y!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Vp(Y!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Vp(Y!b'}0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Vp(Y!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Y!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Y!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(VpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(VpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Vp(Y!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Vp(Y!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Vp(Y!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Vp(Y!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(q(Ct$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Vp(Y!b(`+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Vp(Y!b(S,2j$_#t(d$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Vp(Y!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Vp(Y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(x+JY$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Vp(Y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Vp(Y!b'{0/l$]#t(S,2j(d$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Vp(Y!b'|0/l$]#t(S,2j(d$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [
    noSemicolon,
    noSemicolonType,
    operatorToken,
    jsx,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    insertSemicolon,
    new LocalTokenGroup(
      "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(b~~",
      141,
      339
    ),
    new LocalTokenGroup('j~RQYZXz{^~^O(P~~aP!P!Qd~iO(Q~~', 25, 322)
  ],
  topRules: { Script: [0, 7], SingleExpression: [1, 275], SingleClassItem: [2, 276] },
  dialects: { jsx: 0, ts: 15098 },
  dynamicPrecedences: { 80: 1, 82: 1, 94: 1, 169: 1, 199: 1 },
  specialized: [
    { term: 326, get: (value) => spec_identifier[value] || -1 },
    { term: 342, get: (value) => spec_word[value] || -1 },
    { term: 95, get: (value) => spec_LessThan[value] || -1 }
  ],
  tokenPrec: 15124
})
const snippets = [
  /* @__PURE__ */ snippetCompletion('function ${name}(${params}) {\n	${}\n}', {
    label: 'function',
    detail: 'definition',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion(
    'for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}',
    {
      label: 'for',
      detail: 'loop',
      type: 'keyword'
    }
  ),
  /* @__PURE__ */ snippetCompletion('for (let ${name} of ${collection}) {\n	${}\n}', {
    label: 'for',
    detail: 'of loop',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('do {\n	${}\n} while (${})', {
    label: 'do',
    detail: 'loop',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('while (${}) {\n	${}\n}', {
    label: 'while',
    detail: 'loop',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('try {\n	${}\n} catch (${error}) {\n	${}\n}', {
    label: 'try',
    detail: '/ catch block',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('if (${}) {\n	${}\n}', {
    label: 'if',
    detail: 'block',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('if (${}) {\n	${}\n} else {\n	${}\n}', {
    label: 'if',
    detail: '/ else block',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}', {
    label: 'class',
    detail: 'definition',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: 'import',
    detail: 'named',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: 'import',
    detail: 'default',
    type: 'keyword'
  })
]
const typescriptSnippets = /* @__PURE__ */ snippets.concat([
  /* @__PURE__ */ snippetCompletion('interface ${name} {\n	${}\n}', {
    label: 'interface',
    detail: 'definition',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('type ${name} = ${type}', {
    label: 'type',
    detail: 'definition',
    type: 'keyword'
  }),
  /* @__PURE__ */ snippetCompletion('enum ${name} {\n	${}\n}', {
    label: 'enum',
    detail: 'definition',
    type: 'keyword'
  })
])
const cache = /* @__PURE__ */ new NodeWeakMap()
const ScopeNodes = /* @__PURE__ */ new Set([
  'Script',
  'Block',
  'FunctionExpression',
  'FunctionDeclaration',
  'ArrowFunction',
  'MethodDeclaration',
  'ForStatement'
])
function defID(type) {
  return (node, def) => {
    let id2 = node.node.getChild('VariableDefinition')
    if (id2) def(id2, type)
    return true
  }
}
const functionContext = ['FunctionDeclaration']
const gatherCompletions = {
  FunctionDeclaration: /* @__PURE__ */ defID('function'),
  ClassDeclaration: /* @__PURE__ */ defID('class'),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ defID('constant'),
  TypeAliasDeclaration: /* @__PURE__ */ defID('type'),
  NamespaceDeclaration: /* @__PURE__ */ defID('namespace'),
  VariableDefinition(node, def) {
    if (!node.matchContext(functionContext)) def(node, 'variable')
  },
  TypeDefinition(node, def) {
    def(node, 'type')
  },
  __proto__: null
}
function getScope(doc2, node) {
  let cached = cache.get(node)
  if (cached) return cached
  let completions = [],
    top2 = true
  function def(node2, type) {
    let name2 = doc2.sliceString(node2.from, node2.to)
    completions.push({ label: name2, type })
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (top2) {
      top2 = false
    } else if (node2.name) {
      let gather = gatherCompletions[node2.name]
      if ((gather && gather(node2, def)) || ScopeNodes.has(node2.name)) return false
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc2, node2.node)) completions.push(c)
      return false
    }
  })
  cache.set(node, completions)
  return completions
}
const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/
const dontComplete = [
  'TemplateString',
  'String',
  'RegExp',
  'LineComment',
  'BlockComment',
  'VariableDefinition',
  'TypeDefinition',
  'Label',
  'PropertyDefinition',
  'PropertyName',
  'PrivatePropertyDefinition',
  'PrivatePropertyName',
  'JSXText',
  'JSXAttributeValue',
  'JSXOpenTag',
  'JSXCloseTag',
  'JSXSelfClosingTag',
  '.',
  '?.'
]
function localCompletionSource(context) {
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1)
  if (dontComplete.indexOf(inner.name) > -1) return null
  let isWord =
    inner.name == 'VariableName' ||
    (inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to)))
  if (!isWord && !context.explicit) return null
  let options = []
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos))
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  }
}
function pathFor(read, member, name2) {
  var _a2
  let path = []
  for (;;) {
    let obj = member.firstChild,
      prop
    if ((obj === null || obj === void 0 ? void 0 : obj.name) == 'VariableName') {
      path.push(read(obj))
      return { path: path.reverse(), name: name2 }
    } else if (
      (obj === null || obj === void 0 ? void 0 : obj.name) == 'MemberExpression' &&
      ((_a2 = prop = obj.lastChild) === null || _a2 === void 0 ? void 0 : _a2.name) ==
        'PropertyName'
    ) {
      path.push(read(prop))
      member = obj
    } else {
      return null
    }
  }
}
function completionPath(context) {
  let read = (node) => context.state.doc.sliceString(node.from, node.to)
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1)
  if (inner.name == 'PropertyName') {
    return pathFor(read, inner.parent, read(inner))
  } else if ((inner.name == '.' || inner.name == '?.') && inner.parent.name == 'MemberExpression') {
    return pathFor(read, inner.parent, '')
  } else if (dontComplete.indexOf(inner.name) > -1) {
    return null
  } else if (
    inner.name == 'VariableName' ||
    (inner.to - inner.from < 20 && Identifier.test(read(inner)))
  ) {
    return { path: [], name: read(inner) }
  } else if (inner.name == 'MemberExpression') {
    return pathFor(read, inner, '')
  } else {
    return context.explicit ? { path: [], name: '' } : null
  }
}
function enumeratePropertyCompletions(obj, top2) {
  let options = [],
    seen = /* @__PURE__ */ new Set()
  for (let depth = 0; ; depth++) {
    for (let name2 of (Object.getOwnPropertyNames || Object.keys)(obj)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(name2) || seen.has(name2)) continue
      seen.add(name2)
      let value
      try {
        value = obj[name2]
      } catch (_2) {
        continue
      }
      options.push({
        label: name2,
        type:
          typeof value == 'function'
            ? /^[A-Z]/.test(name2)
              ? 'class'
              : top2
                ? 'function'
                : 'method'
            : top2
              ? 'variable'
              : 'property',
        boost: -depth
      })
    }
    let next = Object.getPrototypeOf(obj)
    if (!next) return options
    obj = next
  }
}
function scopeCompletionSource(scope) {
  let cache2 = /* @__PURE__ */ new Map()
  return (context) => {
    let path = completionPath(context)
    if (!path) return null
    let target = scope
    for (let step of path.path) {
      target = target[step]
      if (!target) return null
    }
    let options = cache2.get(target)
    if (!options)
      cache2.set(target, (options = enumeratePropertyCompletions(target, !path.path.length)))
    return {
      from: context.pos - path.name.length,
      options,
      validFor: Identifier
    }
  }
}
const javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
  name: 'javascript',
  parser: /* @__PURE__ */ parser$3.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter,
            closed = /^\s*\}/.test(after),
            isCase = /^\s*(case|default)\b/.test(after)
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit
        },
        Block: /* @__PURE__ */ delimitedIndent({ closing: '}' }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        'TemplateString BlockComment': () => null,
        'Statement Property': /* @__PURE__ */ continuedIndent({ except: /^\s*{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter)
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit)
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter)
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit)
        },
        'JSXOpenTag JSXSelfClosingTag'(context) {
          return context.column(context.node.from) + context.unit
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        'Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType':
          foldInside,
        BlockComment(tree) {
          return { from: tree.from + 2, to: tree.to - 2 }
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ['(', '[', '{', "'", '"', '`'] },
    commentTokens: { line: '//', block: { open: '/*', close: '*/' } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: '$'
  }
})
const jsxSublanguage = {
  test: (node) => /^JSX/.test(node.name),
  facet: /* @__PURE__ */ defineLanguageFacet({
    commentTokens: { block: { open: '{/*', close: '*/}' } }
  })
}
const typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure(
  { dialect: 'ts' },
  'typescript'
)
const jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: 'jsx',
  props: [/* @__PURE__ */ sublanguageProp.add((n2) => (n2.isTop ? [jsxSublanguage] : void 0))]
})
const tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure(
  {
    dialect: 'jsx ts',
    props: [/* @__PURE__ */ sublanguageProp.add((n2) => (n2.isTop ? [jsxSublanguage] : void 0))]
  },
  'typescript'
)
let kwCompletion = (name2) => ({ label: name2, type: 'keyword' })
const keywords =
  /* @__PURE__ */ 'break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield'
    .split(' ')
    .map(kwCompletion)
const typescriptKeywords = /* @__PURE__ */ keywords.concat(
  /* @__PURE__ */ ['declare', 'implements', 'private', 'protected', 'public'].map(kwCompletion)
)
function javascript(config2 = {}) {
  let lang = config2.jsx
    ? config2.typescript
      ? tsxLanguage
      : jsxLanguage
    : config2.typescript
      ? typescriptLanguage
      : javascriptLanguage
  let completions = config2.typescript
    ? typescriptSnippets.concat(typescriptKeywords)
    : snippets.concat(keywords)
  return new LanguageSupport(lang, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(completions))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config2.jsx ? autoCloseTags$1 : []
  ])
}
function findOpenTag(node) {
  for (;;) {
    if (
      node.name == 'JSXOpenTag' ||
      node.name == 'JSXSelfClosingTag' ||
      node.name == 'JSXFragmentTag'
    )
      return node
    if (node.name == 'JSXEscape' || !node.parent) return null
    node = node.parent
  }
}
function elementName$1(doc2, tree, max = doc2.length) {
  for (
    let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild;
    ch;
    ch = ch.nextSibling
  ) {
    if (
      ch.name == 'JSXIdentifier' ||
      ch.name == 'JSXBuiltin' ||
      ch.name == 'JSXNamespacedName' ||
      ch.name == 'JSXMemberExpression'
    )
      return doc2.sliceString(ch.from, Math.min(ch.to, max))
  }
  return ''
}
const android =
  typeof navigator == 'object' && /* @__PURE__ */ /Android\b/.test(navigator.userAgent)
const autoCloseTags$1 = /* @__PURE__ */ EditorView.inputHandler.of(
  (view, from, to, text2, defaultInsert) => {
    if (
      (android ? view.composing : view.compositionStarted) ||
      view.state.readOnly ||
      from != to ||
      (text2 != '>' && text2 != '/') ||
      !javascriptLanguage.isActiveAt(view.state, from, -1)
    )
      return false
    let base2 = defaultInsert(),
      { state } = base2
    let closeTags = state.changeByRange((range) => {
      var _a2
      let { head } = range,
        around = syntaxTree(state).resolveInner(head - 1, -1),
        name2
      if (around.name == 'JSXStartTag') around = around.parent
      if (
        state.doc.sliceString(head - 1, head) != text2 ||
        (around.name == 'JSXAttributeValue' && around.to > head)
      );
      else if (text2 == '>' && around.name == 'JSXFragmentTag') {
        return { range, changes: { from: head, insert: `</>` } }
      } else if (text2 == '/' && around.name == 'JSXStartCloseTag') {
        let empty2 = around.parent,
          base3 = empty2.parent
        if (
          base3 &&
          empty2.from == head - 2 &&
          ((name2 = elementName$1(state.doc, base3.firstChild, head)) ||
            ((_a2 = base3.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) ==
              'JSXFragmentTag')
        ) {
          let insert2 = `${name2}>`
          return {
            range: EditorSelection.cursor(head + insert2.length, -1),
            changes: { from: head, insert: insert2 }
          }
        }
      } else if (text2 == '>') {
        let openTag = findOpenTag(around)
        if (
          openTag &&
          openTag.name == 'JSXOpenTag' &&
          !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) &&
          (name2 = elementName$1(state.doc, openTag, head))
        )
          return { range, changes: { from: head, insert: `</${name2}>` } }
      }
      return { range }
    })
    if (closeTags.changes.empty) return false
    view.dispatch([
      base2,
      state.update(closeTags, { userEvent: 'input.complete', scrollIntoView: true })
    ])
    return true
  }
)
function esLint(eslint, config2) {
  if (!config2) {
    config2 = {
      parserOptions: { ecmaVersion: 2019, sourceType: 'module' },
      env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
      rules: {}
    }
    eslint.getRules().forEach((desc, name2) => {
      var _a2
      if ((_a2 = desc.meta.docs) === null || _a2 === void 0 ? void 0 : _a2.recommended)
        config2.rules[name2] = 2
    })
  }
  return (view) => {
    let { state } = view,
      found = []
    for (let { from, to } of javascriptLanguage.findRegions(state)) {
      let fromLine = state.doc.lineAt(from),
        offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from }
      for (let d of eslint.verify(state.sliceDoc(from, to), config2))
        found.push(translateDiagnostic(d, state.doc, offset))
    }
    return found
  }
}
function mapPos(line, col, doc2, offset) {
  return doc2.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1)
}
function translateDiagnostic(input, doc2, offset) {
  let start = mapPos(input.line, input.column, doc2, offset)
  let result = {
    from: start,
    to:
      input.endLine != null && input.endColumn != 1
        ? mapPos(input.endLine, input.endColumn, doc2, offset)
        : start,
    message: input.message,
    source: input.ruleId ? 'eslint:' + input.ruleId : 'eslint',
    severity: input.severity == 1 ? 'warning' : 'error'
  }
  if (input.fix) {
    let { range, text: text2 } = input.fix,
      from = range[0] + offset.pos - start,
      to = range[1] + offset.pos - start
    result.actions = [
      {
        name: 'fix',
        apply(view, start2) {
          view.dispatch({
            changes: { from: start2 + from, to: start2 + to, insert: text2 },
            scrollIntoView: true
          })
        }
      }
    ]
  }
  return result
}
const index$2 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      autoCloseTags: autoCloseTags$1,
      completionPath,
      esLint,
      javascript,
      javascriptLanguage,
      jsxLanguage,
      localCompletionSource,
      scopeCompletionSource,
      snippets,
      tsxLanguage,
      typescriptLanguage,
      typescriptSnippets
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const Targets = ['_blank', '_self', '_top', '_parent']
const Charsets = ['ascii', 'utf-8', 'utf-16', 'latin1', 'latin1']
const Methods = ['get', 'post', 'put', 'delete']
const Encs = ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain']
const Bool = ['true', 'false']
const S = {}
const Tags = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Targets,
      hreflang: null
    }
  },
  abbr: S,
  address: S,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ['default', 'rect', 'circle', 'poly']
    }
  },
  article: S,
  aside: S,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ['anonymous', 'use-credentials'],
      preload: ['none', 'metadata', 'auto'],
      autoplay: ['autoplay'],
      loop: ['loop'],
      controls: ['controls']
    }
  },
  b: S,
  base: { attrs: { href: null, target: Targets } },
  bdi: S,
  bdo: S,
  blockquote: { attrs: { cite: null } },
  body: S,
  br: S,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ['autofocus'],
      disabled: ['autofocus'],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ['novalidate'],
      formtarget: Targets,
      type: ['submit', 'reset', 'button']
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: S,
  center: S,
  cite: S,
  code: S,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ['command', 'checkbox', 'radio'],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ['disabled'],
      checked: ['checked']
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ['disabled'], multiple: ['multiple'] } },
  datalist: { attrs: { data: null } },
  dd: S,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ['open'] } },
  dfn: S,
  div: S,
  dl: S,
  dt: S,
  em: S,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ['disabled'], form: null, name: null } },
  figcaption: S,
  figure: S,
  footer: S,
  form: {
    attrs: {
      action: null,
      name: null,
      'accept-charset': Charsets,
      autocomplete: ['on', 'off'],
      enctype: Encs,
      method: Methods,
      novalidate: ['novalidate'],
      target: Targets
    }
  },
  h1: S,
  h2: S,
  h3: S,
  h4: S,
  h5: S,
  h6: S,
  head: {
    children: ['title', 'base', 'link', 'style', 'meta', 'script', 'noscript', 'command']
  },
  header: S,
  hgroup: S,
  hr: S,
  html: {
    attrs: { manifest: null }
  },
  i: S,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ['allow-top-navigation', 'allow-same-origin', 'allow-forms', 'allow-scripts'],
      seamless: ['seamless']
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ['anonymous', 'use-credentials']
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ['audio/*', 'video/*', 'image/*'],
      autocomplete: ['on', 'off'],
      autofocus: ['autofocus'],
      checked: ['checked'],
      disabled: ['disabled'],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ['novalidate'],
      formtarget: Targets,
      multiple: ['multiple'],
      readonly: ['readonly'],
      required: ['required'],
      type: [
        'hidden',
        'text',
        'search',
        'tel',
        'url',
        'email',
        'password',
        'datetime',
        'date',
        'month',
        'week',
        'time',
        'datetime-local',
        'number',
        'range',
        'color',
        'checkbox',
        'radio',
        'file',
        'submit',
        'image',
        'reset',
        'button'
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: S,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ['autofocus'],
      disabled: ['disabled'],
      keytype: ['RSA']
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: S,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ['all', '16x16', '16x16 32x32', '16x16 32x32 64x64']
    }
  },
  map: { attrs: { name: null } },
  mark: S,
  menu: { attrs: { label: null, type: ['list', 'context', 'toolbar'] } },
  meta: {
    attrs: {
      content: null,
      charset: Charsets,
      name: ['viewport', 'application-name', 'author', 'description', 'generator', 'keywords'],
      'http-equiv': ['content-language', 'content-type', 'default-style', 'refresh']
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: S,
  noscript: S,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ['typemustmatch']
    }
  },
  ol: {
    attrs: { reversed: ['reversed'], start: null, type: ['1', 'a', 'A', 'i', 'I'] },
    children: ['li', 'script', 'template', 'ul', 'ol']
  },
  optgroup: { attrs: { disabled: ['disabled'], label: null } },
  option: { attrs: { disabled: ['disabled'], label: null, selected: ['selected'], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: S,
  param: { attrs: { name: null, value: null } },
  pre: S,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: S,
  rt: S,
  ruby: S,
  samp: S,
  script: {
    attrs: {
      type: ['text/javascript'],
      src: null,
      async: ['async'],
      defer: ['defer'],
      charset: Charsets
    }
  },
  section: S,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ['autofocus'],
      disabled: ['disabled'],
      multiple: ['multiple']
    }
  },
  slot: { attrs: { name: null } },
  small: S,
  source: { attrs: { src: null, type: null, media: null } },
  span: S,
  strong: S,
  style: {
    attrs: {
      type: ['text/css'],
      media: null,
      scoped: null
    }
  },
  sub: S,
  summary: S,
  sup: S,
  table: S,
  tbody: S,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: S,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ['autofocus'],
      disabled: ['disabled'],
      readonly: ['readonly'],
      required: ['required'],
      wrap: ['soft', 'hard']
    }
  },
  tfoot: S,
  th: {
    attrs: {
      colspan: null,
      rowspan: null,
      headers: null,
      scope: ['row', 'col', 'rowgroup', 'colgroup']
    }
  },
  thead: S,
  time: { attrs: { datetime: null } },
  title: S,
  tr: S,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ['subtitles', 'captions', 'descriptions', 'chapters', 'metadata'],
      srclang: null
    }
  },
  ul: { children: ['li', 'script', 'template', 'ul', 'ol'] },
  var: S,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ['anonymous', 'use-credentials'],
      preload: ['auto', 'metadata', 'none'],
      autoplay: ['autoplay'],
      mediagroup: ['movie'],
      muted: ['muted'],
      controls: ['controls']
    }
  },
  wbr: S
}
const GlobalAttrs = {
  accesskey: null,
  class: null,
  contenteditable: Bool,
  contextmenu: null,
  dir: ['ltr', 'rtl', 'auto'],
  draggable: ['true', 'false', 'auto'],
  dropzone: ['copy', 'move', 'link', 'string:', 'file:'],
  hidden: ['hidden'],
  id: null,
  inert: ['inert'],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ['itemscope'],
  itemtype: null,
  lang: [
    'ar',
    'bn',
    'de',
    'en-GB',
    'en-US',
    'es',
    'fr',
    'hi',
    'id',
    'ja',
    'pa',
    'pt',
    'ru',
    'tr',
    'zh'
  ],
  spellcheck: Bool,
  autocorrect: Bool,
  autocapitalize: Bool,
  style: null,
  tabindex: null,
  title: null,
  translate: ['yes', 'no'],
  rel: [
    'stylesheet',
    'alternate',
    'author',
    'bookmark',
    'help',
    'license',
    'next',
    'nofollow',
    'noreferrer',
    'prefetch',
    'prev',
    'search',
    'tag'
  ],
  role: /* @__PURE__ */ 'alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer'.split(
    ' '
  ),
  'aria-activedescendant': null,
  'aria-atomic': Bool,
  'aria-autocomplete': ['inline', 'list', 'both', 'none'],
  'aria-busy': Bool,
  'aria-checked': ['true', 'false', 'mixed', 'undefined'],
  'aria-controls': null,
  'aria-describedby': null,
  'aria-disabled': Bool,
  'aria-dropeffect': null,
  'aria-expanded': ['true', 'false', 'undefined'],
  'aria-flowto': null,
  'aria-grabbed': ['true', 'false', 'undefined'],
  'aria-haspopup': Bool,
  'aria-hidden': Bool,
  'aria-invalid': ['true', 'false', 'grammar', 'spelling'],
  'aria-label': null,
  'aria-labelledby': null,
  'aria-level': null,
  'aria-live': ['off', 'polite', 'assertive'],
  'aria-multiline': Bool,
  'aria-multiselectable': Bool,
  'aria-owns': null,
  'aria-posinset': null,
  'aria-pressed': ['true', 'false', 'mixed', 'undefined'],
  'aria-readonly': Bool,
  'aria-relevant': null,
  'aria-required': Bool,
  'aria-selected': ['true', 'false', 'undefined'],
  'aria-setsize': null,
  'aria-sort': ['ascending', 'descending', 'none', 'other'],
  'aria-valuemax': null,
  'aria-valuemin': null,
  'aria-valuenow': null,
  'aria-valuetext': null
}
const eventAttributes =
  /* @__PURE__ */ 'beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload'
    .split(' ')
    .map((n2) => 'on' + n2)
for (let a of eventAttributes) GlobalAttrs[a] = null
class Schema {
  constructor(extraTags, extraAttrs) {
    this.tags = Object.assign(Object.assign({}, Tags), extraTags)
    this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs)
    this.allTags = Object.keys(this.tags)
    this.globalAttrNames = Object.keys(this.globalAttrs)
  }
}
Schema.default = /* @__PURE__ */ new Schema()
function elementName(doc2, tree, max = doc2.length) {
  if (!tree) return ''
  let tag = tree.firstChild
  let name2 = tag && tag.getChild('TagName')
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max)) : ''
}
function findParentElement(tree, skip = false) {
  for (; tree; tree = tree.parent)
    if (tree.name == 'Element') {
      if (skip) skip = false
      else return tree
    }
  return null
}
function allowedChildren(doc2, tree, schema) {
  let parentInfo = schema.tags[elementName(doc2, findParentElement(tree))]
  return (
    (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags
  )
}
function openTags(doc2, tree) {
  let open = []
  for (
    let parent = findParentElement(tree);
    parent && !parent.type.isTop;
    parent = findParentElement(parent.parent)
  ) {
    let tagName = elementName(doc2, parent)
    if (tagName && parent.lastChild.name == 'CloseTag') break
    if (
      tagName &&
      open.indexOf(tagName) < 0 &&
      (tree.name == 'EndTag' || tree.from >= parent.firstChild.to)
    )
      open.push(tagName)
  }
  return open
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/
function completeTag(state, schema, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? '' : '>'
  let parent = findParentElement(tree, true)
  return {
    from,
    to,
    options: allowedChildren(state.doc, parent, schema)
      .map((tagName) => ({ label: tagName, type: 'type' }))
      .concat(
        openTags(state.doc, tree).map((tag, i) => ({
          label: '/' + tag,
          apply: '/' + tag + end,
          type: 'type',
          boost: 99 - i
        }))
      ),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  }
}
function completeCloseTag(state, tree, from, to) {
  let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? '' : '>'
  return {
    from,
    to,
    options: openTags(state.doc, tree).map((tag, i) => ({
      label: tag,
      apply: tag + end,
      type: 'type',
      boost: 99 - i
    })),
    validFor: identifier
  }
}
function completeStartTag(state, schema, tree, pos) {
  let options = [],
    level = 0
  for (let tagName of allowedChildren(state.doc, tree, schema))
    options.push({ label: '<' + tagName, type: 'type' })
  for (let open of openTags(state.doc, tree))
    options.push({ label: '</' + open + '>', type: 'type', boost: 99 - level++ })
  return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ }
}
function completeAttrName(state, schema, tree, from, to) {
  let elt2 = findParentElement(tree),
    info = elt2 ? schema.tags[elementName(state.doc, elt2)] : null
  let localAttrs = info && info.attrs ? Object.keys(info.attrs) : []
  let names =
    info && info.globalAttrs === false
      ? localAttrs
      : localAttrs.length
        ? localAttrs.concat(schema.globalAttrNames)
        : schema.globalAttrNames
  return {
    from,
    to,
    options: names.map((attrName) => ({ label: attrName, type: 'property' })),
    validFor: identifier
  }
}
function completeAttrValue(state, schema, tree, from, to) {
  var _a2
  let nameNode =
    (_a2 = tree.parent) === null || _a2 === void 0 ? void 0 : _a2.getChild('AttributeName')
  let options = [],
    token = void 0
  if (nameNode) {
    let attrName = state.sliceDoc(nameNode.from, nameNode.to)
    let attrs = schema.globalAttrs[attrName]
    if (!attrs) {
      let elt2 = findParentElement(tree),
        info = elt2 ? schema.tags[elementName(state.doc, elt2)] : null
      attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName]
    }
    if (attrs) {
      let base2 = state.sliceDoc(from, to).toLowerCase(),
        quoteStart = '"',
        quoteEnd = '"'
      if (/^['"]/.test(base2)) {
        token = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/
        quoteStart = ''
        quoteEnd = state.sliceDoc(to, to + 1) == base2[0] ? '' : base2[0]
        base2 = base2.slice(1)
        from++
      } else {
        token = /^[^\s<>='"]*$/
      }
      for (let value of attrs)
        options.push({ label: value, apply: quoteStart + value + quoteEnd, type: 'constant' })
    }
  }
  return { from, to, options, validFor: token }
}
function htmlCompletionFor(schema, context) {
  let { state, pos } = context,
    tree = syntaxTree(state).resolveInner(pos, -1),
    around = tree.resolve(pos)
  for (let scan = pos, before; around == tree && (before = tree.childBefore(scan)); ) {
    let last = before.lastChild
    if (!last || !last.type.isError || last.from < last.to) break
    around = tree = before
    scan = last.from
  }
  if (tree.name == 'TagName') {
    return tree.parent && /CloseTag$/.test(tree.parent.name)
      ? completeCloseTag(state, tree, tree.from, pos)
      : completeTag(state, schema, tree, tree.from, pos)
  } else if (tree.name == 'StartTag') {
    return completeTag(state, schema, tree, pos, pos)
  } else if (tree.name == 'StartCloseTag' || tree.name == 'IncompleteCloseTag') {
    return completeCloseTag(state, tree, pos, pos)
  } else if (
    tree.name == 'OpenTag' ||
    tree.name == 'SelfClosingTag' ||
    tree.name == 'AttributeName'
  ) {
    return completeAttrName(
      state,
      schema,
      tree,
      tree.name == 'AttributeName' ? tree.from : pos,
      pos
    )
  } else if (
    tree.name == 'Is' ||
    tree.name == 'AttributeValue' ||
    tree.name == 'UnquotedAttributeValue'
  ) {
    return completeAttrValue(state, schema, tree, tree.name == 'Is' ? pos : tree.from, pos)
  } else if (
    context.explicit &&
    (around.name == 'Element' || around.name == 'Text' || around.name == 'Document')
  ) {
    return completeStartTag(state, schema, tree, pos)
  } else {
    return null
  }
}
function htmlCompletionSource(context) {
  return htmlCompletionFor(Schema.default, context)
}
function htmlCompletionSourceWith(config2) {
  let { extraTags, extraGlobalAttributes: extraAttrs } = config2
  let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default
  return (context) => htmlCompletionFor(schema, context)
}
const jsonParser = /* @__PURE__ */ javascriptLanguage.parser.configure({ top: 'SingleExpression' })
const defaultNesting = [
  {
    tag: 'script',
    attrs: (attrs) => attrs.type == 'text/typescript' || attrs.lang == 'ts',
    parser: typescriptLanguage.parser
  },
  {
    tag: 'script',
    attrs: (attrs) => attrs.type == 'text/babel' || attrs.type == 'text/jsx',
    parser: jsxLanguage.parser
  },
  {
    tag: 'script',
    attrs: (attrs) => attrs.type == 'text/typescript-jsx',
    parser: tsxLanguage.parser
  },
  {
    tag: 'script',
    attrs(attrs) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(attrs.type)
    },
    parser: jsonParser
  },
  {
    tag: 'script',
    attrs(attrs) {
      return (
        !attrs.type ||
        /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type)
      )
    },
    parser: javascriptLanguage.parser
  },
  {
    tag: 'style',
    attrs(attrs) {
      return (
        (!attrs.lang || attrs.lang == 'css') &&
        (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type))
      )
    },
    parser: cssLanguage.parser
  }
]
const defaultAttrs = /* @__PURE__ */ [
  {
    name: 'style',
    parser: /* @__PURE__ */ cssLanguage.parser.configure({ top: 'Styles' })
  }
].concat(
  /* @__PURE__ */ eventAttributes.map((name2) => ({
    name: name2,
    parser: javascriptLanguage.parser
  }))
)
const htmlPlain = /* @__PURE__ */ LRLanguage.define({
  name: 'html',
  parser: /* @__PURE__ */ parser$5.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Element(context) {
          let after = /^(\s*)(<\/)?/.exec(context.textAfter)
          if (context.node.to <= context.pos + after[0].length) return context.continue()
          return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit)
        },
        'OpenTag CloseTag SelfClosingTag'(context) {
          return context.column(context.node.from) + context.unit
        },
        Document(context) {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
            return context.continue()
          let endElt = null,
            close
          for (let cur2 = context.node; ; ) {
            let last = cur2.lastChild
            if (!last || last.name != 'Element' || last.to != cur2.to) break
            endElt = cur2 = last
          }
          if (
            endElt &&
            !(
              (close = endElt.lastChild) &&
              (close.name == 'CloseTag' || close.name == 'SelfClosingTag')
            )
          )
            return context.lineIndent(endElt.from) + context.unit
          return null
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Element(node) {
          let first = node.firstChild,
            last = node.lastChild
          if (!first || first.name != 'OpenTag') return null
          return { from: first.to, to: last.name == 'CloseTag' ? last.from : node.to }
        }
      }),
      /* @__PURE__ */ bracketMatchingHandle.add({
        'OpenTag CloseTag': (node) => node.getChild('TagName')
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: '<!--', close: '-->' } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: '-._'
  }
})
const htmlLanguage = /* @__PURE__ */ htmlPlain.configure({
  wrap: /* @__PURE__ */ configureNesting(defaultNesting, defaultAttrs)
})
function html(config2 = {}) {
  let dialect = '',
    wrap
  if (config2.matchClosingTags === false) dialect = 'noMatch'
  if (config2.selfClosingTags === true) dialect = (dialect ? dialect + ' ' : '') + 'selfClosing'
  if (
    (config2.nestedLanguages && config2.nestedLanguages.length) ||
    (config2.nestedAttributes && config2.nestedAttributes.length)
  )
    wrap = configureNesting(
      (config2.nestedLanguages || []).concat(defaultNesting),
      (config2.nestedAttributes || []).concat(defaultAttrs)
    )
  let lang = wrap
    ? htmlPlain.configure({ wrap, dialect })
    : dialect
      ? htmlLanguage.configure({ dialect })
      : htmlLanguage
  return new LanguageSupport(lang, [
    htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config2) }),
    config2.autoCloseTags !== false ? autoCloseTags : [],
    javascript().support,
    css$1().support
  ])
}
const selfClosers = /* @__PURE__ */ new Set(
  /* @__PURE__ */ 'area base br col command embed frame hr img input keygen link meta param source track wbr menuitem'.split(
    ' '
  )
)
const autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of(
  (view, from, to, text2, insertTransaction) => {
    if (
      view.composing ||
      view.state.readOnly ||
      from != to ||
      (text2 != '>' && text2 != '/') ||
      !htmlLanguage.isActiveAt(view.state, from, -1)
    )
      return false
    let base2 = insertTransaction(),
      { state } = base2
    let closeTags = state.changeByRange((range) => {
      var _a2, _b, _c
      let didType = state.doc.sliceString(range.from - 1, range.to) == text2
      let { head } = range,
        after = syntaxTree(state).resolveInner(head, -1),
        name2
      if (didType && text2 == '>' && after.name == 'EndTag') {
        let tag = after.parent
        if (
          ((_b = (_a2 = tag.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null ||
          _b === void 0
            ? void 0
            : _b.name) != 'CloseTag' &&
          (name2 = elementName(state.doc, tag.parent, head)) &&
          !selfClosers.has(name2)
        ) {
          let to2 = head + (state.doc.sliceString(head, head + 1) === '>' ? 1 : 0)
          let insert2 = `</${name2}>`
          return { range, changes: { from: head, to: to2, insert: insert2 } }
        }
      } else if (didType && text2 == '/' && after.name == 'IncompleteCloseTag') {
        let tag = after.parent
        if (
          after.from == head - 2 &&
          ((_c = tag.lastChild) === null || _c === void 0 ? void 0 : _c.name) != 'CloseTag' &&
          (name2 = elementName(state.doc, tag, head)) &&
          !selfClosers.has(name2)
        ) {
          let to2 = head + (state.doc.sliceString(head, head + 1) === '>' ? 1 : 0)
          let insert2 = `${name2}>`
          return {
            range: EditorSelection.cursor(head + insert2.length, -1),
            changes: { from: head, to: to2, insert: insert2 }
          }
        }
      }
      return { range }
    })
    if (closeTags.changes.empty) return false
    view.dispatch([
      base2,
      state.update(closeTags, {
        userEvent: 'input.complete',
        scrollIntoView: true
      })
    ])
    return true
  }
)
const index$1 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      autoCloseTags,
      html,
      htmlCompletionSource,
      htmlCompletionSourceWith,
      htmlLanguage,
      htmlPlain
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const data = /* @__PURE__ */ defineLanguageFacet({
  commentTokens: { block: { open: '<!--', close: '-->' } }
})
const headingProp = /* @__PURE__ */ new NodeProp()
const commonmark = /* @__PURE__ */ parser$6.configure({
  props: [
    /* @__PURE__ */ foldNodeProp.add((type) => {
      return !type.is('Block') || type.is('Document') || isHeading(type) != null || isList(type)
        ? void 0
        : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })
    }),
    /* @__PURE__ */ headingProp.add(isHeading),
    /* @__PURE__ */ indentNodeProp.add({
      Document: () => null
    }),
    /* @__PURE__ */ languageDataProp.add({
      Document: data
    })
  ]
})
function isHeading(type) {
  let match2 = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name)
  return match2 ? +match2[1] : void 0
}
function isList(type) {
  return type.name == 'OrderedList' || type.name == 'BulletList'
}
function findSectionEnd(headerNode, level) {
  let last = headerNode
  for (;;) {
    let next = last.nextSibling,
      heading2
    if (!next || ((heading2 = isHeading(next.type)) != null && heading2 <= level)) break
    last = next
  }
  return last.to
}
const headerIndent = /* @__PURE__ */ foldService.of((state, start, end) => {
  for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {
    if (node.from < start) break
    let heading2 = node.type.prop(headingProp)
    if (heading2 == null) continue
    let upto = findSectionEnd(node, heading2)
    if (upto > end) return { from: end, to: upto }
  }
  return null
})
function mkLang(parser2) {
  return new Language(data, parser2, [headerIndent], 'markdown')
}
const commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark)
const extended = /* @__PURE__ */ commonmark.configure([
  GFM,
  Subscript,
  Superscript,
  Emoji,
  {
    props: [
      /* @__PURE__ */ foldNodeProp.add({
        Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })
      })
    ]
  }
])
const markdownLanguage = /* @__PURE__ */ mkLang(extended)
function getCodeParser(languages2, defaultLanguage) {
  return (info) => {
    if (info && languages2) {
      let found = null
      info = /\S*/.exec(info)[0]
      if (typeof languages2 == 'function') found = languages2(info)
      else found = LanguageDescription.matchLanguageName(languages2, info, true)
      if (found instanceof LanguageDescription)
        return found.support
          ? found.support.language.parser
          : ParseContext.getSkippingParser(found.load())
      else if (found) return found.parser
    }
    return defaultLanguage ? defaultLanguage.parser : null
  }
}
class Context {
  constructor(node, from, to, spaceBefore, spaceAfter, type, item) {
    this.node = node
    this.from = from
    this.to = to
    this.spaceBefore = spaceBefore
    this.spaceAfter = spaceAfter
    this.type = type
    this.item = item
  }
  blank(maxWidth, trailing = true) {
    let result = this.spaceBefore + (this.node.name == 'Blockquote' ? '>' : '')
    if (maxWidth != null) {
      while (result.length < maxWidth) result += ' '
      return result
    } else {
      for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
        result += ' '
      return result + (trailing ? this.spaceAfter : '')
    }
  }
  marker(doc2, add3) {
    let number2 =
      this.node.name == 'OrderedList' ? String(+itemNumber(this.item, doc2)[2] + add3) : ''
    return this.spaceBefore + number2 + this.type + this.spaceAfter
  }
}
function getContext(node, doc2) {
  let nodes = [],
    context = []
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    if (cur2.name == 'FencedCode') return context
    if (cur2.name == 'ListItem' || cur2.name == 'Blockquote') nodes.push(cur2)
  }
  for (let i = nodes.length - 1; i >= 0; i--) {
    let node2 = nodes[i],
      match2
    let line = doc2.lineAt(node2.from),
      startPos = node2.from - line.from
    if (node2.name == 'Blockquote' && (match2 = /^ *>( ?)/.exec(line.text.slice(startPos)))) {
      context.push(
        new Context(node2, startPos, startPos + match2[0].length, '', match2[1], '>', null)
      )
    } else if (
      node2.name == 'ListItem' &&
      node2.parent.name == 'OrderedList' &&
      (match2 = /^( *)\d+([.)])( *)/.exec(line.text.slice(startPos)))
    ) {
      let after = match2[3],
        len = match2[0].length
      if (after.length >= 4) {
        after = after.slice(0, after.length - 4)
        len -= 4
      }
      context.push(
        new Context(node2.parent, startPos, startPos + len, match2[1], after, match2[2], node2)
      )
    } else if (
      node2.name == 'ListItem' &&
      node2.parent.name == 'BulletList' &&
      (match2 = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(line.text.slice(startPos)))
    ) {
      let after = match2[4],
        len = match2[0].length
      if (after.length > 4) {
        after = after.slice(0, after.length - 4)
        len -= 4
      }
      let type = match2[2]
      if (match2[3]) type += match2[3].replace(/[xX]/, ' ')
      context.push(
        new Context(node2.parent, startPos, startPos + len, match2[1], after, type, node2)
      )
    }
  }
  return context
}
function itemNumber(item, doc2) {
  return /^(\s*)(\d+)(?=[.)])/.exec(doc2.sliceString(item.from, item.from + 10))
}
function renumberList(after, doc2, changes, offset = 0) {
  for (let prev = -1, node = after; ; ) {
    if (node.name == 'ListItem') {
      let m = itemNumber(node, doc2)
      let number2 = +m[2]
      if (prev >= 0) {
        if (number2 != prev + 1) return
        changes.push({
          from: node.from + m[1].length,
          to: node.from + m[0].length,
          insert: String(prev + 2 + offset)
        })
      }
      prev = number2
    }
    let next = node.nextSibling
    if (!next) break
    node = next
  }
}
function normalizeIndent(content2, state) {
  let blank = /^[ \t]*/.exec(content2)[0].length
  if (!blank || state.facet(indentUnit) != '	') return content2
  let col = countColumn(content2, 4, blank)
  let space2 = ''
  for (let i = col; i > 0; ) {
    if (i >= 4) {
      space2 += '	'
      i -= 4
    } else {
      space2 += ' '
      i--
    }
  }
  return space2 + content2.slice(blank)
}
const insertNewlineContinueMarkup = ({ state, dispatch }) => {
  let tree = syntaxTree(state),
    { doc: doc2 } = state
  let dont = null,
    changes = state.changeByRange((range) => {
      if (
        !range.empty ||
        (!markdownLanguage.isActiveAt(state, range.from, -1) &&
          !markdownLanguage.isActiveAt(state, range.from, 1))
      )
        return (dont = { range })
      let pos = range.from,
        line = doc2.lineAt(pos)
      let context = getContext(tree.resolveInner(pos, -1), doc2)
      while (context.length && context[context.length - 1].from > pos - line.from) context.pop()
      if (!context.length) return (dont = { range })
      let inner = context[context.length - 1]
      if (inner.to - inner.spaceAfter.length > pos - line.from) return (dont = { range })
      let emptyLine =
        pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line.text.slice(inner.to))
      if (inner.item && emptyLine) {
        let first = inner.node.firstChild,
          second = inner.node.getChild('ListItem', 'ListItem')
        if (
          first.to >= pos ||
          (second && second.to < pos) ||
          (line.from > 0 && !/[^\s>]/.test(doc2.lineAt(line.from - 1).text))
        ) {
          let next = context.length > 1 ? context[context.length - 2] : null
          let delTo,
            insert3 = ''
          if (next && next.item) {
            delTo = line.from + next.from
            insert3 = next.marker(doc2, 1)
          } else {
            delTo = line.from + (next ? next.to : 0)
          }
          let changes3 = [{ from: delTo, to: pos, insert: insert3 }]
          if (inner.node.name == 'OrderedList') renumberList(inner.item, doc2, changes3, -2)
          if (next && next.node.name == 'OrderedList') renumberList(next.item, doc2, changes3)
          return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 }
        } else {
          let insert3 = blankLine(context, state, line)
          return {
            range: EditorSelection.cursor(pos + insert3.length + 1),
            changes: { from: line.from, insert: insert3 + state.lineBreak }
          }
        }
      }
      if (inner.node.name == 'Blockquote' && emptyLine && line.from) {
        let prevLine = doc2.lineAt(line.from - 1),
          quoted = />\s*$/.exec(prevLine.text)
        if (quoted && quoted.index == inner.from) {
          let changes3 = state.changes([
            { from: prevLine.from + quoted.index, to: prevLine.to },
            { from: line.from + inner.from, to: line.to }
          ])
          return { range: range.map(changes3), changes: changes3 }
        }
      }
      let changes2 = []
      if (inner.node.name == 'OrderedList') renumberList(inner.item, doc2, changes2)
      let continued = inner.item && inner.item.from < line.from
      let insert2 = ''
      if (!continued || /^[\s\d.)\-+*>]*/.exec(line.text)[0].length >= inner.to) {
        for (let i = 0, e2 = context.length - 1; i <= e2; i++) {
          insert2 +=
            i == e2 && !continued
              ? context[i].marker(doc2, 1)
              : context[i].blank(
                  i < e2 ? countColumn(line.text, 4, context[i + 1].from) - insert2.length : null
                )
        }
      }
      let from = pos
      while (from > line.from && /\s/.test(line.text.charAt(from - line.from - 1))) from--
      insert2 = normalizeIndent(insert2, state)
      if (nonTightList(inner.node, state.doc))
        insert2 = blankLine(context, state, line) + state.lineBreak + insert2
      changes2.push({ from, to: pos, insert: state.lineBreak + insert2 })
      return { range: EditorSelection.cursor(from + insert2.length + 1), changes: changes2 }
    })
  if (dont) return false
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: 'input' }))
  return true
}
function isMark(node) {
  return node.name == 'QuoteMark' || node.name == 'ListMark'
}
function nonTightList(node, doc2) {
  if (node.name != 'OrderedList' && node.name != 'BulletList') return false
  let first = node.firstChild,
    second = node.getChild('ListItem', 'ListItem')
  if (!second) return false
  let line1 = doc2.lineAt(first.to),
    line2 = doc2.lineAt(second.from)
  let empty2 = /^[\s>]*$/.test(line1.text)
  return line1.number + (empty2 ? 0 : 1) < line2.number
}
function blankLine(context, state, line) {
  let insert2 = ''
  for (let i = 0, e2 = context.length - 2; i <= e2; i++) {
    insert2 += context[i].blank(
      i < e2 ? countColumn(line.text, 4, context[i + 1].from) - insert2.length : null,
      i < e2
    )
  }
  return normalizeIndent(insert2, state)
}
function contextNodeForDelete(tree, pos) {
  let node = tree.resolveInner(pos, -1),
    scan = pos
  if (isMark(node)) {
    scan = node.from
    node = node.parent
  }
  for (let prev; (prev = node.childBefore(scan)); ) {
    if (isMark(prev)) {
      scan = prev.from
    } else if (prev.name == 'OrderedList' || prev.name == 'BulletList') {
      node = prev.lastChild
      scan = node.to
    } else {
      break
    }
  }
  return node
}
const deleteMarkupBackward = ({ state, dispatch }) => {
  let tree = syntaxTree(state)
  let dont = null,
    changes = state.changeByRange((range) => {
      let pos = range.from,
        { doc: doc2 } = state
      if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {
        let line = doc2.lineAt(pos)
        let context = getContext(contextNodeForDelete(tree, pos), doc2)
        if (context.length) {
          let inner = context[context.length - 1]
          let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0)
          if (pos - line.from > spaceEnd && !/\S/.test(line.text.slice(spaceEnd, pos - line.from)))
            return {
              range: EditorSelection.cursor(line.from + spaceEnd),
              changes: { from: line.from + spaceEnd, to: pos }
            }
          if (
            pos - line.from == spaceEnd && // Only apply this if we're on the line that has the
            // construct's syntax, or there's only indentation in the
            // target range
            (!inner.item ||
              line.from <= inner.item.from ||
              !/\S/.test(line.text.slice(0, inner.to)))
          ) {
            let start = line.from + inner.from
            if (
              inner.item &&
              inner.node.from < inner.item.from &&
              /\S/.test(line.text.slice(inner.from, inner.to))
            ) {
              let insert2 = inner.blank(
                countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from)
              )
              if (start == line.from) insert2 = normalizeIndent(insert2, state)
              return {
                range: EditorSelection.cursor(start + insert2.length),
                changes: { from: start, to: line.from + inner.to, insert: insert2 }
              }
            }
            if (start < pos)
              return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } }
          }
        }
      }
      return (dont = { range })
    })
  if (dont) return false
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: 'delete' }))
  return true
}
const markdownKeymap = [
  { key: 'Enter', run: insertNewlineContinueMarkup },
  { key: 'Backspace', run: deleteMarkupBackward }
]
const htmlNoMatch = /* @__PURE__ */ html({ matchClosingTags: false })
function markdown(config2 = {}) {
  let {
    codeLanguages,
    defaultCodeLanguage,
    addKeymap = true,
    base: { parser: parser2 } = commonmarkLanguage,
    completeHTMLTags = true,
    htmlTagLanguage = htmlNoMatch
  } = config2
  if (!(parser2 instanceof MarkdownParser))
    throw new RangeError('Base parser provided to `markdown` should be a Markdown parser')
  let extensions = config2.extensions ? [config2.extensions] : []
  let support = [htmlTagLanguage.support],
    defaultCode
  if (defaultCodeLanguage instanceof LanguageSupport) {
    support.push(defaultCodeLanguage.support)
    defaultCode = defaultCodeLanguage.language
  } else if (defaultCodeLanguage) {
    defaultCode = defaultCodeLanguage
  }
  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : void 0
  extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }))
  if (addKeymap) support.push(Prec.high(keymap.of(markdownKeymap)))
  let lang = mkLang(parser2.configure(extensions))
  if (completeHTMLTags) support.push(lang.data.of({ autocomplete: htmlTagCompletion }))
  return new LanguageSupport(lang, support)
}
function htmlTagCompletion(context) {
  let { state, pos } = context,
    m = /<[:\-\.\w\u00b7-\uffff]*$/.exec(state.sliceDoc(pos - 25, pos))
  if (!m) return null
  let tree = syntaxTree(state).resolveInner(pos, -1)
  while (tree && !tree.type.isTop) {
    if (
      tree.name == 'CodeBlock' ||
      tree.name == 'FencedCode' ||
      tree.name == 'ProcessingInstructionBlock' ||
      tree.name == 'CommentBlock' ||
      tree.name == 'Link' ||
      tree.name == 'Image'
    )
      return null
    tree = tree.parent
  }
  return {
    from: pos - m[0].length,
    to: pos,
    options: htmlTagCompletions(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  }
}
let _tagCompletions = null
function htmlTagCompletions() {
  if (_tagCompletions) return _tagCompletions
  let result = htmlCompletionSource(
    new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true)
  )
  return (_tagCompletions = result ? result.options : [])
}
const index = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      commonmarkLanguage,
      deleteMarkupBackward,
      insertNewlineContinueMarkup,
      markdown,
      markdownKeymap,
      markdownLanguage
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
const props$9 = {
  title: {
    type: String,
    default: ''
  },
  /**
   * 展示在工具栏的内容，通常是个图标
   *
   * @deprecated 使用默认插槽代替
   */
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  showToolbarName: {
    type: Boolean,
    default: void 0
  }
  /**
   * ==结束
   */
}
const NormalToolbar = /* @__PURE__ */ defineComponent({
  name: 'NormalToolbar',
  props: props$9,
  emits: ['onClick'],
  setup(props2, ctx) {
    return () => {
      const Trigger = getSlot(
        {
          props: props2,
          ctx
        },
        'trigger'
      )
      const Default = getSlot({
        props: props2,
        ctx
      })
      return createVNode(
        'div',
        {
          class: [`${prefix}-toolbar-item`, props2.disabled && `${prefix}-disabled`],
          title: props2.title,
          onClick: (e2) => {
            var _a2
            if (props2.disabled) return
            ;(_a2 = props2.onClick) == null ? void 0 : _a2.call(props2, e2)
            ctx.emit('onClick', e2)
          }
        },
        [Default || Trigger]
      )
    }
  }
})
NormalToolbar.install = (app) => {
  app.component(NormalToolbar.name, NormalToolbar)
  return app
}
function _isSlot(s) {
  return (
    typeof s === 'function' ||
    (Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s))
  )
}
const props$8 = {
  title: {
    type: String,
    default: ''
  },
  modalTitle: {
    type: [String, Object],
    default: ''
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  width: {
    type: String,
    default: 'auto'
  },
  height: {
    type: String,
    default: 'auto'
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  },
  /**
   * 显示全屏按钮
   */
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function,
    default: void 0
  },
  class: {
    type: String,
    default: void 0
  },
  style: {
    type: [Object, String],
    default: void 0
  },
  showMask: {
    type: Boolean,
    default: true
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  showToolbarName: {
    type: Boolean,
    default: void 0
  }
  /**
   * ==结束
   */
}
const ModalToolbar = /* @__PURE__ */ defineComponent({
  name: 'ModalToolbar',
  props: props$8,
  emits: ['onClick', 'onClose', 'onAdjust'],
  setup(props2, ctx) {
    return () => {
      const Trigger = getSlot(
        {
          props: props2,
          ctx
        },
        'trigger'
      )
      const ModalTitle = getSlot(
        {
          props: props2,
          ctx
        },
        'modalTitle'
      )
      const Default = getSlot({
        props: props2,
        ctx
      })
      return createVNode(Fragment, null, [
        createVNode(
          'div',
          {
            class: [`${prefix}-toolbar-item`, props2.disabled && `${prefix}-disabled`],
            title: props2.title,
            onClick: () => {
              var _a2
              if (props2.disabled) return
              ;(_a2 = props2.onClick) == null ? void 0 : _a2.call(props2)
              ctx.emit('onClick')
            }
          },
          [Trigger]
        ),
        createVNode(
          MdModal,
          {
            style: props2.style,
            class: props2.class,
            width: props2.width,
            height: props2.height,
            title: ModalTitle,
            visible: props2.visible,
            showMask: props2.showMask,
            onClose: () => {
              var _a2
              ;(_a2 = props2.onClose) == null ? void 0 : _a2.call(props2)
              ctx.emit('onClose')
            },
            showAdjust: props2.showAdjust,
            isFullscreen: props2.isFullscreen,
            onAdjust: (v) => {
              var _a2
              ;(_a2 = props2.onAdjust) == null ? void 0 : _a2.call(props2, v)
              ctx.emit('onAdjust', v)
            }
          },
          _isSlot(Default)
            ? Default
            : {
                default: () => [Default]
              }
        )
      ])
    }
  }
})
ModalToolbar.install = (app) => {
  app.component(ModalToolbar.name, ModalToolbar)
  return app
}
var __defProp = Object.defineProperty
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value })
    : (obj[key] = value)
var __publicField = (obj, key, value) =>
  __defNormalProp(obj, typeof key !== 'symbol' ? key + '' : key, value)
const Divider = /* @__PURE__ */ defineComponent({
  name: `${prefix}-divider`,
  setup() {
    return () =>
      createVNode(
        'div',
        {
          class: `${prefix}-divider`
        },
        null
      )
  }
})
const toolbarProps = {
  noPrettier: {
    type: Boolean
  },
  // 工具栏选择显示
  toolbars: {
    type: Array,
    default: () => []
  },
  // 工具栏选择不显示
  toolbarsExclude: {
    type: Array,
    default: () => []
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  screenfull: {
    type: Object,
    default: null
  },
  screenfullJs: {
    type: String,
    default: ''
  },
  updateSetting: {
    type: Function,
    default: () => {}
  },
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  defToolbars: {
    type: Object
  },
  noUploadImg: {
    type: Boolean
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean
  },
  catalogVisible: {
    type: Boolean
  },
  codeTheme: {
    type: String
  },
  insertLinkDirect: {
    type: Boolean
  }
}
const useSreenfull = (props2) => {
  const editorId = inject('editorId')
  const { editorExtensions, editorExtensionsAttrs } = globalConfig
  let screenfull = editorExtensions.screenfull.instance
  const screenfullMe = ref(false)
  const fullscreenHandler = (status) => {
    if (!screenfull) {
      bus.emit(editorId, ERROR_CATCHER, {
        name: 'fullscreen',
        message: 'fullscreen is undefined'
      })
      return
    }
    if (screenfull.isEnabled) {
      screenfullMe.value = true
      const targetStatus = status === void 0 ? !screenfull.isFullscreen : status
      if (targetStatus) {
        screenfull.request()
      } else {
        screenfull.exit()
      }
    } else {
      console.error('browser does not support screenfull!')
    }
  }
  const onScreenfullEvent = () => {
    if (screenfull && screenfull.isEnabled) {
      screenfull.on('change', () => {
        if (screenfullMe.value || props2.setting.fullscreen) {
          screenfullMe.value = false
          props2.updateSetting('fullscreen')
        }
      })
    }
  }
  const screenfullLoad = () => {
    screenfull = window.screenfull
    onScreenfullEvent()
  }
  onMounted(() => {
    var _a2
    onScreenfullEvent()
    if (!screenfull) {
      appendHandler(
        'script',
        {
          ...((_a2 = editorExtensionsAttrs.screenfull) == null ? void 0 : _a2.js),
          src: editorExtensions.screenfull.js,
          id: CDN_IDS.screenfull,
          onload: screenfullLoad
        },
        'screenfull'
      )
    }
  })
  onMounted(() => {
    bus.on(editorId, {
      name: CHANGE_FULL_SCREEN,
      callback: fullscreenHandler
    })
  })
  return { fullscreenHandler }
}
const props$6 = {
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  onSelected: {
    type: Function,
    default: () => {}
  }
}
const TableShape = /* @__PURE__ */ defineComponent({
  name: 'TableShape',
  props: props$6,
  setup(props2) {
    const hoverPosition = reactive({
      x: -1,
      y: -1
    })
    const tableShapeStr = computed(() => {
      return JSON.stringify(props2.tableShape)
    })
    const initShape = () => {
      const shape = [...JSON.parse(tableShapeStr.value)]
      if (!shape[2] || shape[2] < shape[0]) {
        shape[2] = shape[0]
      }
      if (!shape[3] || shape[3] < shape[3]) {
        shape[3] = shape[1]
      }
      return shape
    }
    const tableShape = ref(initShape())
    watch([tableShapeStr], () => {
      tableShape.value = initShape()
    })
    return () =>
      createVNode(
        'div',
        {
          class: `${prefix}-table-shape`,
          onMouseleave: () => {
            tableShape.value = initShape()
            hoverPosition.x = -1
            hoverPosition.y = -1
          }
        },
        [
          new Array(tableShape.value[1]).fill('').map((_2, rowIndex) =>
            createVNode(
              'div',
              {
                class: `${prefix}-table-shape-row`,
                key: `table-shape-row-${rowIndex}`
              },
              [
                new Array(tableShape.value[0]).fill('').map((_22, colIndex) =>
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-table-shape-col`,
                      key: `table-shape-col-${colIndex}`,
                      onMouseenter: () => {
                        hoverPosition.x = rowIndex
                        hoverPosition.y = colIndex
                        if (
                          colIndex + 1 === tableShape.value[0] &&
                          colIndex + 1 < tableShape.value[2]
                        ) {
                          tableShape.value[0]++
                        } else if (
                          colIndex + 2 < tableShape.value[0] &&
                          tableShape.value[0] > props2.tableShape[0]
                        ) {
                          tableShape.value[0]--
                        }
                        if (
                          rowIndex + 1 === tableShape.value[1] &&
                          rowIndex + 1 < tableShape.value[3]
                        ) {
                          tableShape.value[1]++
                        } else if (
                          rowIndex + 2 < tableShape.value[1] &&
                          tableShape.value[1] > props2.tableShape[1]
                        ) {
                          tableShape.value[1]--
                        }
                      },
                      onClick: () => {
                        props2.onSelected(hoverPosition)
                      }
                    },
                    [
                      createVNode(
                        'div',
                        {
                          class: [
                            `${prefix}-table-shape-col-default`,
                            rowIndex <= hoverPosition.x &&
                              colIndex <= hoverPosition.y &&
                              `${prefix}-table-shape-col-include`
                          ]
                        },
                        null
                      )
                    ]
                  )
                )
              ]
            )
          )
        ]
      )
  }
})
const props$5 = {
  type: {
    type: String,
    default: 'link'
  },
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {}
  },
  onOk: {
    type: Function,
    default: () => {}
  }
}
const LinkModal = /* @__PURE__ */ defineComponent({
  name: `${prefix}-modal-link`,
  props: props$5,
  setup(props2) {
    const ult = inject('usedLanguageText')
    const editorId = inject('editorId')
    const title = computed(() => {
      var _a2, _b
      switch (props2.type) {
        case 'link': {
          return (_a2 = ult.value.linkModalTips) == null ? void 0 : _a2.linkTitle
        }
        case 'image': {
          return (_b = ult.value.linkModalTips) == null ? void 0 : _b.imageTitle
        }
        default: {
          return ''
        }
      }
    })
    const linkData = reactive({
      desc: '',
      url: ''
    })
    watch(
      () => props2.visible,
      (nVal) => {
        if (!nVal) {
          setTimeout(() => {
            linkData.desc = ''
            linkData.url = ''
          }, 200)
        }
      }
    )
    return () =>
      createVNode(
        MdModal,
        {
          title: title.value,
          visible: props2.visible,
          onClose: props2.onCancel
        },
        {
          default: () => {
            var _a2, _b, _c, _d, _e
            return [
              createVNode(
                'div',
                {
                  class: `${prefix}-form-item`
                },
                [
                  createVNode(
                    'label',
                    {
                      class: `${prefix}-label`,
                      for: `link-desc-${editorId}`
                    },
                    [(_a2 = ult.value.linkModalTips) == null ? void 0 : _a2.descLabel]
                  ),
                  createVNode(
                    'input',
                    {
                      placeholder:
                        (_b = ult.value.linkModalTips) == null ? void 0 : _b.descLabelPlaceHolder,
                      class: `${prefix}-input`,
                      id: `link-desc-${editorId}`,
                      type: 'text',
                      value: linkData.desc,
                      onChange: (e2) => {
                        linkData.desc = e2.target.value
                      },
                      autocomplete: 'off'
                    },
                    null
                  )
                ]
              ),
              createVNode(
                'div',
                {
                  class: `${prefix}-form-item`
                },
                [
                  createVNode(
                    'label',
                    {
                      class: `${prefix}-label`,
                      for: `link-url-${editorId}`
                    },
                    [(_c = ult.value.linkModalTips) == null ? void 0 : _c.urlLabel]
                  ),
                  createVNode(
                    'input',
                    {
                      placeholder:
                        (_d = ult.value.linkModalTips) == null ? void 0 : _d.urlLabelPlaceHolder,
                      class: `${prefix}-input`,
                      id: `link-url-${editorId}`,
                      type: 'text',
                      value: linkData.url,
                      onChange: (e2) => {
                        linkData.url = e2.target.value
                      },
                      autocomplete: 'off'
                    },
                    null
                  )
                ]
              ),
              createVNode(
                'div',
                {
                  class: `${prefix}-form-item`
                },
                [
                  createVNode(
                    'button',
                    {
                      class: [`${prefix}-btn`, `${prefix}-btn-row`],
                      type: 'button',
                      onClick: () => {
                        props2.onOk(linkData)
                        linkData.desc = ''
                        linkData.url = ''
                      }
                    },
                    [(_e = ult.value.linkModalTips) == null ? void 0 : _e.buttonOK]
                  )
                ]
              )
            ]
          }
        }
      )
  }
})
const props$4 = {
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {}
  },
  onOk: {
    type: Function,
    default: () => {}
  }
}
const ClipModal = /* @__PURE__ */ defineComponent({
  name: `${prefix}-modal-clip`,
  props: props$4,
  setup(props2) {
    const ult = inject('usedLanguageText')
    const editorId = inject('editorId')
    const rootRef = inject('rootRef')
    let Cropper = globalConfig.editorExtensions.cropper.instance
    const uploadRef = ref()
    const uploadImgRef = ref()
    const previewTargetRef = ref()
    const data2 = reactive({
      cropperInited: false,
      imgSelected: false,
      imgSrc: '',
      // 是否全屏
      isFullscreen: false
    })
    let cropper = null
    watch(
      () => props2.visible,
      () => {
        if (props2.visible && !data2.cropperInited) {
          Cropper = Cropper || window.Cropper
          uploadRef.value.onchange = () => {
            if (!Cropper) {
              bus.emit(editorId, ERROR_CATCHER, {
                name: 'Cropper',
                message: 'Cropper is undefined'
              })
              return
            }
            const fileList = uploadRef.value.files || []
            data2.imgSelected = true
            if ((fileList == null ? void 0 : fileList.length) > 0) {
              const fileReader = new FileReader()
              fileReader.onload = (e2) => {
                data2.imgSrc = e2.target.result
              }
              fileReader.readAsDataURL(fileList[0])
            }
          }
        }
      }
    )
    watch(
      () => [data2.imgSelected],
      () => {
        previewTargetRef.value.style = ''
      }
    )
    watch([toRef(() => data2.isFullscreen), toRef(() => data2.imgSrc)], () => {
      if (data2.imgSrc) {
        nextTick(() => {
          cropper == null ? void 0 : cropper.destroy()
          previewTargetRef.value.style = ''
          if (uploadImgRef.value) {
            cropper = new Cropper(uploadImgRef.value, {
              viewMode: 2,
              preview: rootRef.value.getRootNode().querySelector(`.${prefix}-clip-preview-target`)
              // aspectRatio: 16 / 9,
            })
          }
        })
      }
    })
    const reset = () => {
      cropper.clear()
      cropper.destroy()
      cropper = null
      uploadRef.value.value = ''
      data2.imgSelected = false
    }
    return () => {
      var _a2
      return createVNode(
        MdModal,
        {
          class: `${prefix}-modal-clip`,
          title: (_a2 = ult.value.clipModalTips) == null ? void 0 : _a2.title,
          visible: props2.visible,
          onClose: props2.onCancel,
          showAdjust: true,
          isFullscreen: data2.isFullscreen,
          onAdjust: (val) => {
            data2.isFullscreen = val
          },
          width: '668px',
          height: '421px'
        },
        {
          default: () => {
            var _a22, _b, _c
            return [
              createVNode(
                'div',
                {
                  class: `${prefix}-form-item ${prefix}-clip`
                },
                [
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-clip-main`
                    },
                    [
                      data2.imgSelected
                        ? createVNode(
                            'div',
                            {
                              class: `${prefix}-clip-cropper`
                            },
                            [
                              createVNode(
                                'img',
                                {
                                  src: data2.imgSrc,
                                  ref: uploadImgRef,
                                  style: {
                                    display: 'none'
                                  },
                                  alt: ''
                                },
                                null
                              ),
                              createVNode(
                                'div',
                                {
                                  class: `${prefix}-clip-delete`,
                                  onClick: reset
                                },
                                [
                                  createVNode(
                                    Icon,
                                    {
                                      name: 'delete'
                                    },
                                    null
                                  )
                                ]
                              )
                            ]
                          )
                        : createVNode(
                            'div',
                            {
                              class: `${prefix}-clip-upload`,
                              onClick: () => {
                                uploadRef.value.click()
                              },
                              role: 'button',
                              tabindex: '0',
                              'aria-label':
                                (_a22 = ult.value.imgTitleItem) == null ? void 0 : _a22.upload
                            },
                            [
                              createVNode(
                                Icon,
                                {
                                  name: 'upload'
                                },
                                null
                              )
                            ]
                          )
                    ]
                  ),
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-clip-preview`
                    },
                    [
                      createVNode(
                        'div',
                        {
                          class: `${prefix}-clip-preview-target`,
                          ref: previewTargetRef
                        },
                        null
                      )
                    ]
                  )
                ]
              ),
              createVNode(
                'div',
                {
                  class: `${prefix}-form-item`
                },
                [
                  createVNode(
                    'button',
                    {
                      class: `${prefix}-btn`,
                      type: 'button',
                      onClick: () => {
                        if (cropper) {
                          const cvs = cropper.getCroppedCanvas()
                          bus.emit(
                            editorId,
                            UPLOAD_IMAGE,
                            [base642File(cvs.toDataURL('image/png'))],
                            props2.onOk
                          )
                          reset()
                        }
                      }
                    },
                    [
                      ((_b = ult.value.clipModalTips) == null ? void 0 : _b.buttonUpload) ||
                        ((_c = ult.value.linkModalTips) == null ? void 0 : _c.buttonOK)
                    ]
                  )
                ]
              ),
              createVNode(
                'input',
                {
                  ref: uploadRef,
                  accept: 'image/*',
                  type: 'file',
                  multiple: false,
                  style: {
                    display: 'none'
                  },
                  'aria-hidden': 'true'
                },
                null
              )
            ]
          }
        }
      )
    }
  }
})
const props$3 = {
  type: {
    type: String,
    default: 'link'
  },
  linkVisible: {
    type: Boolean,
    default: false
  },
  clipVisible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {}
  },
  onOk: {
    type: Function,
    default: () => {}
  }
}
const Modals = /* @__PURE__ */ defineComponent({
  name: `${prefix}-modals`,
  props: props$3,
  setup(props2) {
    return () =>
      createVNode(Fragment, null, [
        createVNode(
          LinkModal,
          {
            type: props2.type,
            visible: props2.linkVisible,
            onOk: props2.onOk,
            onCancel: props2.onCancel
          },
          null
        ),
        createVNode(
          ClipModal,
          {
            visible: props2.clipVisible,
            onOk: props2.onOk,
            onCancel: props2.onCancel
          },
          null
        )
      ])
  }
})
const ToolBar = /* @__PURE__ */ defineComponent({
  name: 'MDEditorToolbar',
  props: toolbarProps,
  setup(props2) {
    const editorId = inject('editorId')
    const ult = inject('usedLanguageText')
    const theme2 = inject('theme')
    const previewTheme = inject('previewTheme')
    const language2 = inject('language')
    const disabled = inject('disabled')
    const { fullscreenHandler } = useSreenfull(props2)
    const wrapperId = `${editorId}-toolbar-wrapper`
    const wrapperRef = ref()
    const visible = reactive({
      title: false,
      catalog: false,
      // 图片上传下拉
      image: false,
      // 表格预选
      table: false,
      // mermaid
      mermaid: false,
      katex: false
    })
    const emitHandler = (direct, params) => {
      if (disabled == null ? void 0 : disabled.value) {
        return false
      }
      bus.emit(editorId, REPLACE, direct, params)
    }
    const modalData = reactive({
      type: 'link',
      linkVisible: false,
      clipVisible: false
    })
    const toolbarLeftRef = ref()
    onMounted(() => {
      bus.on(editorId, {
        name: OPEN_MODALS,
        callback(type) {
          modalData.type = type
          modalData.linkVisible = true
        }
      })
    })
    const splitedbar = computed(() => {
      const excluedBars = props2.toolbars.filter(
        (barItem) => !props2.toolbarsExclude.includes(barItem)
      )
      const moduleSplitIndex = excluedBars.indexOf('=')
      const barLeft =
        moduleSplitIndex === -1 ? excluedBars : excluedBars.slice(0, moduleSplitIndex + 1)
      const barRight =
        moduleSplitIndex === -1 ? [] : excluedBars.slice(moduleSplitIndex, Number.MAX_SAFE_INTEGER)
      return [barLeft, barRight]
    })
    const uploadRef = ref()
    const uploadHandler = () => {
      bus.emit(editorId, UPLOAD_IMAGE, Array.from(uploadRef.value.files || []))
      uploadRef.value.value = ''
    }
    onMounted(() => {
      uploadRef.value.addEventListener('change', uploadHandler)
    })
    const barRender = (barItem) => {
      var _a2,
        _b,
        _c,
        _d,
        _e,
        _f,
        _g,
        _h,
        _i,
        _j,
        _k,
        _l,
        _m,
        _n,
        _o,
        _p,
        _q,
        _r,
        _s,
        _t,
        _u,
        _v,
        _w,
        _x,
        _y,
        _z,
        _A,
        _B,
        _C,
        _D,
        _E,
        _F,
        _G,
        _H,
        _I,
        _J,
        _K,
        _L,
        _M,
        _N,
        _O,
        _P,
        _Q,
        _R,
        _S,
        _T,
        _U,
        _V,
        _W,
        _X,
        _Y,
        _Z,
        __,
        _$,
        _aa,
        _ba,
        _ca,
        _da,
        _ea,
        _fa,
        _ga,
        _ha,
        _ia,
        _ja,
        _ka,
        _la,
        _ma,
        _na,
        _oa,
        _pa,
        _qa,
        _ra,
        _sa,
        _ta,
        _ua,
        _va,
        _wa,
        _xa,
        _ya,
        _za,
        _Aa
      if (allToolbar.includes(barItem)) {
        switch (barItem) {
          case '-': {
            return createVNode(Divider, null, null)
          }
          case 'bold': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_a2 = ult.value.toolbarTips) == null ? void 0 : _a2.bold,
                onClick: () => {
                  emitHandler('bold')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'bold'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_b = ult.value.toolbarTips) == null ? void 0 : _b.bold]
                  )
              ]
            )
          }
          case 'underline': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_c = ult.value.toolbarTips) == null ? void 0 : _c.underline,
                onClick: () => {
                  emitHandler('underline')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'underline'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_d = ult.value.toolbarTips) == null ? void 0 : _d.underline]
                  )
              ]
            )
          }
          case 'italic': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_e = ult.value.toolbarTips) == null ? void 0 : _e.italic,
                onClick: () => {
                  emitHandler('italic')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'italic'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_f = ult.value.toolbarTips) == null ? void 0 : _f.italic]
                  )
              ]
            )
          }
          case 'strikeThrough': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_g = ult.value.toolbarTips) == null ? void 0 : _g.strikeThrough,
                onClick: () => {
                  emitHandler('strikeThrough')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'strike-through'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_h = ult.value.toolbarTips) == null ? void 0 : _h.strikeThrough]
                  )
              ]
            )
          }
          case 'title': {
            return createVNode(
              Dropdown,
              {
                relative: `#${wrapperId}`,
                visible: visible.title,
                onChange: (v) => {
                  visible.title = v
                },
                disabled: disabled == null ? void 0 : disabled.value,
                overlay: createVNode(
                  'ul',
                  {
                    class: `${prefix}-menu`,
                    onClick: () => {
                      visible.title = false
                    },
                    role: 'menu'
                  },
                  [
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h1')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_i = ult.value.titleItem) == null ? void 0 : _i.h1]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h2')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_j = ult.value.titleItem) == null ? void 0 : _j.h2]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h3')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_k = ult.value.titleItem) == null ? void 0 : _k.h3]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h4')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_l = ult.value.titleItem) == null ? void 0 : _l.h4]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h5')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_m = ult.value.titleItem) == null ? void 0 : _m.h5]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-title`,
                        onClick: () => {
                          emitHandler('h6')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_n = ult.value.titleItem) == null ? void 0 : _n.h6]
                    )
                  ]
                )
              },
              {
                default: () => {
                  var _a22, _b2
                  return [
                    createVNode(
                      'div',
                      {
                        class: [
                          `${prefix}-toolbar-item`,
                          (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                        ],
                        title: (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.title
                      },
                      [
                        createVNode(
                          Icon,
                          {
                            name: 'title'
                          },
                          null
                        ),
                        props2.showToolbarName &&
                          createVNode(
                            'div',
                            {
                              class: `${prefix}-toolbar-item-name`
                            },
                            [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.title]
                          )
                      ]
                    )
                  ]
                }
              }
            )
          }
          case 'sub': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_o = ult.value.toolbarTips) == null ? void 0 : _o.sub,
                onClick: () => {
                  emitHandler('sub')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'sub'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_p = ult.value.toolbarTips) == null ? void 0 : _p.sub]
                  )
              ]
            )
          }
          case 'sup': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_q = ult.value.toolbarTips) == null ? void 0 : _q.sup,
                onClick: () => {
                  emitHandler('sup')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'sup'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_r = ult.value.toolbarTips) == null ? void 0 : _r.sup]
                  )
              ]
            )
          }
          case 'quote': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_s = ult.value.toolbarTips) == null ? void 0 : _s.quote,
                onClick: () => {
                  emitHandler('quote')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'quote'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_t = ult.value.toolbarTips) == null ? void 0 : _t.quote]
                  )
              ]
            )
          }
          case 'unorderedList': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_u = ult.value.toolbarTips) == null ? void 0 : _u.unorderedList,
                onClick: () => {
                  emitHandler('unorderedList')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'unordered-list'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_v = ult.value.toolbarTips) == null ? void 0 : _v.unorderedList]
                  )
              ]
            )
          }
          case 'orderedList': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_w = ult.value.toolbarTips) == null ? void 0 : _w.orderedList,
                onClick: () => {
                  emitHandler('orderedList')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'ordered-list'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_x = ult.value.toolbarTips) == null ? void 0 : _x.orderedList]
                  )
              ]
            )
          }
          case 'task': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_y = ult.value.toolbarTips) == null ? void 0 : _y.task,
                onClick: () => {
                  emitHandler('task')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'task'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_z = ult.value.toolbarTips) == null ? void 0 : _z.task]
                  )
              ]
            )
          }
          case 'codeRow': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_A = ult.value.toolbarTips) == null ? void 0 : _A.codeRow,
                onClick: () => {
                  emitHandler('codeRow')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'code-row'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_B = ult.value.toolbarTips) == null ? void 0 : _B.codeRow]
                  )
              ]
            )
          }
          case 'code': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_C = ult.value.toolbarTips) == null ? void 0 : _C.code,
                onClick: () => {
                  emitHandler('code')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'code'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_D = ult.value.toolbarTips) == null ? void 0 : _D.code]
                  )
              ]
            )
          }
          case 'link': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_E = ult.value.toolbarTips) == null ? void 0 : _E.link,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  if (props2.insertLinkDirect) {
                    emitHandler('link')
                  } else {
                    modalData.type = 'link'
                    modalData.linkVisible = true
                  }
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'link'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_F = ult.value.toolbarTips) == null ? void 0 : _F.link]
                  )
              ]
            )
          }
          case 'image': {
            return props2.noUploadImg
              ? createVNode(
                  'div',
                  {
                    class: [
                      `${prefix}-toolbar-item`,
                      (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                    ],
                    title: (_G = ult.value.toolbarTips) == null ? void 0 : _G.image,
                    onClick: () => {
                      if (disabled == null ? void 0 : disabled.value) {
                        return false
                      }
                      if (props2.insertLinkDirect) {
                        emitHandler('image')
                      } else {
                        modalData.type = 'image'
                        modalData.linkVisible = true
                      }
                    }
                  },
                  [
                    createVNode(
                      Icon,
                      {
                        name: 'image'
                      },
                      null
                    ),
                    props2.showToolbarName &&
                      createVNode(
                        'div',
                        {
                          class: `${prefix}-toolbar-item-name`
                        },
                        [(_H = ult.value.toolbarTips) == null ? void 0 : _H.image]
                      )
                  ]
                )
              : createVNode(
                  Dropdown,
                  {
                    relative: `#${wrapperId}`,
                    visible: visible.image,
                    onChange: (v) => {
                      visible.image = v
                    },
                    disabled: disabled == null ? void 0 : disabled.value,
                    overlay: createVNode(
                      'ul',
                      {
                        class: `${prefix}-menu`,
                        onClick: () => {
                          visible.image = false
                        },
                        role: 'menu'
                      },
                      [
                        createVNode(
                          'li',
                          {
                            class: `${prefix}-menu-item ${prefix}-menu-item-image`,
                            onClick: () => {
                              if (props2.insertLinkDirect) {
                                emitHandler('image')
                              } else {
                                modalData.type = 'image'
                                modalData.linkVisible = true
                              }
                            },
                            role: 'menuitem',
                            tabindex: '0'
                          },
                          [(_I = ult.value.imgTitleItem) == null ? void 0 : _I.link]
                        ),
                        createVNode(
                          'li',
                          {
                            class: `${prefix}-menu-item ${prefix}-menu-item-image`,
                            onClick: () => {
                              uploadRef.value.click()
                            },
                            role: 'menuitem',
                            tabindex: '0'
                          },
                          [(_J = ult.value.imgTitleItem) == null ? void 0 : _J.upload]
                        ),
                        createVNode(
                          'li',
                          {
                            class: `${prefix}-menu-item ${prefix}-menu-item-image`,
                            onClick: () => {
                              modalData.clipVisible = true
                            },
                            role: 'menuitem',
                            tabindex: '0'
                          },
                          [(_K = ult.value.imgTitleItem) == null ? void 0 : _K.clip2upload]
                        )
                      ]
                    )
                  },
                  {
                    default: () => {
                      var _a22, _b2
                      return [
                        createVNode(
                          'div',
                          {
                            class: [
                              `${prefix}-toolbar-item`,
                              (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                            ],
                            title: (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.image
                          },
                          [
                            createVNode(
                              Icon,
                              {
                                name: 'image'
                              },
                              null
                            ),
                            props2.showToolbarName &&
                              createVNode(
                                'div',
                                {
                                  class: `${prefix}-toolbar-item-name`
                                },
                                [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.image]
                              )
                          ]
                        )
                      ]
                    }
                  }
                )
          }
          case 'table': {
            return createVNode(
              Dropdown,
              {
                relative: `#${wrapperId}`,
                visible: visible.table,
                onChange: (v) => {
                  visible.table = v
                },
                disabled: disabled == null ? void 0 : disabled.value,
                key: 'bar-table',
                overlay: createVNode(
                  TableShape,
                  {
                    tableShape: props2.tableShape,
                    onSelected: (selectedShape) => {
                      emitHandler('table', {
                        selectedShape
                      })
                    }
                  },
                  null
                )
              },
              {
                default: () => {
                  var _a22, _b2
                  return [
                    createVNode(
                      'div',
                      {
                        class: [
                          `${prefix}-toolbar-item`,
                          (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                        ],
                        title: (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.table
                      },
                      [
                        createVNode(
                          Icon,
                          {
                            name: 'table'
                          },
                          null
                        ),
                        props2.showToolbarName &&
                          createVNode(
                            'div',
                            {
                              class: `${prefix}-toolbar-item-name`
                            },
                            [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.table]
                          )
                      ]
                    )
                  ]
                }
              }
            )
          }
          case 'revoke': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_L = ult.value.toolbarTips) == null ? void 0 : _L.revoke,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  bus.emit(editorId, CTRL_Z)
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'revoke'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_M = ult.value.toolbarTips) == null ? void 0 : _M.revoke]
                  )
              ]
            )
          }
          case 'next': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_N = ult.value.toolbarTips) == null ? void 0 : _N.next,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  bus.emit(editorId, CTRL_SHIFT_Z)
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'next'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_O = ult.value.toolbarTips) == null ? void 0 : _O.next]
                  )
              ]
            )
          }
          case 'save': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_P = ult.value.toolbarTips) == null ? void 0 : _P.save,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  bus.emit(editorId, ON_SAVE)
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'save'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_Q = ult.value.toolbarTips) == null ? void 0 : _Q.save]
                  )
              ]
            )
          }
          case 'prettier': {
            return !props2.noPrettier
              ? createVNode(
                  'div',
                  {
                    class: [
                      `${prefix}-toolbar-item`,
                      (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                    ],
                    title: (_R = ult.value.toolbarTips) == null ? void 0 : _R.prettier,
                    onClick: () => {
                      emitHandler('prettier')
                    }
                  },
                  [
                    createVNode(
                      Icon,
                      {
                        name: 'prettier'
                      },
                      null
                    ),
                    props2.showToolbarName &&
                      createVNode(
                        'div',
                        {
                          class: `${prefix}-toolbar-item-name`
                        },
                        [(_S = ult.value.toolbarTips) == null ? void 0 : _S.prettier]
                      )
                  ]
                )
              : ''
          }
          case 'pageFullscreen': {
            return (
              !props2.setting.fullscreen &&
              createVNode(
                'div',
                {
                  class: [
                    `${prefix}-toolbar-item`,
                    props2.setting.pageFullscreen && `${prefix}-toolbar-active`,
                    (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                  ],
                  title: (_T = ult.value.toolbarTips) == null ? void 0 : _T.pageFullscreen,
                  onClick: () => {
                    if (disabled == null ? void 0 : disabled.value) {
                      return false
                    }
                    props2.updateSetting('pageFullscreen')
                  }
                },
                [
                  createVNode(
                    Icon,
                    {
                      name: props2.setting.pageFullscreen ? 'minimize' : 'maximize'
                    },
                    null
                  ),
                  props2.showToolbarName &&
                    createVNode(
                      'div',
                      {
                        class: `${prefix}-toolbar-item-name`
                      },
                      [(_U = ult.value.toolbarTips) == null ? void 0 : _U.pageFullscreen]
                    )
                ]
              )
            )
          }
          case 'fullscreen': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  props2.setting.fullscreen && `${prefix}-toolbar-active`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_V = ult.value.toolbarTips) == null ? void 0 : _V.fullscreen,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  fullscreenHandler()
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: props2.setting.fullscreen ? 'fullscreen-exit' : 'fullscreen'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_W = ult.value.toolbarTips) == null ? void 0 : _W.fullscreen]
                  )
              ]
            )
          }
          case 'preview': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  props2.setting.preview && `${prefix}-toolbar-active`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_X = ult.value.toolbarTips) == null ? void 0 : _X.preview,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  props2.updateSetting('preview')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'preview'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_Y = ult.value.toolbarTips) == null ? void 0 : _Y.preview]
                  )
              ]
            )
          }
          case 'previewOnly': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  props2.setting.previewOnly && `${prefix}-toolbar-active`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_Z = ult.value.toolbarTips) == null ? void 0 : _Z.previewOnly,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  props2.updateSetting('previewOnly')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'preview-only'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(__ = ult.value.toolbarTips) == null ? void 0 : __.previewOnly]
                  )
              ]
            )
          }
          case 'htmlPreview': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  props2.setting.htmlPreview && `${prefix}-toolbar-active`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_$ = ult.value.toolbarTips) == null ? void 0 : _$.htmlPreview,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  props2.updateSetting('htmlPreview')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'preview-html'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_aa = ult.value.toolbarTips) == null ? void 0 : _aa.htmlPreview]
                  )
              ]
            )
          }
          case 'catalog': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  props2.catalogVisible && `${prefix}-toolbar-active`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_ba = ult.value.toolbarTips) == null ? void 0 : _ba.catalog,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  bus.emit(editorId, CHANGE_CATALOG_VISIBLE)
                },
                key: 'bar-catalog'
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'catalog'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_ca = ult.value.toolbarTips) == null ? void 0 : _ca.catalog]
                  )
              ]
            )
          }
          case 'github': {
            return createVNode(
              'div',
              {
                class: [
                  `${prefix}-toolbar-item`,
                  (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                ],
                title: (_da = ult.value.toolbarTips) == null ? void 0 : _da.github,
                onClick: () => {
                  if (disabled == null ? void 0 : disabled.value) {
                    return false
                  }
                  C$1('https://github.com/imzbf/md-editor-v3')
                }
              },
              [
                createVNode(
                  Icon,
                  {
                    name: 'github'
                  },
                  null
                ),
                props2.showToolbarName &&
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-item-name`
                    },
                    [(_ea = ult.value.toolbarTips) == null ? void 0 : _ea.github]
                  )
              ]
            )
          }
          case 'mermaid': {
            return createVNode(
              Dropdown,
              {
                relative: `#${wrapperId}`,
                visible: visible.mermaid,
                onChange: (v) => {
                  visible.mermaid = v
                },
                disabled: disabled == null ? void 0 : disabled.value,
                overlay: createVNode(
                  'ul',
                  {
                    class: `${prefix}-menu`,
                    onClick: () => {
                      visible.mermaid = false
                    },
                    role: 'menu'
                  },
                  [
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('flow')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_fa = ult.value.mermaid) == null ? void 0 : _fa.flow]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('sequence')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ga = ult.value.mermaid) == null ? void 0 : _ga.sequence]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('gantt')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ha = ult.value.mermaid) == null ? void 0 : _ha.gantt]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('class')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ia = ult.value.mermaid) == null ? void 0 : _ia.class]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('state')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ja = ult.value.mermaid) == null ? void 0 : _ja.state]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('pie')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ka = ult.value.mermaid) == null ? void 0 : _ka.pie]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('relationship')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_la = ult.value.mermaid) == null ? void 0 : _la.relationship]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                        onClick: () => {
                          emitHandler('journey')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_ma = ult.value.mermaid) == null ? void 0 : _ma.journey]
                    )
                  ]
                ),
                key: 'bar-mermaid'
              },
              {
                default: () => {
                  var _a22, _b2
                  return [
                    createVNode(
                      'div',
                      {
                        class: [
                          `${prefix}-toolbar-item`,
                          (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                        ],
                        title: (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.mermaid
                      },
                      [
                        createVNode(
                          Icon,
                          {
                            name: 'mermaid'
                          },
                          null
                        ),
                        props2.showToolbarName &&
                          createVNode(
                            'div',
                            {
                              class: `${prefix}-toolbar-item-name`
                            },
                            [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.mermaid]
                          )
                      ]
                    )
                  ]
                }
              }
            )
          }
          case 'katex': {
            return createVNode(
              Dropdown,
              {
                relative: `#${wrapperId}`,
                visible: visible.katex,
                onChange: (v) => {
                  visible.katex = v
                },
                disabled: disabled == null ? void 0 : disabled.value,
                overlay: createVNode(
                  'ul',
                  {
                    class: `${prefix}-menu`,
                    onClick: () => {
                      visible.katex = false
                    },
                    role: 'menu'
                  },
                  [
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-katex`,
                        onClick: () => {
                          emitHandler('katexInline')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_na = ult.value.katex) == null ? void 0 : _na.inline]
                    ),
                    createVNode(
                      'li',
                      {
                        class: `${prefix}-menu-item ${prefix}-menu-item-katex`,
                        onClick: () => {
                          emitHandler('katexBlock')
                        },
                        role: 'menuitem',
                        tabindex: '0'
                      },
                      [(_oa = ult.value.katex) == null ? void 0 : _oa.block]
                    )
                  ]
                ),
                key: 'bar-katex'
              },
              {
                default: () => {
                  var _a22, _b2
                  return [
                    createVNode(
                      'div',
                      {
                        class: [
                          `${prefix}-toolbar-item`,
                          (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
                        ],
                        title: (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.katex
                      },
                      [
                        createVNode(
                          Icon,
                          {
                            name: 'formula'
                          },
                          null
                        ),
                        props2.showToolbarName &&
                          createVNode(
                            'div',
                            {
                              class: `${prefix}-toolbar-item-name`
                            },
                            [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.katex]
                          )
                      ]
                    )
                  ]
                }
              }
            )
          }
        }
      } else if (props2.defToolbars instanceof Array) {
        const defItem = props2.defToolbars[barItem]
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_pa = defItem.props) == null ? void 0 : _pa.theme) || theme2.value,
            previewTheme:
              ((_qa = defItem.props) == null ? void 0 : _qa.theme) || previewTheme.value,
            language: ((_ra = defItem.props) == null ? void 0 : _ra.theme) || language2.value,
            codeTheme: ((_sa = defItem.props) == null ? void 0 : _sa.codeTheme) || props2.codeTheme,
            disabled:
              ((_ta = defItem.props) == null ? void 0 : _ta.disabled) ||
              (disabled == null ? void 0 : disabled.value),
            showToolbarName:
              ((_ua = defItem.props) == null ? void 0 : _ua.showToolbarName) ||
              props2.showToolbarName,
            insert(generate) {
              bus.emit(editorId, REPLACE, 'universal', {
                generate
              })
            }
          })
          return defItemCloned
        }
        return ''
      } else if (props2.defToolbars && props2.defToolbars.children instanceof Array) {
        const defItem = props2.defToolbars.children[barItem]
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_va = defItem.props) == null ? void 0 : _va.theme) || theme2.value,
            previewTheme:
              ((_wa = defItem.props) == null ? void 0 : _wa.theme) || previewTheme.value,
            language: ((_xa = defItem.props) == null ? void 0 : _xa.theme) || language2.value,
            codeTheme: ((_ya = defItem.props) == null ? void 0 : _ya.codeTheme) || props2.codeTheme,
            disabled:
              ((_za = defItem.props) == null ? void 0 : _za.disabled) ||
              (disabled == null ? void 0 : disabled.value),
            showToolbarName:
              ((_Aa = defItem.props) == null ? void 0 : _Aa.showToolbarName) ||
              props2.showToolbarName,
            insert(generate) {
              bus.emit(editorId, REPLACE, 'universal', {
                generate
              })
            }
          })
          return defItemCloned
        }
        return ''
      } else {
        return ''
      }
    }
    watch(
      () => props2.toolbars,
      () => {
        nextTick(() => {
          if (wrapperRef.value) {
            I(wrapperRef.value)
          }
        })
      },
      {
        immediate: true
      }
    )
    return () => {
      var _a2
      const LeftBar = splitedbar.value[0].map((barItem) => barRender(barItem))
      const RightBar = splitedbar.value[1].map((barItem) => barRender(barItem))
      return createVNode(Fragment, null, [
        props2.toolbars.length > 0 &&
          createVNode(
            'div',
            {
              class: `${prefix}-toolbar-wrapper`,
              ref: wrapperRef,
              id: wrapperId
            },
            [
              createVNode(
                'div',
                {
                  class: [`${prefix}-toolbar`, props2.showToolbarName && `${prefix}-stn`]
                },
                [
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-left`,
                      ref: toolbarLeftRef
                    },
                    [LeftBar]
                  ),
                  createVNode(
                    'div',
                    {
                      class: `${prefix}-toolbar-right`
                    },
                    [RightBar]
                  )
                ]
              )
            ]
          ),
        createVNode(
          'label',
          {
            for: `${wrapperId}_label`,
            style: {
              display: 'none'
            },
            'aria-label': (_a2 = ult.value.imgTitleItem) == null ? void 0 : _a2.upload
          },
          null
        ),
        createVNode(
          'input',
          {
            id: `${wrapperId}_label`,
            ref: uploadRef,
            accept: 'image/*',
            type: 'file',
            multiple: true,
            style: {
              display: 'none'
            }
          },
          null
        ),
        createVNode(
          Modals,
          {
            linkVisible: modalData.linkVisible,
            clipVisible: modalData.clipVisible,
            type: modalData.type,
            onCancel: () => {
              modalData.linkVisible = false
              modalData.clipVisible = false
            },
            onOk: (data2) => {
              if (data2) {
                emitHandler(modalData.type, {
                  desc: data2.desc,
                  url: data2.url,
                  transform: modalData.type === 'image'
                })
              }
              modalData.linkVisible = false
              modalData.clipVisible = false
            }
          },
          null
        )
      ])
    }
  }
})
const useAutoScroll = (props2, html2, codeMirrorUt) => {
  const editorId = inject('editorId')
  let clearScrollAuto = () => {}
  let initScrollAuto = () => {}
  const rebindEvent = () => {
    var _a2
    clearScrollAuto()
    const rootNode = (_a2 = codeMirrorUt.value) == null ? void 0 : _a2.view.contentDOM.getRootNode()
    const cmScroller = rootNode.querySelector(`#${editorId} .cm-scroller`)
    const previewEle = rootNode.querySelector(`[id="${editorId}-preview-wrapper"]`)
    const htmlEle = rootNode.querySelector(`[id="${editorId}-html-wrapper"]`)
    if (previewEle || htmlEle) {
      const scrollHandler2 = previewEle ? scrollAuto : scrollAutoWithScale
      const cEle = previewEle || htmlEle
      ;[initScrollAuto, clearScrollAuto] = scrollHandler2(cmScroller, cEle, codeMirrorUt.value)
      if (props2.scrollAuto) {
        initScrollAuto()
      }
    }
  }
  watch(
    [
      html2,
      toRef(props2.setting, 'preview'),
      toRef(props2.setting, 'htmlPreview'),
      toRef(props2.setting, 'fullscreen'),
      toRef(props2.setting, 'pageFullscreen')
    ],
    () => {
      nextTick(rebindEvent)
    }
  )
  watch(
    () => props2.scrollAuto,
    (sa) => {
      if (sa) {
        initScrollAuto()
      } else {
        clearScrollAuto()
      }
    }
  )
  watch(
    () => props2.setting.previewOnly,
    (po) => {
      if (po) {
        clearScrollAuto()
      } else {
        initScrollAuto()
      }
    }
  )
  onMounted(rebindEvent)
}
const directive2flag = async (direct, codeMirrorUt, params) => {
  if (/^h[1-6]$/.test(direct)) {
    return handleHeading(direct, codeMirrorUt)
  } else if (direct === 'prettier') {
    return await handlePrettier(codeMirrorUt, params)
  }
  switch (direct) {
    case 'bold':
    case 'underline':
    case 'italic':
    case 'strikeThrough':
    case 'sub':
    case 'sup':
    case 'codeRow':
    case 'katexInline':
    case 'katexBlock': {
      return wrapText(direct, codeMirrorUt)
    }
    case 'quote':
    case 'orderedList':
    case 'unorderedList':
    case 'task': {
      return handleMultiLine(direct, codeMirrorUt)
    }
    case 'code': {
      return handleCodeBlock(params, codeMirrorUt)
    }
    case 'table': {
      return handleTable(params)
    }
    case 'link': {
      const { desc = '', url = '' } = params
      const text2 = `[${desc}](${url})`
      return {
        text: text2,
        options: {
          select: url === '',
          deviationStart: text2.length - url.length - 1,
          deviationEnd: -1
        }
      }
    }
    case 'image': {
      return handleImage(params)
    }
    case 'flow':
    case 'sequence':
    case 'gantt':
    case 'class':
    case 'state':
    case 'pie':
    case 'relationship':
    case 'journey': {
      return handleMermaid(direct)
    }
    case 'universal': {
      return handleUniversal(codeMirrorUt.getSelectedText(), params)
    }
    default: {
      return { text: '', options: {} }
    }
  }
}
const handleHeading = (direct, codeMirrorUt) => {
  const level = direct.slice(1)
  const prefix2 = '#'.repeat(Number(level))
  const [text2, replaceStart, replaceEnd] = getSelectedInfo(codeMirrorUt, {
    wholeLine: true
  })
  return {
    text: `${prefix2} ${text2}`,
    options: { deviationStart: prefix2.length + 1, replaceStart, replaceEnd }
  }
}
const handlePrettier = async (codeMirrorUt, params) => {
  var _a2, _b, _c
  const prettier =
    window.prettier ||
    ((_a2 = globalConfig.editorExtensions.prettier) == null ? void 0 : _a2.prettierInstance)
  const prettierPlugins = [
    ((_b = window.prettierPlugins) == null ? void 0 : _b.markdown) ||
      ((_c = globalConfig.editorExtensions.prettier) == null ? void 0 : _c.parserMarkdownInstance)
  ]
  if (!prettier || !prettierPlugins[0]) {
    bus.emit(params.editorId, ERROR_CATCHER, {
      name: 'prettier',
      message: 'prettier is undefined'
    })
    return {
      text: codeMirrorUt.getValue(),
      options: { select: false, replaceAll: true }
    }
  }
  return {
    text: await prettier.format(codeMirrorUt.getValue(), {
      parser: 'markdown',
      plugins: prettierPlugins
    }),
    options: { select: false, replaceAll: true }
  }
}
const wrappers = {
  bold: ['**', '**', 2, -2],
  underline: ['<u>', '</u>', 3, -4],
  italic: ['*', '*', 1, -1],
  strikeThrough: ['~~', '~~', 2, -2],
  sub: ['~', '~', 1, -1],
  sup: ['^', '^', 1, -1],
  codeRow: ['`', '`', 1, -1],
  katexInline: ['$', '$', 1, -1],
  katexBlock: ['\n$$\n', '\n$$\n', 4, -4]
}
const wrapText = (type, codeMirrorUt) => {
  const text2 = codeMirrorUt.getSelectedText()
  const [prefix2, subfix, deviationStart, deviationEnd] = wrappers[type]
  return {
    text: `${prefix2}${text2}${subfix}`,
    options: {
      deviationStart,
      deviationEnd
      // replaceStart, replaceEnd
    }
  }
}
const keys = {
  quote: '> ',
  unorderedList: '- ',
  orderedList: 1,
  task: '- [ ] '
}
const handleMultiLine = (type, codeMirrorUt) => {
  const [text2, replaceStart, replaceEnd] = getSelectedInfo(codeMirrorUt, {
    wholeLine: true
  })
  const lines = text2.split('\n')
  const key = keys[type]
  const formattedLines =
    type === 'orderedList'
      ? lines.map((line, i) => `${key + i}. ${line}`)
      : lines.map((line) => `${key}${line}`)
  const firstLinePrefix = type === 'orderedList' ? '1. ' : key.toString()
  const deviationStart = lines.length === 1 ? firstLinePrefix.length : 0
  return {
    text: formattedLines.join('\n'),
    options: { deviationStart, replaceStart, replaceEnd }
  }
}
const handleCodeBlock = (params, codeMirrorUt) => {
  const [text2, replaceStart, replaceEnd] = getSelectedInfo(codeMirrorUt)
  const mode = params.mode || 'language'
  const _text = `
\`\`\`${mode}
${params.text || text2 || ''}
\`\`\`
`
  return {
    text: _text,
    options: {
      deviationStart: 4,
      deviationEnd: 4 + mode.length - _text.length,
      replaceStart,
      replaceEnd
    }
  }
}
const handleMermaid = (type) => {
  const mermaidTemplates = {
    flow: 'flowchart TD \n  Start --> Stop',
    sequence: 'sequenceDiagram\n  A->>B: hello!\n  B-->>A: hi!',
    gantt: 'gantt\ntitle Gantt Chart\ndateFormat  YYYY-MM-DD',
    class: 'classDiagram\n  class Animal',
    state: 'stateDiagram-v2\n  s1 --> s2',
    pie: 'pie\n  "Dogs" : 386\n  "Cats" : 85\n  "Rats" : 15',
    relationship: 'erDiagram\n  CAR ||--o{ NAMED-DRIVER : allows',
    journey: 'journey\n  title My Journey',
    ...globalConfig.editorConfig.mermaidTemplate
  }
  return {
    text: `
\`\`\`mermaid
${mermaidTemplates[type]}
\`\`\`
`,
    options: { deviationStart: 12, deviationEnd: -5 }
  }
}
const handleImage = (params) => {
  const { desc = '', url = '', urls } = params
  let text2 = ''
  const urlIsEmpty = url === '' && (!urls || (urls instanceof Array && urls.length === 0))
  if (urls instanceof Array) {
    text2 = urls.reduce((pVal, _url) => {
      const {
        url: url2 = '',
        alt = '',
        title = ''
      } = typeof _url === 'object' ? _url : { url: _url }
      return (
        pVal +
        `![${alt}](${url2}${title ? " '" + title + "'" : ''})
`
      )
    }, '')
  } else {
    text2 = `![${desc}](${url})
`
  }
  return {
    text: text2,
    options: {
      select: url === '',
      deviationStart: urlIsEmpty ? text2.length - url.length - 2 : text2.length,
      deviationEnd: urlIsEmpty ? -2 : 0
    }
  }
}
const handleTable = (params) => {
  const { selectedShape = { x: 1, y: 1 } } = params
  const { x: x2, y: y2 } = selectedShape
  let text2 = '\n| Column'
  for (let i = 0; i <= y2; i++) {
    text2 += ` |`
  }
  text2 += '\n|'
  for (let i = 0; i <= y2; i++) {
    text2 += ' - |'
  }
  for (let row = 0; row <= x2; row++) {
    text2 += '\n|'
    for (let col = 0; col <= y2; col++) {
      text2 += ' |'
    }
  }
  text2 += '\n'
  return { text: text2, options: { deviationStart: 3, deviationEnd: 10 - text2.length } }
}
const handleUniversal = (selectedText, params) => {
  const { generate } = params
  const insertOptions = generate(selectedText)
  return {
    text: insertOptions.targetValue,
    options: {
      select: insertOptions.select ?? true,
      deviationStart: insertOptions.deviationStart || 0,
      deviationEnd: insertOptions.deviationEnd || 0
    }
  }
}
const getSelectedInfo = (codeMirrorUt, options = { wholeLine: false }) => {
  const state = codeMirrorUt.view.state
  const selection2 = state.selection.main
  if (selection2.empty) {
    const startLine = state.doc.lineAt(selection2.from)
    return [state.doc.lineAt(selection2.from).text, startLine.from, startLine.to]
  } else if (options.wholeLine) {
    const startLine = state.doc.lineAt(selection2.from)
    const endLine = state.doc.lineAt(selection2.to)
    return [state.doc.sliceString(startLine.from, endLine.to), startLine.from, endLine.to]
  }
  return [state.doc.sliceString(selection2.from, selection2.to), selection2.from, selection2.to]
}
const chalky$1 = '#e5c07b',
  coral$1 = 'var(--md-color)',
  cyan$1 = '#56b6c2',
  invalid$1 = '#ffffff',
  ivory$1 = 'var(--md-color)',
  stone$1 = '#e5c07b',
  malibu$1 = '#e5c07b',
  sage$1 = 'var(--md-color)',
  whiskey$1 = '#d19a66',
  violet$1 = '#c678dd',
  darkBackground$1 = '#21252b',
  highlightBackground$1 = '#2c313a',
  background$1 = 'var(--md-bk-color)',
  tooltipBackground$1 = 'var(--md-bk-color)',
  selection$1 = '#ceedfa33',
  cursor$1 = '#528bff'
const oneDarkTheme = EditorView.theme(
  {
    '&': {
      color: ivory$1,
      backgroundColor: background$1
    },
    '.cm-content': {
      caretColor: cursor$1
    },
    '.cm-cursor, .cm-dropCursor': { borderLeftColor: cursor$1 },
    '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection':
      { backgroundColor: selection$1 },
    '.cm-panels': { backgroundColor: darkBackground$1, color: ivory$1 },
    '.cm-panels.cm-panels-top': { borderBottom: '1px solid var(--md-border-color)' },
    '.cm-panels.cm-panels-bottom': { borderTop: '1px solid var(--md-border-color)' },
    '.cm-searchMatch': {
      backgroundColor: '#72a1ff59',
      outline: '1px solid #457dff'
    },
    '.cm-searchMatch.cm-searchMatch-selected': {
      backgroundColor: '#6199ff2f'
    },
    '.cm-activeLine': { backgroundColor: '#ceedfa33' },
    '.cm-selectionMatch': { backgroundColor: '#aafe661a' },
    '&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket': {
      backgroundColor: '#bad0f847'
    },
    '.cm-gutters': {
      backgroundColor: background$1,
      color: ivory$1,
      borderRight: '1px solid',
      borderColor: 'var(--md-border-color)'
    },
    '.cm-activeLineGutter': {
      backgroundColor: highlightBackground$1
    },
    '.cm-foldPlaceholder': {
      backgroundColor: 'transparent',
      border: 'none',
      color: '#ddd'
    },
    '.cm-tooltip': {
      border: '1px solid var(--md-border-color)',
      backgroundColor: tooltipBackground$1
    },
    '.cm-tooltip .cm-tooltip-arrow:before': {
      borderTopColor: 'transparent',
      borderBottomColor: 'transparent'
    },
    '.cm-tooltip .cm-tooltip-arrow:after': {
      borderTopColor: tooltipBackground$1,
      borderBottomColor: tooltipBackground$1
    },
    '.cm-tooltip-autocomplete': {
      '& > ul > li[aria-selected]': {
        color: ivory$1
      }
    }
  },
  { dark: true }
)
const oneDarkHighlightStyle = HighlightStyle.define([
  { tag: tags$1.keyword, color: violet$1 },
  {
    tag: [tags$1.name, tags$1.deleted, tags$1.character, tags$1.propertyName, tags$1.macroName],
    color: coral$1
  },
  { tag: [tags$1.function(tags$1.variableName), tags$1.labelName], color: malibu$1 },
  {
    tag: [tags$1.color, tags$1.constant(tags$1.name), tags$1.standard(tags$1.name)],
    color: whiskey$1
  },
  { tag: [tags$1.definition(tags$1.name), tags$1.separator], color: ivory$1 },
  {
    tag: [
      tags$1.typeName,
      tags$1.className,
      tags$1.number,
      tags$1.changed,
      tags$1.annotation,
      tags$1.modifier,
      tags$1.self,
      tags$1.namespace
    ],
    color: chalky$1
  },
  {
    tag: [
      tags$1.operator,
      tags$1.operatorKeyword,
      tags$1.url,
      tags$1.escape,
      tags$1.regexp,
      tags$1.link,
      tags$1.special(tags$1.string)
    ],
    color: cyan$1
  },
  { tag: [tags$1.meta, tags$1.comment], color: stone$1 },
  { tag: tags$1.strong, fontWeight: 'bold' },
  { tag: tags$1.emphasis, fontStyle: 'italic' },
  { tag: tags$1.strikethrough, textDecoration: 'line-through' },
  { tag: tags$1.link, color: stone$1, textDecoration: 'underline' },
  { tag: tags$1.heading, fontWeight: 'bold', color: coral$1 },
  { tag: [tags$1.atom, tags$1.bool, tags$1.special(tags$1.variableName)], color: whiskey$1 },
  { tag: [tags$1.processingInstruction, tags$1.string, tags$1.inserted], color: sage$1 },
  { tag: tags$1.invalid, color: invalid$1 }
])
const oneDark = [oneDarkTheme, syntaxHighlighting(oneDarkHighlightStyle)]
const chalky = '#e5c07b',
  coral = 'var(--md-color)',
  cyan = '#56b6c2',
  invalid = '#fff',
  ivory = '#3f4a54',
  stone = '#2d8cf0',
  malibu = '#2d8cf0',
  sage = '#3f4a54',
  whiskey = '#d19a66',
  violet = '#c678dd',
  darkBackground = '#f6f6f6',
  highlightBackground = '#ceedfa33',
  background = 'var(--md-bk-color)',
  tooltipBackground = 'var(--md-bk-color)',
  selection = '#bad5fa',
  cursor = '#3f4a54'
const oneLightTheme = EditorView.theme(
  {
    '&': {
      color: ivory,
      backgroundColor: background
    },
    '.cm-content': {
      caretColor: cursor
    },
    '.cm-cursor, .cm-dropCursor': { borderLeftColor: cursor },
    '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection':
      { backgroundColor: selection },
    '.cm-panels': { backgroundColor: darkBackground, color: ivory },
    '.cm-panels.cm-panels-top': { borderBottom: '1px solid var(--md-border-color)' },
    '.cm-panels.cm-panels-bottom': { borderTop: '1px solid var(--md-border-color)' },
    '.cm-searchMatch': {
      backgroundColor: '#72a1ff59',
      outline: '1px solid #457dff'
    },
    '.cm-searchMatch.cm-searchMatch-selected': {
      backgroundColor: '#6199ff2f'
    },
    '.cm-activeLine': { backgroundColor: '#ceedfa33' },
    '.cm-selectionMatch': { backgroundColor: '#aafe661a' },
    '&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket': {
      backgroundColor: '#bad0f847'
    },
    '.cm-gutters': {
      backgroundColor: background,
      color: ivory,
      borderRight: '1px solid',
      borderColor: 'var(--md-border-color)'
    },
    '.cm-activeLineGutter': {
      backgroundColor: highlightBackground
    },
    '.cm-foldPlaceholder': {
      backgroundColor: 'transparent',
      border: 'none',
      color: '#ddd'
    },
    '.cm-tooltip': {
      border: '1px solid var(--md-border-color)',
      backgroundColor: tooltipBackground
    },
    '.cm-tooltip .cm-tooltip-arrow:before': {
      borderTopColor: 'transparent',
      borderBottomColor: 'transparent'
    },
    '.cm-tooltip .cm-tooltip-arrow:after': {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    '.cm-tooltip-autocomplete': {
      '& > ul > li[aria-selected]': {
        color: ivory
      }
    }
  }
  // { dark: true }
)
const oneLightHighlightStyle = HighlightStyle.define([
  { tag: tags$1.keyword, color: violet },
  {
    tag: [tags$1.name, tags$1.deleted, tags$1.character, tags$1.propertyName, tags$1.macroName],
    color: coral
  },
  { tag: [tags$1.function(tags$1.variableName), tags$1.labelName], color: malibu },
  {
    tag: [tags$1.color, tags$1.constant(tags$1.name), tags$1.standard(tags$1.name)],
    color: whiskey
  },
  { tag: [tags$1.definition(tags$1.name), tags$1.separator], color: ivory },
  {
    tag: [
      tags$1.typeName,
      tags$1.className,
      tags$1.number,
      tags$1.changed,
      tags$1.annotation,
      tags$1.modifier,
      tags$1.self,
      tags$1.namespace
    ],
    color: chalky
  },
  {
    tag: [
      tags$1.operator,
      tags$1.operatorKeyword,
      tags$1.url,
      tags$1.escape,
      tags$1.regexp,
      tags$1.link,
      tags$1.special(tags$1.string)
    ],
    color: cyan
  },
  { tag: [tags$1.meta, tags$1.comment], color: stone },
  { tag: tags$1.strong, fontWeight: 'bold' },
  { tag: tags$1.emphasis, fontStyle: 'italic' },
  { tag: tags$1.strikethrough, textDecoration: 'line-through' },
  { tag: tags$1.link, color: stone, textDecoration: 'underline' },
  { tag: tags$1.heading, fontWeight: 'bold', color: coral },
  { tag: [tags$1.atom, tags$1.bool, tags$1.special(tags$1.variableName)], color: whiskey },
  { tag: [tags$1.processingInstruction, tags$1.string, tags$1.inserted], color: sage },
  { tag: tags$1.invalid, color: invalid }
])
const oneLight = [oneLightTheme, syntaxHighlighting(oneLightHighlightStyle)]
const getPairApply = (flag, type, title, suffix, selectType) => {
  return (view, _completion, from, to) => {
    const insert2 = `${flag}${type}${title}${suffix}`
    const newTo = from + _completion.label.length + (selectType === 'title' ? title.length : 0)
    view.dispatch({
      changes: { from, to, insert: insert2 },
      selection: EditorSelection.create(
        [
          EditorSelection.range(
            from + _completion.label.length + (selectType === 'title' ? 1 : -type.length),
            newTo
          ),
          EditorSelection.cursor(newTo)
        ],
        1
      )
    })
    view.focus()
  }
}
const getApply = (_label) => {
  return (view, _completion, from, to) => {
    const label = _label.slice(to - from)
    view.dispatch(view.state.replaceSelection(`${label} `))
  }
}
const createAutocompletion = (completions) => {
  const defaultCompletion = (context) => {
    const word = context.matchBefore(/^#+|^-\s*\[*\s*\]*|`+|\[|!\[*|^\|\s?\|?|\$\$?|!+\s*\w*/)
    if (word === null || (word.from == word.to && context.explicit)) {
      return null
    }
    return {
      from: word.from,
      options: [
        // 标题
        ...['h2', 'h3', 'h4', 'h5', 'h6'].map((key, index2) => {
          const label = new Array(index2 + 2).fill('#').join('')
          return {
            label,
            type: 'text',
            apply: getApply(label)
          }
        }),
        // 任务列表
        ...['unchecked', 'checked'].map((key) => {
          const label = key === 'checked' ? '- [x]' : '- [ ]'
          return {
            label,
            type: 'text',
            apply: getApply(label)
          }
        }),
        // 代码
        ...[
          ['`', ''],
          ['```', 'language'],
          ['```mermaid\n', '']
        ].map((c) => {
          return {
            label: `${c[0]}${c[1]}`,
            type: 'text',
            apply: getPairApply(c[0], c[1], '', c[0] === '`' ? '`' : '\n```', 'type')
          }
        }),
        // 链接
        {
          label: '[]()',
          type: 'text'
        },
        {
          label: '![]()',
          type: 'text'
        },
        // 表格
        {
          label: '| |',
          type: 'text',
          detail: 'table',
          apply:
            '| col | col | col |\n| - | - | - |\n| content | content | content |\n| content | content | content |'
        },
        // 公式
        {
          label: '$',
          type: 'text',
          apply: getPairApply('$', '', '', '$', 'type')
        },
        {
          label: '$$',
          type: 'text',
          apply: getPairApply('$$', '', '\n', '\n$$', 'title')
        },
        // 那啥？
        ...[
          'note',
          'abstract',
          'info',
          'tip',
          'success',
          'question',
          'warning',
          'failure',
          'danger',
          'bug',
          'example',
          'quote',
          'hint',
          'caution',
          'error',
          'attention'
        ].map((key) => {
          const label = `!!! ${key}`
          return {
            label,
            type: 'text',
            apply: getPairApply('!!!', ` ${key}`, ' Title', '\n\n!!!', 'title')
          }
        })
      ]
    }
  }
  return autocompletion({
    override: completions ? [defaultCompletion, ...completions] : [defaultCompletion]
  })
}
const toggleWith = (view) => {
  const mc = new Compartment()
  const toggle = (extension) => {
    if (mc.get(view.state)) {
      view.dispatch({ effects: mc.reconfigure(extension) })
    } else {
      view.dispatch({
        effects: StateEffect.appendConfig.of(mc.of(extension))
      })
    }
    return true
  }
  return toggle
}
class CodeMirrorUt {
  constructor(view) {
    __publicField(this, 'view')
    __publicField(this, 'maxLength', Number.MAX_SAFE_INTEGER)
    __publicField(this, 'toggleTabSize')
    __publicField(this, 'togglePlaceholder')
    __publicField(this, 'setExtensions')
    __publicField(this, 'toggleDisabled')
    __publicField(this, 'toggleReadOnly')
    __publicField(this, 'toggleMaxlength')
    this.view = view
    this.toggleTabSize = toggleWith(this.view)
    this.togglePlaceholder = toggleWith(this.view)
    this.setExtensions = toggleWith(this.view)
    this.toggleDisabled = toggleWith(this.view)
    this.toggleReadOnly = toggleWith(this.view)
    this.toggleMaxlength = toggleWith(this.view)
  }
  getValue() {
    return this.view.state.doc.toString()
  }
  /**
   * 设置内容
   *
   * @param insert 待插入内容
   * @param from 插入开始位置
   * @param to 插入结束位置
   */
  setValue(insert2, from = 0, to = this.view.state.doc.length) {
    this.view.dispatch({
      changes: {
        from,
        to,
        insert: insert2
      }
    })
  }
  /**
   * 获取选中的文本
   */
  getSelectedText() {
    const { from, to } = this.view.state.selection.main
    return this.view.state.sliceDoc(from, to)
  }
  /**
   * 使用新的内容替换选中的内容
   *
   * @param text 待替换内容
   * @param options 替换后是否选中
   */
  replaceSelectedText(text2, _options, editorId) {
    const options = {
      // 是否选中
      select: true,
      // 选中时，开始位置的偏移量
      deviationStart: 0,
      // 结束的偏移量
      deviationEnd: 0,
      // 直接替换所有文本
      replaceAll: false,
      // 替换旧文本的开始位置
      replaceStart: -1,
      // 替换旧文本的结束位置
      replaceEnd: -1,
      ..._options
    }
    try {
      if (options.replaceAll) {
        this.setValue(text2)
        if (text2.length > this.maxLength) {
          throw new Error('The input text is too long')
        }
        return
      }
      if (
        this.view.state.doc.length - this.getSelectedText().length + text2.length >
        this.maxLength
      ) {
        throw new Error('The input text is too long')
      }
      const { from } = this.view.state.selection.main
      if (options.replaceStart !== -1) {
        this.view.dispatch({
          changes: {
            from: options.replaceStart,
            to: options.replaceEnd,
            insert: text2
          }
        })
      } else {
        this.view.dispatch(this.view.state.replaceSelection(text2))
      }
      if (options.select) {
        this.view.dispatch({
          selection: {
            anchor:
              options.replaceStart === -1
                ? from + options.deviationStart
                : options.replaceStart + options.deviationStart,
            head:
              options.replaceStart === -1
                ? from + text2.length + options.deviationEnd
                : options.replaceStart + text2.length + options.deviationEnd
          }
        })
      }
      this.view.focus()
    } catch (e2) {
      if (e2.message === 'The input text is too long') {
        bus.emit(editorId, ERROR_CATCHER, {
          name: 'overlength',
          message: e2.message,
          data: text2
        })
      } else {
        throw e2
      }
    }
  }
  /**
   * 设置tabSize
   *
   * @param tabSize 需要切换的大小
   */
  setTabSize(tabSize) {
    this.toggleTabSize([EditorState.tabSize.of(tabSize), indentUnit.of(' '.repeat(tabSize))])
  }
  /**
   * 设置placeholder
   *
   * @param t 目标内容
   */
  setPlaceholder(t2) {
    this.togglePlaceholder(placeholder(t2))
  }
  focus(options) {
    this.view.focus()
    if (!options) {
      return
    }
    let anchor = 0
    let head = 0
    let pos = 0
    switch (options) {
      case 'start': {
        break
      }
      case 'end': {
        const length = this.getValue().length
        anchor = head = pos = length
        break
      }
      default: {
        anchor = options.rangeAnchor || options.cursorPos
        head = options.rangeHead || options.cursorPos
        pos = options.cursorPos
      }
    }
    this.view.dispatch({
      scrollIntoView: true,
      selection: EditorSelection.create(
        [EditorSelection.range(anchor, head), EditorSelection.cursor(pos)],
        1
      )
    })
  }
  setDisabled(d) {
    this.toggleDisabled([EditorView.editable.of(!d)])
  }
  setReadOnly(r2) {
    this.toggleReadOnly([EditorState.readOnly.of(r2)])
  }
  setMaxLength(ml) {
    this.maxLength = ml
    this.toggleMaxlength([
      EditorState.changeFilter.of((tr) => {
        return tr.newDoc.length <= ml
      })
    ])
  }
}
const usePasteUpload = (props2, codeMirrorUt) => {
  const editorId = inject('editorId')
  const imgInsert = (tv) => {
    if (tv instanceof Promise) {
      tv.then((targetValue) => {
        bus.emit(editorId, REPLACE, 'universal', {
          generate() {
            return {
              targetValue
            }
          }
        })
      }).catch((err) => {
        console.error(err)
      })
    } else {
      bus.emit(editorId, REPLACE, 'universal', {
        generate() {
          return {
            targetValue: tv
          }
        }
      })
    }
  }
  const pasteHandler = (e2) => {
    var _a2, _b, _c
    if (!e2.clipboardData) {
      return
    }
    if (e2.clipboardData.files.length > 0) {
      const { files } = e2.clipboardData
      bus.emit(
        editorId,
        UPLOAD_IMAGE,
        Array.from(files).filter((file) => {
          return /image\/.*/.test(file.type)
        })
      )
      e2.preventDefault()
      return
    }
    const targetValue = e2.clipboardData.getData('text/plain')
    const to = ((_a2 = codeMirrorUt.value) == null ? void 0 : _a2.view.state.selection.main.to) || 0
    const from =
      ((_b = codeMirrorUt.value) == null ? void 0 : _b.view.state.doc.lineAt(to).from) || 0
    const lineStart =
      ((_c = codeMirrorUt.value) == null ? void 0 : _c.view.state.doc.sliceString(from, to)) || ''
    const templateStart = /!\[.*\]\(\s*$/.test(lineStart)
    const templateIn = /!\[.*\]\((.*)\s?.*\)/.test(targetValue)
    if (templateStart) {
      const tv = props2.transformImgUrl(targetValue)
      imgInsert(tv)
      e2.preventDefault()
      return
    } else if (templateIn) {
      const matchArr = targetValue.match(
        new RegExp(`(?<=!\\[.*\\]\\()([^)\\s]+)(?=\\s?["']?.*["']?\\))`, 'g')
      )
      if (matchArr) {
        Promise.all(
          matchArr.map((img) => {
            return props2.transformImgUrl(img)
          })
        ).then((newUrls) => {
          imgInsert(
            newUrls.reduce((prev, curr, index2) => {
              return prev.replace(matchArr[index2], curr)
            }, targetValue)
          )
        })
      } else {
        imgInsert(targetValue)
      }
      e2.preventDefault()
      return
    }
    if (props2.autoDetectCode && e2.clipboardData.types.includes('vscode-editor-data')) {
      const vscCoodInfo = JSON.parse(e2.clipboardData.getData('vscode-editor-data'))
      bus.emit(editorId, REPLACE, 'code', {
        mode: vscCoodInfo.mode,
        text: e2.clipboardData.getData('text/plain')
      })
      e2.preventDefault()
      return
    }
    if (props2.maxlength && targetValue.length + props2.modelValue.length > props2.maxlength) {
      bus.emit(editorId, ERROR_CATCHER, {
        name: 'overlength',
        message: 'The input text is too long',
        data: targetValue
      })
    }
  }
  return pasteHandler
}
const createCommands = (id2, contentProps2) => {
  const CtrlB = {
    key: 'Ctrl-b',
    mac: 'Cmd-b',
    run: () => {
      bus.emit(id2, REPLACE, 'bold')
      return true
    }
  }
  const CtrlS = {
    key: 'Ctrl-s',
    mac: 'Cmd-s',
    run: (view) => {
      bus.emit(id2, ON_SAVE, view.state.doc.toString())
      return true
    },
    shift: () => {
      bus.emit(id2, REPLACE, 'strikeThrough')
      return true
    }
  }
  const CtrlU = {
    key: 'Ctrl-u',
    mac: 'Cmd-u',
    preventDefault: true,
    run: () => {
      bus.emit(id2, REPLACE, 'underline')
      return true
    },
    shift: () => {
      bus.emit(id2, REPLACE, 'unorderedList')
      return true
    }
  }
  const CtrlI = {
    key: 'Ctrl-i',
    mac: 'Cmd-i',
    preventDefault: true,
    run: () => {
      bus.emit(id2, REPLACE, 'italic')
      return true
    },
    shift: () => {
      bus.emit(id2, OPEN_MODALS, 'image')
      return true
    }
  }
  const Ctrl1 = {
    key: 'Ctrl-1',
    mac: 'Cmd-1',
    run: () => {
      bus.emit(id2, REPLACE, 'h1')
      return true
    }
  }
  const Ctrl2 = {
    key: 'Ctrl-2',
    mac: 'Cmd-2',
    run: () => {
      bus.emit(id2, REPLACE, 'h2')
      return true
    }
  }
  const Ctrl3 = {
    key: 'Ctrl-3',
    mac: 'Cmd-3',
    run: () => {
      bus.emit(id2, REPLACE, 'h3')
      return true
    }
  }
  const Ctrl4 = {
    key: 'Ctrl-4',
    mac: 'Cmd-4',
    run: () => {
      bus.emit(id2, REPLACE, 'h4')
      return true
    }
  }
  const Ctrl5 = {
    key: 'Ctrl-5',
    mac: 'Cmd-5',
    run: () => {
      bus.emit(id2, REPLACE, 'h5')
      return true
    }
  }
  const Ctrl6 = {
    key: 'Ctrl-6',
    mac: 'Cmd-6',
    run: () => {
      bus.emit(id2, REPLACE, 'h6')
      return true
    }
  }
  const CtrlArrowUp = {
    key: 'Ctrl-ArrowUp',
    mac: 'Cmd-ArrowUp',
    run: () => {
      bus.emit(id2, REPLACE, 'sup')
      return true
    }
  }
  const CtrlArrowDown = {
    key: 'Ctrl-ArrowDown',
    mac: 'Cmd-ArrowDown',
    run: () => {
      bus.emit(id2, REPLACE, 'sub')
      return true
    }
  }
  const CtrlO = {
    key: 'Ctrl-o',
    mac: 'Cmd-o',
    run: () => {
      bus.emit(id2, REPLACE, 'orderedList')
      return true
    }
  }
  const CtrlC = {
    key: 'Ctrl-c',
    mac: 'Cmd-c',
    shift: () => {
      bus.emit(id2, REPLACE, 'code')
      return true
    },
    any(_view, e2) {
      if ((e2.ctrlKey || e2.metaKey) && e2.altKey && e2.code === 'KeyC') {
        bus.emit(id2, REPLACE, 'codeRow')
        return true
      }
      return false
    }
  }
  const CtrlL = {
    key: 'Ctrl-l',
    mac: 'Cmd-l',
    run: () => {
      bus.emit(id2, OPEN_MODALS, 'link')
      return true
    }
  }
  const CtrlF = {
    key: 'Ctrl-f',
    mac: 'Cmd-f',
    shift: () => {
      if (!contentProps2.noPrettier) {
        bus.emit(id2, REPLACE, 'prettier')
        return true
      }
      return false
    }
  }
  const CtrlT = {
    any: (_view, e2) => {
      if ((e2.ctrlKey || e2.metaKey) && e2.altKey && e2.shiftKey && e2.code === 'KeyT') {
        bus.emit(id2, REPLACE, 'table')
        return true
      }
      return false
    }
  }
  const CtrlD = {
    key: 'Ctrl-d',
    mac: 'Cmd-d',
    run: deleteLine,
    preventDefault: true
  }
  return [
    CtrlB,
    CtrlD,
    CtrlS,
    CtrlU,
    CtrlI,
    Ctrl1,
    Ctrl2,
    Ctrl3,
    Ctrl4,
    Ctrl5,
    Ctrl6,
    CtrlArrowUp,
    CtrlArrowDown,
    CtrlO,
    CtrlC,
    CtrlL,
    CtrlF,
    CtrlT,
    ...searchKeymap
  ]
}
EditorView.EDIT_CONTEXT = false
const useCodeMirror = (props2) => {
  const tabWidth = inject('tabWidth')
  const editorId = inject('editorId')
  const theme2 = inject('theme')
  const inputWrapperRef = ref()
  const codeMirrorUt = shallowRef()
  const spelling = ref(false)
  const languageComp = new Compartment(),
    themeComp = new Compartment(),
    autocompletionComp = new Compartment(),
    historyComp = new Compartment(),
    eventComp = new Compartment()
  const mdEditorCommands = createCommands(editorId, props2)
  const getDefaultKeymaps = () => [
    ...mdEditorCommands,
    ...defaultKeymap,
    ...historyKeymap,
    indentWithTab
  ]
  const pasteHandler = usePasteUpload(props2, codeMirrorUt)
  const domEventHandlers = {
    paste: pasteHandler,
    blur: props2.onBlur,
    focus: props2.onFocus,
    drop: props2.onDrop,
    compositionstart: () => {
      spelling.value = true
    },
    compositionend: (_e, view) => {
      spelling.value = false
      props2.updateModelValue(view.state.doc.toString())
    },
    input: (e2) => {
      if (props2.onInput) {
        props2.onInput(e2)
      }
      const { data: data2 } = e2
      if (props2.maxlength && props2.modelValue.length + data2.length > props2.maxlength) {
        bus.emit(editorId, ERROR_CATCHER, {
          name: 'overlength',
          message: 'The input text is too long',
          data: data2
        })
      }
    }
  }
  const defaultExtensions = [
    keymap.of(getDefaultKeymaps()),
    historyComp.of(history()),
    languageComp.of(markdown({ codeLanguages: languages })),
    // 横向换行
    EditorView.lineWrapping,
    EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        props2.onChange(update.state.doc.toString())
        if (!spelling.value) {
          props2.updateModelValue(update.state.doc.toString())
        }
      }
    }),
    eventComp.of(EditorView.domEventHandlers(domEventHandlers)),
    // 解决多行placeholder时，光标异常的情况
    drawSelection()
  ]
  const getExtensions = () => {
    const extensions = [
      ...defaultExtensions,
      themeComp.of(theme2.value === 'light' ? oneLight : oneDark),
      autocompletionComp.of(createAutocompletion(props2.completions))
    ]
    return globalConfig.codeMirrorExtensions(theme2.value, extensions, getDefaultKeymaps(), {
      editorId
    })
  }
  onMounted(() => {
    const view = new EditorView({
      doc: props2.modelValue,
      parent: inputWrapperRef.value,
      extensions: [getExtensions()]
    })
    const nc = new CodeMirrorUt(view)
    codeMirrorUt.value = nc
    setTimeout(() => {
      nc.setTabSize(tabWidth)
      nc.setDisabled(props2.disabled)
      nc.setReadOnly(props2.readonly)
      if (props2.placeholder) nc.setPlaceholder(props2.placeholder)
      if (typeof props2.maxlength === 'number') nc.setMaxLength(props2.maxlength)
      if (props2.autofocus) view.focus()
    }, 0)
    bus.on(editorId, {
      name: CTRL_Z,
      callback() {
        undo(view)
      }
    })
    bus.on(editorId, {
      name: CTRL_SHIFT_Z,
      callback() {
        redo(view)
      }
    })
    bus.on(editorId, {
      name: REPLACE,
      async callback(direct, params = {}) {
        var _a2, _b
        if (direct === 'image' && params.transform) {
          const tv = props2.transformImgUrl(params.url)
          if (tv instanceof Promise) {
            tv.then(async (url) => {
              var _a22
              const { text: text2, options } = await directive2flag(direct, codeMirrorUt.value, {
                ...params,
                url
              })
              ;(_a22 = codeMirrorUt.value) == null
                ? void 0
                : _a22.replaceSelectedText(text2, options, editorId)
            }).catch((err) => {
              console.error(err)
            })
          } else {
            const { text: text2, options } = await directive2flag(direct, codeMirrorUt.value, {
              ...params,
              url: tv
            })
            ;(_a2 = codeMirrorUt.value) == null
              ? void 0
              : _a2.replaceSelectedText(text2, options, editorId)
          }
        } else {
          const { text: text2, options } = await directive2flag(direct, codeMirrorUt.value, params)
          ;(_b = codeMirrorUt.value) == null
            ? void 0
            : _b.replaceSelectedText(text2, options, editorId)
        }
      }
    })
    bus.on(editorId, {
      name: EVENT_LISTENER,
      callback: $((handlers2) => {
        var _a2
        const nextDomEventHandlers = { ...domEventHandlers }
        const defaultEventNames = Object.keys(domEventHandlers)
        for (const eventName in handlers2) {
          const en = eventName
          if (defaultEventNames.includes(en)) {
            nextDomEventHandlers[en] = (e2, v) => {
              handlers2[en](e2, v)
              if (!e2.defaultPrevented) {
                domEventHandlers[en](e2, v)
              }
            }
          } else {
            nextDomEventHandlers[en] = handlers2[en]
          }
        }
        ;(_a2 = codeMirrorUt.value) == null
          ? void 0
          : _a2.view.dispatch({
              effects: eventComp.reconfigure(EditorView.domEventHandlers(nextDomEventHandlers))
            })
      })
    })
    bus.on(editorId, {
      name: TASK_STATE_CHANGED,
      callback: (lineNumber, value) => {
        const line = view.state.doc.line(lineNumber)
        view.dispatch(
          view.state.update({ changes: { from: line.from, to: line.to, insert: value } })
        )
      }
    })
    bus.on(editorId, {
      name: SEND_EDITOR_VIEW,
      callback() {
        bus.emit(editorId, GET_EDITOR_VIEW, view)
      }
    })
    bus.emit(editorId, GET_EDITOR_VIEW, view)
  })
  watch(
    theme2,
    () => {
      var _a2
      ;(_a2 = codeMirrorUt.value) == null
        ? void 0
        : _a2.view.dispatch({
            effects: themeComp.reconfigure(theme2.value === 'light' ? oneLight : oneDark)
          })
    },
    { deep: true }
  )
  watch(
    () => props2.completions,
    () => {
      var _a2
      ;(_a2 = codeMirrorUt.value) == null
        ? void 0
        : _a2.view.dispatch({
            effects: autocompletionComp.reconfigure(createAutocompletion(props2.completions))
          })
    },
    { deep: true }
  )
  watch(
    () => props2.modelValue,
    () => {
      var _a2, _b
      if (((_a2 = codeMirrorUt.value) == null ? void 0 : _a2.getValue()) !== props2.modelValue) {
        ;(_b = codeMirrorUt.value) == null ? void 0 : _b.setValue(props2.modelValue)
      }
    }
  )
  watch(
    () => props2.placeholder,
    () => {
      var _a2
      ;(_a2 = codeMirrorUt.value) == null ? void 0 : _a2.setPlaceholder(props2.placeholder)
    }
  )
  watch(
    () => props2.disabled,
    () => {
      var _a2
      ;(_a2 = codeMirrorUt.value) == null ? void 0 : _a2.setDisabled(props2.disabled)
    }
  )
  watch(
    () => props2.readonly,
    () => {
      var _a2
      ;(_a2 = codeMirrorUt.value) == null ? void 0 : _a2.setDisabled(props2.readonly)
    }
  )
  watch(
    () => props2.maxlength,
    () => {
      var _a2
      if (props2.maxlength) {
        ;(_a2 = codeMirrorUt.value) == null ? void 0 : _a2.setMaxLength(props2.maxlength)
      }
    }
  )
  return {
    inputWrapperRef,
    codeMirrorUt,
    resetHistory() {
      var _a2, _b
      ;(_a2 = codeMirrorUt.value) == null
        ? void 0
        : _a2.view.dispatch({ effects: historyComp.reconfigure([]) })
      ;(_b = codeMirrorUt.value) == null
        ? void 0
        : _b.view.dispatch({ effects: historyComp.reconfigure(history()) })
    }
  }
}
const useResize = (props2, contentRef, resizeRef) => {
  const compatibledInputBoxWidth = computed(() => {
    return /px$/.test(`${props2.inputBoxWidth}`) ? '50%' : props2.inputBoxWidth
  })
  const state = reactive({
    resizedWidth: compatibledInputBoxWidth.value
  })
  const inputWrapperStyle = reactive({
    width: compatibledInputBoxWidth.value
  })
  const resizeOperateStyle = reactive({
    left: compatibledInputBoxWidth.value,
    display: 'initial'
  })
  const resizeMousemove = (e2) => {
    var _a2, _b, _c
    const maxWidth = ((_a2 = contentRef.value) == null ? void 0 : _a2.offsetWidth) || 0
    const contentX = ((_b = contentRef.value) == null ? void 0 : _b.getBoundingClientRect().x) || 0
    let nextWidth = e2.x - contentX
    if (nextWidth / maxWidth < MinInputBoxWidth) {
      nextWidth = maxWidth * MinInputBoxWidth
    } else if (nextWidth > maxWidth - maxWidth * MinInputBoxWidth) {
      nextWidth = maxWidth - maxWidth * MinInputBoxWidth
    }
    const ibw = `${(nextWidth / maxWidth) * 100}%`
    inputWrapperStyle.width = ibw
    resizeOperateStyle.left = ibw
    state.resizedWidth = ibw
    ;(_c = props2.oninputBoxWidthChange) == null ? void 0 : _c.call(props2, ibw)
  }
  const resizeMousedown = (ev) => {
    if (ev.target === resizeRef.value) {
      document.addEventListener('mousemove', resizeMousemove)
    }
  }
  const resizeMouseup = () => {
    document.removeEventListener('mousemove', resizeMousemove)
  }
  watch([resizeRef], () => {
    document.removeEventListener('mousedown', resizeMousedown)
    document.removeEventListener('mouseup', resizeMouseup)
    document.addEventListener('mousedown', resizeMousedown)
    document.addEventListener('mouseup', resizeMouseup)
  })
  onMounted(() => {
    document.addEventListener('mousedown', resizeMousedown)
    document.addEventListener('mouseup', resizeMouseup)
  })
  onBeforeUnmount(() => {
    document.removeEventListener('mousedown', resizeMousedown)
    document.removeEventListener('mouseup', resizeMouseup)
  })
  watch([compatibledInputBoxWidth], ([nVal]) => {
    state.resizedWidth = nVal
    inputWrapperStyle.width = nVal
    resizeOperateStyle.left = nVal
  })
  watch(
    [
      toRef(props2.setting, 'htmlPreview'),
      toRef(props2.setting, 'preview'),
      toRef(props2.setting, 'previewOnly')
    ],
    () => {
      if (props2.setting.previewOnly) {
        inputWrapperStyle.width = '0%'
        resizeOperateStyle.display = 'none'
      } else if (!props2.setting.htmlPreview && !props2.setting.preview) {
        inputWrapperStyle.width = '100%'
        resizeOperateStyle.display = 'none'
      } else {
        inputWrapperStyle.width = state.resizedWidth
        resizeOperateStyle.display = 'initial'
      }
    },
    {
      immediate: true
    }
  )
  return {
    inputWrapperStyle,
    resizeOperateStyle
  }
}
const smoothScroll = x()
const Content = /* @__PURE__ */ defineComponent({
  name: 'MDEditorContent',
  props: contentProps,
  setup(props2, ctx) {
    const editorId = inject('editorId')
    const html2 = ref('')
    const contentRef = ref()
    const resizeRef = ref()
    const { inputWrapperRef, codeMirrorUt, resetHistory } = useCodeMirror(props2)
    const { inputWrapperStyle, resizeOperateStyle } = useResize(props2, contentRef, resizeRef)
    useAutoScroll(props2, html2, codeMirrorUt)
    ctx.expose({
      getSelectedText() {
        var _a2
        return (_a2 = codeMirrorUt.value) == null ? void 0 : _a2.getSelectedText()
      },
      focus(options) {
        var _a2
        ;(_a2 = codeMirrorUt.value) == null ? void 0 : _a2.focus(options)
      },
      resetHistory,
      getEditorView() {
        var _a2
        return (_a2 = codeMirrorUt.value) == null ? void 0 : _a2.view
      }
    })
    return () => {
      return createVNode(
        'div',
        {
          class: `${prefix}-content`
        },
        [
          createVNode(
            'div',
            {
              class: `${prefix}-content-wrapper`,
              ref: contentRef
            },
            [
              createVNode(
                'div',
                {
                  class: `${prefix}-input-wrapper`,
                  style: inputWrapperStyle,
                  ref: inputWrapperRef
                },
                null
              ),
              (props2.setting.htmlPreview || props2.setting.preview) &&
                createVNode(
                  'div',
                  {
                    class: `${prefix}-resize-operate`,
                    style: resizeOperateStyle,
                    ref: resizeRef
                  },
                  null
                ),
              createVNode(
                ContentPreview,
                {
                  modelValue: props2.modelValue,
                  onChange: props2.onChange,
                  setting: props2.setting,
                  onHtmlChanged: (html_) => {
                    html2.value = html_
                    props2.onHtmlChanged(html_)
                  },
                  onGetCatalog: props2.onGetCatalog,
                  mdHeadingId: props2.mdHeadingId,
                  noMermaid: props2.noMermaid,
                  sanitize: props2.sanitize,
                  noKatex: props2.noKatex,
                  formatCopiedText: props2.formatCopiedText,
                  noHighlight: props2.noHighlight,
                  noImgZoomIn: props2.noImgZoomIn,
                  sanitizeMermaid: props2.sanitizeMermaid,
                  codeFoldable: props2.codeFoldable,
                  autoFoldThreshold: props2.autoFoldThreshold,
                  onRemount: props2.onRemount
                },
                null
              )
            ]
          ),
          props2.catalogVisible &&
            createVNode(
              MdCatalog,
              {
                theme: props2.theme,
                class: `${prefix}-catalog-editor ${prefix}-catalog-${props2.catalogLayout}`,
                editorId: editorId,
                mdHeadingId: props2.mdHeadingId,
                key: 'internal-catalog',
                scrollElementOffsetTop: 2,
                syncWith: !props2.setting.preview ? 'editor' : 'preview',
                onClick: (e2, toc) => {
                  var _a2, _b
                  if (!props2.setting.preview && toc.line !== void 0) {
                    e2.preventDefault()
                    const view = (_a2 = codeMirrorUt.value) == null ? void 0 : _a2.view
                    if (view) {
                      const line = view.state.doc.line(toc.line + 1)
                      const top2 = (_b = view.lineBlockAt(line.from)) == null ? void 0 : _b.top
                      const scroller = view.scrollDOM
                      smoothScroll(scroller, top2)
                    }
                  }
                },
                catalogMaxDepth: props2.catalogMaxDepth
              },
              null
            )
        ]
      )
    }
  }
})
const MarkdownTotal = /* @__PURE__ */ defineComponent({
  props: {
    modelValue: {
      type: String,
      default: ''
    }
  },
  setup(props2) {
    const ult = inject('usedLanguageText')
    return () => {
      var _a2, _b
      return createVNode(
        'div',
        {
          class: `${prefix}-footer-item`
        },
        [
          createVNode(
            'label',
            {
              class: `${prefix}-footer-label`
            },
            [`${(_a2 = ult.value.footer) == null ? void 0 : _a2.markdownTotal}:`]
          ),
          createVNode('span', null, [((_b = props2.modelValue) == null ? void 0 : _b.length) || 0])
        ]
      )
    }
  }
})
const props$2 = {
  checked: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {}
  },
  disabled: {
    type: Boolean,
    default: void 0
  }
}
const Checkbox = /* @__PURE__ */ defineComponent({
  name: `${prefix}-checkbox`,
  props: props$2,
  setup(props2) {
    return () => {
      return createVNode(
        'div',
        {
          class: [
            `${prefix}-checkbox`,
            props2.checked && `${prefix}-checkbox-checked`,
            props2.disabled && `${prefix}-disabled`
          ],
          onClick: () => {
            if (!props2.disabled) {
              props2.onChange(!props2.checked)
            }
          }
        },
        null
      )
    }
  }
})
const props$1 = {
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {}
  }
}
const ScrollAuto = /* @__PURE__ */ defineComponent({
  props: props$1,
  setup(props2) {
    const ult = inject('usedLanguageText')
    const disabled = inject('disabled')
    return () => {
      var _a2
      return createVNode(
        'div',
        {
          class: [
            `${prefix}-footer-item`,
            (disabled == null ? void 0 : disabled.value) && `${prefix}-disabled`
          ]
        },
        [
          createVNode(
            'label',
            {
              class: `${prefix}-footer-label`,
              onClick: () => {
                props2.onScrollAutoChange(!props2.scrollAuto)
              }
            },
            [(_a2 = ult == null ? void 0 : ult.value.footer) == null ? void 0 : _a2.scrollAuto]
          ),
          createVNode(
            Checkbox,
            {
              checked: props2.scrollAuto,
              onChange: props2.onScrollAutoChange,
              disabled: disabled == null ? void 0 : disabled.value
            },
            null
          )
        ]
      )
    }
  }
})
const props$7 = {
  modelValue: {
    type: String,
    default: ''
  },
  footers: {
    type: Array,
    default: []
  },
  scrollAuto: {
    type: Boolean
  },
  noScrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {}
  },
  defFooters: {
    type: Object
  }
}
const Footer = /* @__PURE__ */ defineComponent({
  name: 'MDEditorFooter',
  props: props$7,
  setup(props2) {
    const theme2 = inject('theme')
    const language2 = inject('language')
    const disabled = inject('disabled')
    const splitedItems = computed(() => {
      const moduleSplitIndex = props2.footers.indexOf('=')
      const barLeft =
        moduleSplitIndex === -1 ? props2.footers : props2.footers.slice(0, moduleSplitIndex)
      const barRight =
        moduleSplitIndex === -1
          ? []
          : props2.footers.slice(moduleSplitIndex, Number.MAX_SAFE_INTEGER)
      return [barLeft, barRight]
    })
    const footerRender = (name2) => {
      var _a2, _b, _c, _d, _e, _f
      if (allFooter.includes(name2)) {
        switch (name2) {
          case 'markdownTotal': {
            return createVNode(
              MarkdownTotal,
              {
                modelValue: props2.modelValue
              },
              null
            )
          }
          case 'scrollSwitch': {
            return (
              !props2.noScrollAuto &&
              createVNode(
                ScrollAuto,
                {
                  scrollAuto: props2.scrollAuto,
                  onScrollAutoChange: props2.onScrollAutoChange
                },
                null
              )
            )
          }
        }
      } else if (props2.defFooters instanceof Array) {
        const defItem = props2.defFooters[name2]
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_a2 = defItem.props) == null ? void 0 : _a2.theme) || theme2.value,
            language: ((_b = defItem.props) == null ? void 0 : _b.language) || language2.value,
            disabled:
              ((_c = defItem.props) == null ? void 0 : _c.disabled) ||
              (disabled == null ? void 0 : disabled.value)
          })
          return defItemCloned
        }
        return ''
      } else if (props2.defFooters && props2.defFooters.children instanceof Array) {
        const defItem = props2.defFooters.children[name2]
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_d = defItem.props) == null ? void 0 : _d.theme) || theme2.value,
            language: ((_e = defItem.props) == null ? void 0 : _e.language) || language2.value,
            disabled:
              ((_f = defItem.props) == null ? void 0 : _f.disabled) ||
              (disabled == null ? void 0 : disabled.value)
          })
          return defItemCloned
        }
        return ''
      } else {
        return ''
      }
    }
    return () => {
      const LeftFooter = splitedItems.value[0].map((name2) => footerRender(name2))
      const RightFooter = splitedItems.value[1].map((name2) => footerRender(name2))
      return createVNode(
        'div',
        {
          class: `${prefix}-footer`
        },
        [
          createVNode(
            'div',
            {
              class: `${prefix}-footer-left`
            },
            [LeftFooter]
          ),
          createVNode(
            'div',
            {
              class: `${prefix}-footer-right`
            },
            [RightFooter]
          )
        ]
      )
    }
  }
})
const Editor = /* @__PURE__ */ defineComponent({
  name: 'MdEditorV3',
  props: editorProps,
  emits: editorEmits,
  setup(props2, ctx) {
    const { noKatex, noMermaid, noPrettier, noUploadImg, noHighlight } = props2
    const state = reactive({
      scrollAuto: props2.scrollAuto
    })
    const rootRef = ref()
    const codeRef = ref()
    const { editorId } = useProvide(props2, rootRef)
    const [setting, updateSetting] = useConfig(props2, ctx, {
      editorId
    })
    const catalogVisible = useCatalog(props2, {
      editorId
    })
    useOnSave(props2, ctx, {
      editorId
    })
    useExpansion(props2)
    useErrorCatcher(props2, ctx, {
      editorId
    })
    useExpose$1(props2, ctx, {
      editorId,
      catalogVisible,
      setting,
      updateSetting,
      codeRef
    })
    onBeforeUnmount(() => {
      bus.clear(editorId)
    })
    return () => {
      const defToolbars = getSlot(
        {
          props: props2,
          ctx
        },
        'defToolbars'
      )
      const defFooters = getSlot(
        {
          props: props2,
          ctx
        },
        'defFooters'
      )
      return createVNode(
        'div',
        {
          id: editorId,
          class: [
            prefix,
            props2.class,
            props2.theme === 'dark' && `${prefix}-dark`,
            setting.fullscreen || setting.pageFullscreen ? `${prefix}-fullscreen` : ''
          ],
          style: props2.style,
          ref: rootRef
        },
        [
          props2.toolbars.length > 0 &&
            createVNode(
              ToolBar,
              {
                noPrettier: noPrettier,
                toolbars: props2.toolbars,
                toolbarsExclude: props2.toolbarsExclude,
                setting: setting,
                updateSetting: updateSetting,
                tableShape: props2.tableShape,
                defToolbars: defToolbars,
                noUploadImg: noUploadImg,
                showToolbarName: props2.showToolbarName,
                catalogVisible: catalogVisible.value,
                codeTheme: props2.codeTheme,
                insertLinkDirect: props2.insertLinkDirect
              },
              null
            ),
          createVNode(
            Content,
            {
              ref: codeRef,
              modelValue: props2.modelValue,
              setting: setting,
              mdHeadingId: props2.mdHeadingId,
              noMermaid: noMermaid,
              noPrettier: noPrettier,
              sanitize: props2.sanitize,
              placeholder: props2.placeholder,
              noKatex: noKatex,
              scrollAuto: state.scrollAuto,
              formatCopiedText: props2.formatCopiedText,
              autofocus: props2.autoFocus,
              disabled: props2.disabled,
              readonly: props2.readOnly,
              maxlength: props2.maxLength,
              autoDetectCode: props2.autoDetectCode,
              noHighlight: noHighlight,
              updateModelValue: (value) => {
                ctx.emit('update:modelValue', value)
              },
              onChange: (value) => {
                var _a2
                ;(_a2 = props2.onChange) == null ? void 0 : _a2.call(props2, value)
                ctx.emit('onChange', value)
              },
              onHtmlChanged: (html2) => {
                var _a2
                ;(_a2 = props2.onHtmlChanged) == null ? void 0 : _a2.call(props2, html2)
                ctx.emit('onHtmlChanged', html2)
              },
              onGetCatalog: (list2) => {
                var _a2
                ;(_a2 = props2.onGetCatalog) == null ? void 0 : _a2.call(props2, list2)
                ctx.emit('onGetCatalog', list2)
              },
              onBlur: (e2) => {
                var _a2
                ;(_a2 = props2.onBlur) == null ? void 0 : _a2.call(props2, e2)
                ctx.emit('onBlur', e2)
              },
              onFocus: (e2) => {
                var _a2
                ;(_a2 = props2.onFocus) == null ? void 0 : _a2.call(props2, e2)
                ctx.emit('onFocus', e2)
              },
              onInput: (e2) => {
                var _a2
                ;(_a2 = props2.onInput) == null ? void 0 : _a2.call(props2, e2)
                ctx.emit('onInput', e2)
              },
              completions: props2.completions,
              catalogVisible: catalogVisible.value,
              theme: props2.theme,
              noImgZoomIn: props2.noImgZoomIn,
              onDrop: (e2) => {
                var _a2
                ;(_a2 = props2.onDrop) == null ? void 0 : _a2.call(props2, e2)
                ctx.emit('onDrop', e2)
              },
              inputBoxWidth: props2.inputBoxWidth,
              oninputBoxWidthChange: (width) => {
                var _a2
                ;(_a2 = props2.oninputBoxWidthChange) == null ? void 0 : _a2.call(props2, width)
                ctx.emit('oninputBoxWidthChange', width)
              },
              sanitizeMermaid: props2.sanitizeMermaid,
              transformImgUrl: props2.transformImgUrl,
              codeFoldable: props2.codeFoldable,
              autoFoldThreshold: props2.autoFoldThreshold,
              onRemount: () => {
                var _a2
                ;(_a2 = props2.onRemount) == null ? void 0 : _a2.call(props2)
                ctx.emit('onRemount')
              },
              catalogLayout: props2.catalogLayout,
              catalogMaxDepth: props2.catalogMaxDepth
            },
            null
          ),
          props2.footers.length > 0 &&
            createVNode(
              Footer,
              {
                modelValue: props2.modelValue,
                footers: props2.footers,
                defFooters: defFooters,
                noScrollAuto: (!setting.preview && !setting.htmlPreview) || setting.previewOnly,
                scrollAuto: state.scrollAuto,
                onScrollAutoChange: (v) => (state.scrollAuto = v)
              },
              null
            )
        ]
      )
    }
  }
})
Editor.install = (app) => {
  app.component(Editor.name, Editor)
  app.use(NormalToolbar).use(DropdownToolbar).use(ModalToolbar).use(MdCatalog).use(MdPreview)
  return app
}
const props = {
  onClick: {
    type: Function,
    default: void 0
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  }
  /**
   * ==结束
   */
}
const NormalFooterToolbar = /* @__PURE__ */ defineComponent({
  name: 'NormalFooterToolbar',
  props,
  emits: ['onClick'],
  setup(props2, ctx) {
    return () => {
      const Children = getSlot({
        props: props2,
        ctx
      })
      return createVNode(
        'div',
        {
          class: [`${prefix}-footer-item`, props2.disabled && `${prefix}-disabled`],
          onClick: (e2) => {
            var _a2
            if (props2.disabled) return
            ;(_a2 = props2.onClick) == null ? void 0 : _a2.call(props2, e2)
            ctx.emit('onClick', e2)
          }
        },
        [Children]
      )
    }
  }
})
NormalFooterToolbar.install = (app) => {
  app.component(NormalFooterToolbar.name, NormalFooterToolbar)
  return app
}
var lib$1 = { exports: {} }
var _default$1 = {}
var lib = { exports: {} }
var _default = {}
function getDefaultWhiteList$1() {
  var whiteList = {}
  whiteList['align-content'] = false
  whiteList['align-items'] = false
  whiteList['align-self'] = false
  whiteList['alignment-adjust'] = false
  whiteList['alignment-baseline'] = false
  whiteList['all'] = false
  whiteList['anchor-point'] = false
  whiteList['animation'] = false
  whiteList['animation-delay'] = false
  whiteList['animation-direction'] = false
  whiteList['animation-duration'] = false
  whiteList['animation-fill-mode'] = false
  whiteList['animation-iteration-count'] = false
  whiteList['animation-name'] = false
  whiteList['animation-play-state'] = false
  whiteList['animation-timing-function'] = false
  whiteList['azimuth'] = false
  whiteList['backface-visibility'] = false
  whiteList['background'] = true
  whiteList['background-attachment'] = true
  whiteList['background-clip'] = true
  whiteList['background-color'] = true
  whiteList['background-image'] = true
  whiteList['background-origin'] = true
  whiteList['background-position'] = true
  whiteList['background-repeat'] = true
  whiteList['background-size'] = true
  whiteList['baseline-shift'] = false
  whiteList['binding'] = false
  whiteList['bleed'] = false
  whiteList['bookmark-label'] = false
  whiteList['bookmark-level'] = false
  whiteList['bookmark-state'] = false
  whiteList['border'] = true
  whiteList['border-bottom'] = true
  whiteList['border-bottom-color'] = true
  whiteList['border-bottom-left-radius'] = true
  whiteList['border-bottom-right-radius'] = true
  whiteList['border-bottom-style'] = true
  whiteList['border-bottom-width'] = true
  whiteList['border-collapse'] = true
  whiteList['border-color'] = true
  whiteList['border-image'] = true
  whiteList['border-image-outset'] = true
  whiteList['border-image-repeat'] = true
  whiteList['border-image-slice'] = true
  whiteList['border-image-source'] = true
  whiteList['border-image-width'] = true
  whiteList['border-left'] = true
  whiteList['border-left-color'] = true
  whiteList['border-left-style'] = true
  whiteList['border-left-width'] = true
  whiteList['border-radius'] = true
  whiteList['border-right'] = true
  whiteList['border-right-color'] = true
  whiteList['border-right-style'] = true
  whiteList['border-right-width'] = true
  whiteList['border-spacing'] = true
  whiteList['border-style'] = true
  whiteList['border-top'] = true
  whiteList['border-top-color'] = true
  whiteList['border-top-left-radius'] = true
  whiteList['border-top-right-radius'] = true
  whiteList['border-top-style'] = true
  whiteList['border-top-width'] = true
  whiteList['border-width'] = true
  whiteList['bottom'] = false
  whiteList['box-decoration-break'] = true
  whiteList['box-shadow'] = true
  whiteList['box-sizing'] = true
  whiteList['box-snap'] = true
  whiteList['box-suppress'] = true
  whiteList['break-after'] = true
  whiteList['break-before'] = true
  whiteList['break-inside'] = true
  whiteList['caption-side'] = false
  whiteList['chains'] = false
  whiteList['clear'] = true
  whiteList['clip'] = false
  whiteList['clip-path'] = false
  whiteList['clip-rule'] = false
  whiteList['color'] = true
  whiteList['color-interpolation-filters'] = true
  whiteList['column-count'] = false
  whiteList['column-fill'] = false
  whiteList['column-gap'] = false
  whiteList['column-rule'] = false
  whiteList['column-rule-color'] = false
  whiteList['column-rule-style'] = false
  whiteList['column-rule-width'] = false
  whiteList['column-span'] = false
  whiteList['column-width'] = false
  whiteList['columns'] = false
  whiteList['contain'] = false
  whiteList['content'] = false
  whiteList['counter-increment'] = false
  whiteList['counter-reset'] = false
  whiteList['counter-set'] = false
  whiteList['crop'] = false
  whiteList['cue'] = false
  whiteList['cue-after'] = false
  whiteList['cue-before'] = false
  whiteList['cursor'] = false
  whiteList['direction'] = false
  whiteList['display'] = true
  whiteList['display-inside'] = true
  whiteList['display-list'] = true
  whiteList['display-outside'] = true
  whiteList['dominant-baseline'] = false
  whiteList['elevation'] = false
  whiteList['empty-cells'] = false
  whiteList['filter'] = false
  whiteList['flex'] = false
  whiteList['flex-basis'] = false
  whiteList['flex-direction'] = false
  whiteList['flex-flow'] = false
  whiteList['flex-grow'] = false
  whiteList['flex-shrink'] = false
  whiteList['flex-wrap'] = false
  whiteList['float'] = false
  whiteList['float-offset'] = false
  whiteList['flood-color'] = false
  whiteList['flood-opacity'] = false
  whiteList['flow-from'] = false
  whiteList['flow-into'] = false
  whiteList['font'] = true
  whiteList['font-family'] = true
  whiteList['font-feature-settings'] = true
  whiteList['font-kerning'] = true
  whiteList['font-language-override'] = true
  whiteList['font-size'] = true
  whiteList['font-size-adjust'] = true
  whiteList['font-stretch'] = true
  whiteList['font-style'] = true
  whiteList['font-synthesis'] = true
  whiteList['font-variant'] = true
  whiteList['font-variant-alternates'] = true
  whiteList['font-variant-caps'] = true
  whiteList['font-variant-east-asian'] = true
  whiteList['font-variant-ligatures'] = true
  whiteList['font-variant-numeric'] = true
  whiteList['font-variant-position'] = true
  whiteList['font-weight'] = true
  whiteList['grid'] = false
  whiteList['grid-area'] = false
  whiteList['grid-auto-columns'] = false
  whiteList['grid-auto-flow'] = false
  whiteList['grid-auto-rows'] = false
  whiteList['grid-column'] = false
  whiteList['grid-column-end'] = false
  whiteList['grid-column-start'] = false
  whiteList['grid-row'] = false
  whiteList['grid-row-end'] = false
  whiteList['grid-row-start'] = false
  whiteList['grid-template'] = false
  whiteList['grid-template-areas'] = false
  whiteList['grid-template-columns'] = false
  whiteList['grid-template-rows'] = false
  whiteList['hanging-punctuation'] = false
  whiteList['height'] = true
  whiteList['hyphens'] = false
  whiteList['icon'] = false
  whiteList['image-orientation'] = false
  whiteList['image-resolution'] = false
  whiteList['ime-mode'] = false
  whiteList['initial-letters'] = false
  whiteList['inline-box-align'] = false
  whiteList['justify-content'] = false
  whiteList['justify-items'] = false
  whiteList['justify-self'] = false
  whiteList['left'] = false
  whiteList['letter-spacing'] = true
  whiteList['lighting-color'] = true
  whiteList['line-box-contain'] = false
  whiteList['line-break'] = false
  whiteList['line-grid'] = false
  whiteList['line-height'] = false
  whiteList['line-snap'] = false
  whiteList['line-stacking'] = false
  whiteList['line-stacking-ruby'] = false
  whiteList['line-stacking-shift'] = false
  whiteList['line-stacking-strategy'] = false
  whiteList['list-style'] = true
  whiteList['list-style-image'] = true
  whiteList['list-style-position'] = true
  whiteList['list-style-type'] = true
  whiteList['margin'] = true
  whiteList['margin-bottom'] = true
  whiteList['margin-left'] = true
  whiteList['margin-right'] = true
  whiteList['margin-top'] = true
  whiteList['marker-offset'] = false
  whiteList['marker-side'] = false
  whiteList['marks'] = false
  whiteList['mask'] = false
  whiteList['mask-box'] = false
  whiteList['mask-box-outset'] = false
  whiteList['mask-box-repeat'] = false
  whiteList['mask-box-slice'] = false
  whiteList['mask-box-source'] = false
  whiteList['mask-box-width'] = false
  whiteList['mask-clip'] = false
  whiteList['mask-image'] = false
  whiteList['mask-origin'] = false
  whiteList['mask-position'] = false
  whiteList['mask-repeat'] = false
  whiteList['mask-size'] = false
  whiteList['mask-source-type'] = false
  whiteList['mask-type'] = false
  whiteList['max-height'] = true
  whiteList['max-lines'] = false
  whiteList['max-width'] = true
  whiteList['min-height'] = true
  whiteList['min-width'] = true
  whiteList['move-to'] = false
  whiteList['nav-down'] = false
  whiteList['nav-index'] = false
  whiteList['nav-left'] = false
  whiteList['nav-right'] = false
  whiteList['nav-up'] = false
  whiteList['object-fit'] = false
  whiteList['object-position'] = false
  whiteList['opacity'] = false
  whiteList['order'] = false
  whiteList['orphans'] = false
  whiteList['outline'] = false
  whiteList['outline-color'] = false
  whiteList['outline-offset'] = false
  whiteList['outline-style'] = false
  whiteList['outline-width'] = false
  whiteList['overflow'] = false
  whiteList['overflow-wrap'] = false
  whiteList['overflow-x'] = false
  whiteList['overflow-y'] = false
  whiteList['padding'] = true
  whiteList['padding-bottom'] = true
  whiteList['padding-left'] = true
  whiteList['padding-right'] = true
  whiteList['padding-top'] = true
  whiteList['page'] = false
  whiteList['page-break-after'] = false
  whiteList['page-break-before'] = false
  whiteList['page-break-inside'] = false
  whiteList['page-policy'] = false
  whiteList['pause'] = false
  whiteList['pause-after'] = false
  whiteList['pause-before'] = false
  whiteList['perspective'] = false
  whiteList['perspective-origin'] = false
  whiteList['pitch'] = false
  whiteList['pitch-range'] = false
  whiteList['play-during'] = false
  whiteList['position'] = false
  whiteList['presentation-level'] = false
  whiteList['quotes'] = false
  whiteList['region-fragment'] = false
  whiteList['resize'] = false
  whiteList['rest'] = false
  whiteList['rest-after'] = false
  whiteList['rest-before'] = false
  whiteList['richness'] = false
  whiteList['right'] = false
  whiteList['rotation'] = false
  whiteList['rotation-point'] = false
  whiteList['ruby-align'] = false
  whiteList['ruby-merge'] = false
  whiteList['ruby-position'] = false
  whiteList['shape-image-threshold'] = false
  whiteList['shape-outside'] = false
  whiteList['shape-margin'] = false
  whiteList['size'] = false
  whiteList['speak'] = false
  whiteList['speak-as'] = false
  whiteList['speak-header'] = false
  whiteList['speak-numeral'] = false
  whiteList['speak-punctuation'] = false
  whiteList['speech-rate'] = false
  whiteList['stress'] = false
  whiteList['string-set'] = false
  whiteList['tab-size'] = false
  whiteList['table-layout'] = false
  whiteList['text-align'] = true
  whiteList['text-align-last'] = true
  whiteList['text-combine-upright'] = true
  whiteList['text-decoration'] = true
  whiteList['text-decoration-color'] = true
  whiteList['text-decoration-line'] = true
  whiteList['text-decoration-skip'] = true
  whiteList['text-decoration-style'] = true
  whiteList['text-emphasis'] = true
  whiteList['text-emphasis-color'] = true
  whiteList['text-emphasis-position'] = true
  whiteList['text-emphasis-style'] = true
  whiteList['text-height'] = true
  whiteList['text-indent'] = true
  whiteList['text-justify'] = true
  whiteList['text-orientation'] = true
  whiteList['text-overflow'] = true
  whiteList['text-shadow'] = true
  whiteList['text-space-collapse'] = true
  whiteList['text-transform'] = true
  whiteList['text-underline-position'] = true
  whiteList['text-wrap'] = true
  whiteList['top'] = false
  whiteList['transform'] = false
  whiteList['transform-origin'] = false
  whiteList['transform-style'] = false
  whiteList['transition'] = false
  whiteList['transition-delay'] = false
  whiteList['transition-duration'] = false
  whiteList['transition-property'] = false
  whiteList['transition-timing-function'] = false
  whiteList['unicode-bidi'] = false
  whiteList['vertical-align'] = false
  whiteList['visibility'] = false
  whiteList['voice-balance'] = false
  whiteList['voice-duration'] = false
  whiteList['voice-family'] = false
  whiteList['voice-pitch'] = false
  whiteList['voice-range'] = false
  whiteList['voice-rate'] = false
  whiteList['voice-stress'] = false
  whiteList['voice-volume'] = false
  whiteList['volume'] = false
  whiteList['white-space'] = false
  whiteList['widows'] = false
  whiteList['width'] = true
  whiteList['will-change'] = false
  whiteList['word-break'] = true
  whiteList['word-spacing'] = true
  whiteList['word-wrap'] = true
  whiteList['wrap-flow'] = false
  whiteList['wrap-through'] = false
  whiteList['writing-mode'] = false
  whiteList['z-index'] = false
  return whiteList
}
function onAttr(name2, value, options) {}
function onIgnoreAttr(name2, value, options) {}
var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/gim
function safeAttrValue$1(name2, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value)) return ''
  return value
}
_default.whiteList = getDefaultWhiteList$1()
_default.getDefaultWhiteList = getDefaultWhiteList$1
_default.onAttr = onAttr
_default.onIgnoreAttr = onIgnoreAttr
_default.safeAttrValue = safeAttrValue$1
var util$1 = {
  indexOf: function (arr, item) {
    var i, j
    if (Array.prototype.indexOf) {
      return arr.indexOf(item)
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i
      }
    }
    return -1
  },
  forEach: function (arr, fn, scope) {
    var i, j
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope)
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr)
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim()
    }
    return str.replace(/(^\s*)|(\s*$)/g, '')
  },
  trimRight: function (str) {
    if (String.prototype.trimRight) {
      return str.trimRight()
    }
    return str.replace(/(\s*$)/g, '')
  }
}
var _$3 = util$1
function parseStyle$1(css2, onAttr2) {
  css2 = _$3.trimRight(css2)
  if (css2[css2.length - 1] !== ';') css2 += ';'
  var cssLength = css2.length
  var isParenthesisOpen = false
  var lastPos = 0
  var i = 0
  var retCSS = ''
  function addNewAttr() {
    if (!isParenthesisOpen) {
      var source = _$3.trim(css2.slice(lastPos, i))
      var j2 = source.indexOf(':')
      if (j2 !== -1) {
        var name2 = _$3.trim(source.slice(0, j2))
        var value = _$3.trim(source.slice(j2 + 1))
        if (name2) {
          var ret = onAttr2(lastPos, retCSS.length, name2, value, source)
          if (ret) retCSS += ret + '; '
        }
      }
    }
    lastPos = i + 1
  }
  for (; i < cssLength; i++) {
    var c2 = css2[i]
    if (c2 === '/' && css2[i + 1] === '*') {
      var j = css2.indexOf('*/', i + 2)
      if (j === -1) break
      i = j + 1
      lastPos = i + 1
      isParenthesisOpen = false
    } else if (c2 === '(') {
      isParenthesisOpen = true
    } else if (c2 === ')') {
      isParenthesisOpen = false
    } else if (c2 === ';') {
      if (isParenthesisOpen);
      else {
        addNewAttr()
      }
    } else if (c2 === '\n') {
      addNewAttr()
    }
  }
  return _$3.trim(retCSS)
}
var parser$2 = parseStyle$1
var DEFAULT$1 = _default
var parseStyle = parser$2
function isNull$1(obj) {
  return obj === void 0 || obj === null
}
function shallowCopyObject$1(obj) {
  var ret = {}
  for (var i in obj) {
    ret[i] = obj[i]
  }
  return ret
}
function FilterCSS$2(options) {
  options = shallowCopyObject$1(options || {})
  options.whiteList = options.whiteList || DEFAULT$1.whiteList
  options.onAttr = options.onAttr || DEFAULT$1.onAttr
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr
  options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue
  this.options = options
}
FilterCSS$2.prototype.process = function (css2) {
  css2 = css2 || ''
  css2 = css2.toString()
  if (!css2) return ''
  var me = this
  var options = me.options
  var whiteList = options.whiteList
  var onAttr2 = options.onAttr
  var onIgnoreAttr2 = options.onIgnoreAttr
  var safeAttrValue2 = options.safeAttrValue
  var retCSS = parseStyle(css2, function (sourcePosition, position, name2, value, source) {
    var check = whiteList[name2]
    var isWhite = false
    if (check === true) isWhite = check
    else if (typeof check === 'function') isWhite = check(value)
    else if (check instanceof RegExp) isWhite = check.test(value)
    if (isWhite !== true) isWhite = false
    value = safeAttrValue2(name2, value)
    if (!value) return
    var opts = {
      position,
      sourcePosition,
      source,
      isWhite
    }
    if (isWhite) {
      var ret = onAttr2(name2, value, opts)
      if (isNull$1(ret)) {
        return name2 + ':' + value
      } else {
        return ret
      }
    } else {
      var ret = onIgnoreAttr2(name2, value, opts)
      if (!isNull$1(ret)) {
        return ret
      }
    }
  })
  return retCSS
}
var css = FilterCSS$2
;(function (module, exports) {
  var DEFAULT2 = _default
  var FilterCSS2 = css
  function filterCSS(html2, options) {
    var xss2 = new FilterCSS2(options)
    return xss2.process(html2)
  }
  exports = module.exports = filterCSS
  exports.FilterCSS = FilterCSS2
  for (var i in DEFAULT2) exports[i] = DEFAULT2[i]
  if (typeof window !== 'undefined') {
    window.filterCSS = module.exports
  }
})(lib, lib.exports)
var libExports$1 = lib.exports
var util = {
  indexOf: function (arr, item) {
    var i, j
    if (Array.prototype.indexOf) {
      return arr.indexOf(item)
    }
    for (i = 0, j = arr.length; i < j; i++) {
      if (arr[i] === item) {
        return i
      }
    }
    return -1
  },
  forEach: function (arr, fn, scope) {
    var i, j
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope)
    }
    for (i = 0, j = arr.length; i < j; i++) {
      fn.call(scope, arr[i], i, arr)
    }
  },
  trim: function (str) {
    if (String.prototype.trim) {
      return str.trim()
    }
    return str.replace(/(^\s*)|(\s*$)/g, '')
  },
  spaceIndex: function (str) {
    var reg = /\s|\n|\t/
    var match2 = reg.exec(str)
    return match2 ? match2.index : -1
  }
}
var FilterCSS$1 = libExports$1.FilterCSS
var getDefaultCSSWhiteList = libExports$1.getDefaultWhiteList
var _$2 = util
function getDefaultWhiteList() {
  return {
    a: ['target', 'href', 'title'],
    abbr: ['title'],
    address: [],
    area: ['shape', 'coords', 'href', 'alt'],
    article: [],
    aside: [],
    audio: ['autoplay', 'controls', 'crossorigin', 'loop', 'muted', 'preload', 'src'],
    b: [],
    bdi: ['dir'],
    bdo: ['dir'],
    big: [],
    blockquote: ['cite'],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ['align', 'valign', 'span', 'width'],
    colgroup: ['align', 'valign', 'span', 'width'],
    dd: [],
    del: ['datetime'],
    details: ['open'],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ['color', 'size', 'face'],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height', 'loading'],
    ins: ['datetime'],
    kbd: [],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ['width', 'border', 'align', 'valign'],
    tbody: ['align', 'valign'],
    td: ['width', 'rowspan', 'colspan', 'align', 'valign'],
    tfoot: ['align', 'valign'],
    th: ['width', 'rowspan', 'colspan', 'align', 'valign'],
    thead: ['align', 'valign'],
    tr: ['rowspan', 'align', 'valign'],
    tt: [],
    u: [],
    ul: [],
    video: [
      'autoplay',
      'controls',
      'crossorigin',
      'loop',
      'muted',
      'playsinline',
      'poster',
      'preload',
      'src',
      'height',
      'width'
    ]
  }
}
var defaultCSSFilter = new FilterCSS$1()
function onTag(tag, html2, options) {}
function onIgnoreTag(tag, html2, options) {}
function onTagAttr(tag, name2, value) {}
function onIgnoreTagAttr(tag, name2, value) {}
function escapeHtml(html2) {
  return html2.replace(REGEXP_LT, '&lt;').replace(REGEXP_GT, '&gt;')
}
function safeAttrValue(tag, name2, value, cssFilter) {
  value = friendlyAttrValue(value)
  if (name2 === 'href' || name2 === 'src') {
    value = _$2.trim(value)
    if (value === '#') return '#'
    if (
      !(
        value.substr(0, 7) === 'http://' ||
        value.substr(0, 8) === 'https://' ||
        value.substr(0, 7) === 'mailto:' ||
        value.substr(0, 4) === 'tel:' ||
        value.substr(0, 11) === 'data:image/' ||
        value.substr(0, 6) === 'ftp://' ||
        value.substr(0, 2) === './' ||
        value.substr(0, 3) === '../' ||
        value[0] === '#' ||
        value[0] === '/'
      )
    ) {
      return ''
    }
  } else if (name2 === 'background') {
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return ''
    }
  } else if (name2 === 'style') {
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return ''
    }
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return ''
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter
      value = cssFilter.process(value)
    }
  }
  value = escapeAttrValue(value)
  return value
}
var REGEXP_LT = /</g
var REGEXP_GT = />/g
var REGEXP_QUOTE = /"/g
var REGEXP_QUOTE_2 = /&quot;/g
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim
var REGEXP_DEFAULT_ON_TAG_ATTR_4 =
  /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi
var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, '&quot;')
}
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"')
}
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
    return code[0] === 'x' || code[0] === 'X'
      ? String.fromCharCode(parseInt(code.substr(1), 16))
      : String.fromCharCode(parseInt(code, 10))
  })
}
function escapeDangerHtml5Entities(str) {
  return str.replace(REGEXP_ATTR_VALUE_COLON, ':').replace(REGEXP_ATTR_VALUE_NEWLINE, ' ')
}
function clearNonPrintableCharacter(str) {
  var str2 = ''
  for (var i = 0, len = str.length; i < len; i++) {
    str2 += str.charCodeAt(i) < 32 ? ' ' : str.charAt(i)
  }
  return _$2.trim(str2)
}
function friendlyAttrValue(str) {
  str = unescapeQuote(str)
  str = escapeHtmlEntities(str)
  str = escapeDangerHtml5Entities(str)
  str = clearNonPrintableCharacter(str)
  return str
}
function escapeAttrValue(str) {
  str = escapeQuote(str)
  str = escapeHtml(str)
  return str
}
function onIgnoreTagStripAll() {
  return ''
}
function StripTagBody(tags2, next) {
  if (typeof next !== 'function') {
    next = function () {}
  }
  var isRemoveAllTag = !Array.isArray(tags2)
  function isRemoveTag(tag) {
    if (isRemoveAllTag) return true
    return _$2.indexOf(tags2, tag) !== -1
  }
  var removeList = []
  var posStart = false
  return {
    onIgnoreTag: function (tag, html2, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = '[/removed]'
          var end = options.position + ret.length
          removeList.push([posStart !== false ? posStart : options.position, end])
          posStart = false
          return ret
        } else {
          if (!posStart) {
            posStart = options.position
          }
          return '[removed]'
        }
      } else {
        return next(tag, html2, options)
      }
    },
    remove: function (html2) {
      var rethtml = ''
      var lastPos = 0
      _$2.forEach(removeList, function (pos) {
        rethtml += html2.slice(lastPos, pos[0])
        lastPos = pos[1]
      })
      rethtml += html2.slice(lastPos)
      return rethtml
    }
  }
}
function stripCommentTag(html2) {
  var retHtml = ''
  var lastPos = 0
  while (lastPos < html2.length) {
    var i = html2.indexOf('<!--', lastPos)
    if (i === -1) {
      retHtml += html2.slice(lastPos)
      break
    }
    retHtml += html2.slice(lastPos, i)
    var j = html2.indexOf('-->', i)
    if (j === -1) {
      break
    }
    lastPos = j + 3
  }
  return retHtml
}
function stripBlankChar(html2) {
  var chars = html2.split('')
  chars = chars.filter(function (char) {
    var c2 = char.charCodeAt(0)
    if (c2 === 127) return false
    if (c2 <= 31) {
      if (c2 === 10 || c2 === 13) return true
      return false
    }
    return true
  })
  return chars.join('')
}
_default$1.whiteList = getDefaultWhiteList()
_default$1.getDefaultWhiteList = getDefaultWhiteList
_default$1.onTag = onTag
_default$1.onIgnoreTag = onIgnoreTag
_default$1.onTagAttr = onTagAttr
_default$1.onIgnoreTagAttr = onIgnoreTagAttr
_default$1.safeAttrValue = safeAttrValue
_default$1.escapeHtml = escapeHtml
_default$1.escapeQuote = escapeQuote
_default$1.unescapeQuote = unescapeQuote
_default$1.escapeHtmlEntities = escapeHtmlEntities
_default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities
_default$1.clearNonPrintableCharacter = clearNonPrintableCharacter
_default$1.friendlyAttrValue = friendlyAttrValue
_default$1.escapeAttrValue = escapeAttrValue
_default$1.onIgnoreTagStripAll = onIgnoreTagStripAll
_default$1.StripTagBody = StripTagBody
_default$1.stripCommentTag = stripCommentTag
_default$1.stripBlankChar = stripBlankChar
_default$1.attributeWrapSign = '"'
_default$1.cssFilter = defaultCSSFilter
_default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList
var parser$1 = {}
var _$1 = util
function getTagName(html2) {
  var i = _$1.spaceIndex(html2)
  var tagName
  if (i === -1) {
    tagName = html2.slice(1, -1)
  } else {
    tagName = html2.slice(1, i + 1)
  }
  tagName = _$1.trim(tagName).toLowerCase()
  if (tagName.slice(0, 1) === '/') tagName = tagName.slice(1)
  if (tagName.slice(-1) === '/') tagName = tagName.slice(0, -1)
  return tagName
}
function isClosing(html2) {
  return html2.slice(0, 2) === '</'
}
function parseTag$1(html2, onTag2, escapeHtml2) {
  var rethtml = ''
  var lastPos = 0
  var tagStart2 = false
  var quoteStart = false
  var currentPos = 0
  var len = html2.length
  var currentTagName = ''
  var currentHtml = ''
  chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
    var c2 = html2.charAt(currentPos)
    if (tagStart2 === false) {
      if (c2 === '<') {
        tagStart2 = currentPos
        continue
      }
    } else {
      if (quoteStart === false) {
        if (c2 === '<') {
          rethtml += escapeHtml2(html2.slice(lastPos, currentPos))
          tagStart2 = currentPos
          lastPos = currentPos
          continue
        }
        if (c2 === '>' || currentPos === len - 1) {
          rethtml += escapeHtml2(html2.slice(lastPos, tagStart2))
          currentHtml = html2.slice(tagStart2, currentPos + 1)
          currentTagName = getTagName(currentHtml)
          rethtml += onTag2(
            tagStart2,
            rethtml.length,
            currentTagName,
            currentHtml,
            isClosing(currentHtml)
          )
          lastPos = currentPos + 1
          tagStart2 = false
          continue
        }
        if (c2 === '"' || c2 === "'") {
          var i = 1
          var ic = html2.charAt(currentPos - i)
          while (ic.trim() === '' || ic === '=') {
            if (ic === '=') {
              quoteStart = c2
              continue chariterator
            }
            ic = html2.charAt(currentPos - ++i)
          }
        }
      } else {
        if (c2 === quoteStart) {
          quoteStart = false
          continue
        }
      }
    }
  }
  if (lastPos < len) {
    rethtml += escapeHtml2(html2.substr(lastPos))
  }
  return rethtml
}
var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim
function parseAttr$1(html2, onAttr2) {
  var lastPos = 0
  var lastMarkPos = 0
  var retAttrs = []
  var tmpName = false
  var len = html2.length
  function addAttr(name2, value) {
    name2 = _$1.trim(name2)
    name2 = name2.replace(REGEXP_ILLEGAL_ATTR_NAME, '').toLowerCase()
    if (name2.length < 1) return
    var ret = onAttr2(name2, value || '')
    if (ret) retAttrs.push(ret)
  }
  for (var i = 0; i < len; i++) {
    var c2 = html2.charAt(i)
    var v, j
    if (tmpName === false && c2 === '=') {
      tmpName = html2.slice(lastPos, i)
      lastPos = i + 1
      lastMarkPos =
        html2.charAt(lastPos) === '"' || html2.charAt(lastPos) === "'"
          ? lastPos
          : findNextQuotationMark(html2, i + 1)
      continue
    }
    if (tmpName !== false) {
      if (i === lastMarkPos) {
        j = html2.indexOf(c2, i + 1)
        if (j === -1) {
          break
        } else {
          v = _$1.trim(html2.slice(lastMarkPos + 1, j))
          addAttr(tmpName, v)
          tmpName = false
          i = j
          lastPos = i + 1
          continue
        }
      }
    }
    if (/\s|\n|\t/.test(c2)) {
      html2 = html2.replace(/\s|\n|\t/g, ' ')
      if (tmpName === false) {
        j = findNextEqual(html2, i)
        if (j === -1) {
          v = _$1.trim(html2.slice(lastPos, i))
          addAttr(v)
          tmpName = false
          lastPos = i + 1
          continue
        } else {
          i = j - 1
          continue
        }
      } else {
        j = findBeforeEqual(html2, i - 1)
        if (j === -1) {
          v = _$1.trim(html2.slice(lastPos, i))
          v = stripQuoteWrap(v)
          addAttr(tmpName, v)
          tmpName = false
          lastPos = i + 1
          continue
        } else {
          continue
        }
      }
    }
  }
  if (lastPos < html2.length) {
    if (tmpName === false) {
      addAttr(html2.slice(lastPos))
    } else {
      addAttr(tmpName, stripQuoteWrap(_$1.trim(html2.slice(lastPos))))
    }
  }
  return _$1.trim(retAttrs.join(' '))
}
function findNextEqual(str, i) {
  for (; i < str.length; i++) {
    var c2 = str[i]
    if (c2 === ' ') continue
    if (c2 === '=') return i
    return -1
  }
}
function findNextQuotationMark(str, i) {
  for (; i < str.length; i++) {
    var c2 = str[i]
    if (c2 === ' ') continue
    if (c2 === "'" || c2 === '"') return i
    return -1
  }
}
function findBeforeEqual(str, i) {
  for (; i > 0; i--) {
    var c2 = str[i]
    if (c2 === ' ') continue
    if (c2 === '=') return i
    return -1
  }
}
function isQuoteWrapString(text2) {
  if (
    (text2[0] === '"' && text2[text2.length - 1] === '"') ||
    (text2[0] === "'" && text2[text2.length - 1] === "'")
  ) {
    return true
  } else {
    return false
  }
}
function stripQuoteWrap(text2) {
  if (isQuoteWrapString(text2)) {
    return text2.substr(1, text2.length - 2)
  } else {
    return text2
  }
}
parser$1.parseTag = parseTag$1
parser$1.parseAttr = parseAttr$1
var FilterCSS = libExports$1.FilterCSS
var DEFAULT = _default$1
var parser = parser$1
var parseTag = parser.parseTag
var parseAttr = parser.parseAttr
var _ = util
function isNull(obj) {
  return obj === void 0 || obj === null
}
function getAttrs(html2) {
  var i = _.spaceIndex(html2)
  if (i === -1) {
    return {
      html: '',
      closing: html2[html2.length - 2] === '/'
    }
  }
  html2 = _.trim(html2.slice(i + 1, -1))
  var isClosing2 = html2[html2.length - 1] === '/'
  if (isClosing2) html2 = _.trim(html2.slice(0, -1))
  return {
    html: html2,
    closing: isClosing2
  }
}
function shallowCopyObject(obj) {
  var ret = {}
  for (var i in obj) {
    ret[i] = obj[i]
  }
  return ret
}
function keysToLowerCase(obj) {
  var ret = {}
  for (var i in obj) {
    if (Array.isArray(obj[i])) {
      ret[i.toLowerCase()] = obj[i].map(function (item) {
        return item.toLowerCase()
      })
    } else {
      ret[i.toLowerCase()] = obj[i]
    }
  }
  return ret
}
function FilterXSS(options) {
  options = shallowCopyObject(options || {})
  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error(
        'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
      )
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll
  }
  if (options.whiteList || options.allowList) {
    options.whiteList = keysToLowerCase(options.whiteList || options.allowList)
  } else {
    options.whiteList = DEFAULT.whiteList
  }
  this.attributeWrapSign =
    options.singleQuotedAttributeValue === true ? "'" : DEFAULT.attributeWrapSign
  options.onTag = options.onTag || DEFAULT.onTag
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml
  this.options = options
  if (options.css === false) {
    this.cssFilter = false
  } else {
    options.css = options.css || {}
    this.cssFilter = new FilterCSS(options.css)
  }
}
FilterXSS.prototype.process = function (html2) {
  html2 = html2 || ''
  html2 = html2.toString()
  if (!html2) return ''
  var me = this
  var options = me.options
  var whiteList = options.whiteList
  var onTag2 = options.onTag
  var onIgnoreTag2 = options.onIgnoreTag
  var onTagAttr2 = options.onTagAttr
  var onIgnoreTagAttr2 = options.onIgnoreTagAttr
  var safeAttrValue2 = options.safeAttrValue
  var escapeHtml2 = options.escapeHtml
  var attributeWrapSign = me.attributeWrapSign
  var cssFilter = me.cssFilter
  if (options.stripBlankChar) {
    html2 = DEFAULT.stripBlankChar(html2)
  }
  if (!options.allowCommentTag) {
    html2 = DEFAULT.stripCommentTag(html2)
  }
  var stripIgnoreTagBody = false
  if (options.stripIgnoreTagBody) {
    stripIgnoreTagBody = DEFAULT.StripTagBody(options.stripIgnoreTagBody, onIgnoreTag2)
    onIgnoreTag2 = stripIgnoreTagBody.onIgnoreTag
  }
  var retHtml = parseTag(
    html2,
    function (sourcePosition, position, tag, html22, isClosing2) {
      var info = {
        sourcePosition,
        position,
        isClosing: isClosing2,
        isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
      }
      var ret = onTag2(tag, html22, info)
      if (!isNull(ret)) return ret
      if (info.isWhite) {
        if (info.isClosing) {
          return '</' + tag + '>'
        }
        var attrs = getAttrs(html22)
        var whiteAttrList = whiteList[tag]
        var attrsHtml = parseAttr(attrs.html, function (name2, value) {
          var isWhiteAttr = _.indexOf(whiteAttrList, name2) !== -1
          var ret2 = onTagAttr2(tag, name2, value, isWhiteAttr)
          if (!isNull(ret2)) return ret2
          if (isWhiteAttr) {
            value = safeAttrValue2(tag, name2, value, cssFilter)
            if (value) {
              return name2 + '=' + attributeWrapSign + value + attributeWrapSign
            } else {
              return name2
            }
          } else {
            ret2 = onIgnoreTagAttr2(tag, name2, value, isWhiteAttr)
            if (!isNull(ret2)) return ret2
            return
          }
        })
        html22 = '<' + tag
        if (attrsHtml) html22 += ' ' + attrsHtml
        if (attrs.closing) html22 += ' /'
        html22 += '>'
        return html22
      } else {
        ret = onIgnoreTag2(tag, html22, info)
        if (!isNull(ret)) return ret
        return escapeHtml2(html22)
      }
    },
    escapeHtml2
  )
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml)
  }
  return retHtml
}
var xss$1 = FilterXSS
;(function (module, exports) {
  var DEFAULT2 = _default$1
  var parser2 = parser$1
  var FilterXSS2 = xss$1
  function filterXSS(html2, options) {
    var xss2 = new FilterXSS2(options)
    return xss2.process(html2)
  }
  exports = module.exports = filterXSS
  exports.filterXSS = filterXSS
  exports.FilterXSS = FilterXSS2
  ;(function () {
    for (var i in DEFAULT2) {
      exports[i] = DEFAULT2[i]
    }
    for (var j in parser2) {
      exports[j] = parser2[j]
    }
  })()
  if (typeof window !== 'undefined') {
    window.filterXSS = module.exports
  }
  function isWorkerEnv() {
    return (
      typeof self !== 'undefined' &&
      typeof DedicatedWorkerGlobalScope !== 'undefined' &&
      self instanceof DedicatedWorkerGlobalScope
    )
  }
  if (isWorkerEnv()) {
    self.filterXSS = module.exports
  }
})(lib$1, lib$1.exports)
export {
  ContextTracker as C,
  Editor as E,
  IterMode as I,
  LRLanguage as L,
  MdPreview as M,
  NodeWeakMap as N,
  LRParser as a,
  LanguageSupport as b,
  continuedIndent as c,
  ExternalTokenizer as d,
  ifNotIn as e,
  foldNodeProp as f,
  completeFromList as g,
  syntaxTree as h,
  indentNodeProp as i,
  delimitedIndent as j,
  flatIndent as k,
  foldInside as l,
  LocalTokenGroup as m,
  snippetCompletion as n,
  defineCSSCompletionSource as o,
  EditorView as p,
  EditorSelection as q,
  html as r,
  styleTags as s,
  tags$1 as t,
  parseMixed as u,
  bracketMatchingHandle as v,
  javascriptLanguage as w
}
