# Why-Talk 插件数据存储设计方案

## 概述

本文档设计了通讯录插件和消息插件如何使用本地Electron的SQLite数据库进行数据存储，实现插件间数据共享，同时保留原有功能特性。

## 设计目标

1. **数据共享**: 通讯录插件与消息插件共用同一份联系人数据缓存
2. **功能保留**: 保留联系人置顶、消息历史记录、文件传输等交互
3. **架构清晰**: 插件与主应用数据层分离，通过统一的API接口访问
4. **性能优化**: 利用SQLite的事务和索引机制提升性能
5. **扩展性**: 支持未来更多插件的数据存储需求

## 整体架构

```
┌─────────────────┐    ┌─────────────────┐
│   通讯录插件     │    │    消息插件      │
└─────────────────┘    └─────────────────┘
         │                       │
         └───────────┬───────────┘
                     │
         ┌─────────────────────────┐
         │    插件数据API层        │
         │  (PluginDataService)   │
         └─────────────────────────┘
                     │
         ┌─────────────────────────┐
         │    主进程数据服务       │
         │  (DatabaseManager)     │
         └─────────────────────────┘
                     │
         ┌─────────────────────────┐
         │     SQLite数据库       │
         │   (why-talk.db)        │
         └─────────────────────────┘
```

## 数据库表结构扩展

### 1. 插件数据表

```sql
-- 插件数据存储表
CREATE TABLE IF NOT EXISTS plugin_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    plugin_id VARCHAR(100) NOT NULL,
    data_key VARCHAR(200) NOT NULL,
    data_value TEXT,
    data_type VARCHAR(50) DEFAULT 'string', -- string, json, number, boolean
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(plugin_id, data_key)
);

-- 插件共享数据表（用于插件间数据共享）
CREATE TABLE IF NOT EXISTS plugin_shared_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    namespace VARCHAR(100) NOT NULL, -- 数据命名空间，如 'contacts', 'messages'
    data_key VARCHAR(200) NOT NULL,
    data_value TEXT,
    data_type VARCHAR(50) DEFAULT 'string',
    owner_plugin VARCHAR(100), -- 数据所有者插件
    permissions TEXT, -- JSON格式的权限配置
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(namespace, data_key)
);

-- 联系人扩展数据表（插件特定的联系人数据）
CREATE TABLE IF NOT EXISTS contact_plugin_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    contact_id INTEGER NOT NULL, -- 关联contacts表的id
    plugin_id VARCHAR(100) NOT NULL,
    data_key VARCHAR(200) NOT NULL,
    data_value TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (contact_id) REFERENCES contacts(id),
    UNIQUE(contact_id, plugin_id, data_key)
);

-- 消息扩展数据表（插件特定的消息数据）
CREATE TABLE IF NOT EXISTS message_plugin_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id INTEGER NOT NULL, -- 关联messages表的id
    plugin_id VARCHAR(100) NOT NULL,
    data_key VARCHAR(200) NOT NULL,
    data_value TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (message_id) REFERENCES messages(id),
    UNIQUE(message_id, plugin_id, data_key)
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_plugin_data_plugin_id ON plugin_data(plugin_id);
CREATE INDEX IF NOT EXISTS idx_plugin_shared_data_namespace ON plugin_shared_data(namespace);
CREATE INDEX IF NOT EXISTS idx_contact_plugin_data_contact_id ON contact_plugin_data(contact_id);
CREATE INDEX IF NOT EXISTS idx_message_plugin_data_message_id ON message_plugin_data(message_id);
```

### 2. 现有表结构优化

```sql
-- 为contacts表添加插件相关字段
ALTER TABLE contacts ADD COLUMN is_pinned INTEGER DEFAULT 0; -- 联系人置顶
ALTER TABLE contacts ADD COLUMN plugin_source VARCHAR(100) DEFAULT ''; -- 插件来源
ALTER TABLE contacts ADD COLUMN last_interaction DATETIME; -- 最后交互时间

-- 为conversations表添加插件相关字段
ALTER TABLE conversations ADD COLUMN plugin_data TEXT; -- JSON格式的插件数据
ALTER TABLE conversations ADD COLUMN custom_settings TEXT; -- 自定义设置

-- 为messages表添加插件相关字段
ALTER TABLE messages ADD COLUMN plugin_source VARCHAR(100) DEFAULT ''; -- 消息来源插件
ALTER TABLE messages ADD COLUMN attachment_data TEXT; -- 附件数据（JSON格式）
ALTER TABLE messages ADD COLUMN read_status INTEGER DEFAULT 0; -- 阅读状态
```

## 插件数据API设计

### 1. 主进程数据服务 (PluginDataService)

```typescript
// src/main/services/plugin/PluginDataService.ts
export class PluginDataService {
  private db: Database.Database

  constructor(database: Database.Database) {
    this.db = database
  }

  // 插件私有数据操作
  async setPluginData(
    pluginId: string,
    key: string,
    value: any,
    type: string = 'string'
  ): Promise<boolean>
  async getPluginData(pluginId: string, key: string): Promise<any>
  async deletePluginData(pluginId: string, key: string): Promise<boolean>
  async listPluginData(pluginId: string): Promise<Array<{ key: string; value: any; type: string }>>

  // 插件共享数据操作
  async setSharedData(
    namespace: string,
    key: string,
    value: any,
    ownerPlugin: string,
    permissions?: any
  ): Promise<boolean>
  async getSharedData(namespace: string, key: string, requestPlugin: string): Promise<any>
  async deleteSharedData(namespace: string, key: string, requestPlugin: string): Promise<boolean>
  async listSharedData(namespace: string, requestPlugin: string): Promise<Array<any>>

  // 联系人数据操作
  async getContacts(pluginId: string): Promise<Array<any>>
  async getContact(contactId: number, pluginId: string): Promise<any>
  async updateContact(contactId: number, updates: any, pluginId: string): Promise<boolean>
  async addContact(contactData: any, pluginId: string): Promise<number>
  async deleteContact(contactId: number, pluginId: string): Promise<boolean>
  async pinContact(contactId: number, isPinned: boolean, pluginId: string): Promise<boolean>

  // 联系人分组操作
  async getContactGroups(pluginId: string): Promise<Array<any>>
  async createContactGroup(groupData: any, pluginId: string): Promise<number>
  async updateContactGroup(groupId: number, updates: any, pluginId: string): Promise<boolean>
  async deleteContactGroup(groupId: number, pluginId: string): Promise<boolean>

  // 消息数据操作
  async getMessages(
    conversationId: number,
    page: number,
    limit: number,
    pluginId: string
  ): Promise<Array<any>>
  async getMessage(messageId: number, pluginId: string): Promise<any>
  async sendMessage(messageData: any, pluginId: string): Promise<number>
  async updateMessage(messageId: number, updates: any, pluginId: string): Promise<boolean>
  async deleteMessage(messageId: number, pluginId: string): Promise<boolean>
  async markMessageAsRead(messageId: number, pluginId: string): Promise<boolean>

  // 会话数据操作
  async getConversations(pluginId: string): Promise<Array<any>>
  async getConversation(conversationId: number, pluginId: string): Promise<any>
  async createConversation(conversationData: any, pluginId: string): Promise<number>
  async updateConversation(conversationId: number, updates: any, pluginId: string): Promise<boolean>
  async deleteConversation(conversationId: number, pluginId: string): Promise<boolean>
  async pinConversation(
    conversationId: number,
    isPinned: boolean,
    pluginId: string
  ): Promise<boolean>

  // 文件传输相关
  async saveFileTransferRecord(transferData: any, pluginId: string): Promise<number>
  async getFileTransferHistory(conversationId: number, pluginId: string): Promise<Array<any>>
  async updateFileTransferStatus(
    transferId: number,
    status: string,
    pluginId: string
  ): Promise<boolean>
}
```

### 2. IPC通信接口

```typescript
// src/main/plugin/PluginAPIHandler.ts 扩展
export class PluginAPIHandler {
  // 添加数据相关的IPC处理器
  private setupDataHandlers() {
    // 插件私有数据
    ipcMain.handle('plugin:data:set', this.handleSetPluginData.bind(this))
    ipcMain.handle('plugin:data:get', this.handleGetPluginData.bind(this))
    ipcMain.handle('plugin:data:delete', this.handleDeletePluginData.bind(this))
    ipcMain.handle('plugin:data:list', this.handleListPluginData.bind(this))

    // 共享数据
    ipcMain.handle('plugin:shared:set', this.handleSetSharedData.bind(this))
    ipcMain.handle('plugin:shared:get', this.handleGetSharedData.bind(this))
    ipcMain.handle('plugin:shared:delete', this.handleDeleteSharedData.bind(this))
    ipcMain.handle('plugin:shared:list', this.handleListSharedData.bind(this))

    // 联系人数据
    ipcMain.handle('plugin:contacts:list', this.handleGetContacts.bind(this))
    ipcMain.handle('plugin:contacts:get', this.handleGetContact.bind(this))
    ipcMain.handle('plugin:contacts:update', this.handleUpdateContact.bind(this))
    ipcMain.handle('plugin:contacts:add', this.handleAddContact.bind(this))
    ipcMain.handle('plugin:contacts:delete', this.handleDeleteContact.bind(this))
    ipcMain.handle('plugin:contacts:pin', this.handlePinContact.bind(this))

    // 联系人分组
    ipcMain.handle('plugin:contact-groups:list', this.handleGetContactGroups.bind(this))
    ipcMain.handle('plugin:contact-groups:create', this.handleCreateContactGroup.bind(this))
    ipcMain.handle('plugin:contact-groups:update', this.handleUpdateContactGroup.bind(this))
    ipcMain.handle('plugin:contact-groups:delete', this.handleDeleteContactGroup.bind(this))

    // 消息数据
    ipcMain.handle('plugin:messages:list', this.handleGetMessages.bind(this))
    ipcMain.handle('plugin:messages:get', this.handleGetMessage.bind(this))
    ipcMain.handle('plugin:messages:send', this.handleSendMessage.bind(this))
    ipcMain.handle('plugin:messages:update', this.handleUpdateMessage.bind(this))
    ipcMain.handle('plugin:messages:delete', this.handleDeleteMessage.bind(this))
    ipcMain.handle('plugin:messages:mark-read', this.handleMarkMessageAsRead.bind(this))

    // 会话数据
    ipcMain.handle('plugin:conversations:list', this.handleGetConversations.bind(this))
    ipcMain.handle('plugin:conversations:get', this.handleGetConversation.bind(this))
    ipcMain.handle('plugin:conversations:create', this.handleCreateConversation.bind(this))
    ipcMain.handle('plugin:conversations:update', this.handleUpdateConversation.bind(this))
    ipcMain.handle('plugin:conversations:delete', this.handleDeleteConversation.bind(this))
    ipcMain.handle('plugin:conversations:pin', this.handlePinConversation.bind(this))

    // 文件传输
    ipcMain.handle('plugin:files:save-transfer', this.handleSaveFileTransfer.bind(this))
    ipcMain.handle('plugin:files:get-history', this.handleGetFileTransferHistory.bind(this))
    ipcMain.handle('plugin:files:update-status', this.handleUpdateFileTransferStatus.bind(this))
  }
}
```

### 3. 前端插件API封装

```javascript
// plugins/shared/PluginDataAPI.js
class PluginDataAPI {
  constructor(pluginId) {
    this.pluginId = pluginId
  }

  // 插件私有数据
  async setData(key, value, type = 'string') {
    return await window.electron.ipcRenderer.invoke('plugin:data:set', {
      pluginId: this.pluginId,
      key,
      value,
      type
    })
  }

  async getData(key) {
    return await window.electron.ipcRenderer.invoke('plugin:data:get', {
      pluginId: this.pluginId,
      key
    })
  }

  async deleteData(key) {
    return await window.electron.ipcRenderer.invoke('plugin:data:delete', {
      pluginId: this.pluginId,
      key
    })
  }

  async listData() {
    return await window.electron.ipcRenderer.invoke('plugin:data:list', {
      pluginId: this.pluginId
    })
  }

  // 共享数据
  async setSharedData(namespace, key, value, permissions = null) {
    return await window.electron.ipcRenderer.invoke('plugin:shared:set', {
      namespace,
      key,
      value,
      ownerPlugin: this.pluginId,
      permissions
    })
  }

  async getSharedData(namespace, key) {
    return await window.electron.ipcRenderer.invoke('plugin:shared:get', {
      namespace,
      key,
      requestPlugin: this.pluginId
    })
  }

  // 联系人数据
  async getContacts() {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:list', {
      pluginId: this.pluginId
    })
  }

  async getContact(contactId) {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:get', {
      contactId,
      pluginId: this.pluginId
    })
  }

  async updateContact(contactId, updates) {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:update', {
      contactId,
      updates,
      pluginId: this.pluginId
    })
  }

  async addContact(contactData) {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:add', {
      contactData,
      pluginId: this.pluginId
    })
  }

  async deleteContact(contactId) {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:delete', {
      contactId,
      pluginId: this.pluginId
    })
  }

  async pinContact(contactId, isPinned) {
    return await window.electron.ipcRenderer.invoke('plugin:contacts:pin', {
      contactId,
      isPinned,
      pluginId: this.pluginId
    })
  }

  // 联系人分组
  async getContactGroups() {
    return await window.electron.ipcRenderer.invoke('plugin:contact-groups:list', {
      pluginId: this.pluginId
    })
  }

  async createContactGroup(groupData) {
    return await window.electron.ipcRenderer.invoke('plugin:contact-groups:create', {
      groupData,
      pluginId: this.pluginId
    })
  }

  // 消息数据
  async getMessages(conversationId, page = 1, limit = 20) {
    return await window.electron.ipcRenderer.invoke('plugin:messages:list', {
      conversationId,
      page,
      limit,
      pluginId: this.pluginId
    })
  }

  async sendMessage(messageData) {
    return await window.electron.ipcRenderer.invoke('plugin:messages:send', {
      messageData,
      pluginId: this.pluginId
    })
  }

  async markMessageAsRead(messageId) {
    return await window.electron.ipcRenderer.invoke('plugin:messages:mark-read', {
      messageId,
      pluginId: this.pluginId
    })
  }

  // 会话数据
  async getConversations() {
    return await window.electron.ipcRenderer.invoke('plugin:conversations:list', {
      pluginId: this.pluginId
    })
  }

  async pinConversation(conversationId, isPinned) {
    return await window.electron.ipcRenderer.invoke('plugin:conversations:pin', {
      conversationId,
      isPinned,
      pluginId: this.pluginId
    })
  }

  // 文件传输
  async saveFileTransfer(transferData) {
    return await window.electron.ipcRenderer.invoke('plugin:files:save-transfer', {
      transferData,
      pluginId: this.pluginId
    })
  }

  async getFileTransferHistory(conversationId) {
    return await window.electron.ipcRenderer.invoke('plugin:files:get-history', {
      conversationId,
      pluginId: this.pluginId
    })
  }
}

// 导出API类
window.PluginDataAPI = PluginDataAPI
```

## 插件实现示例

### 1. 通讯录插件数据层改造

```javascript
// plugins/contact-plugin/ContactDataManager.js
class ContactDataManager {
  constructor(pluginId) {
    this.api = new PluginDataAPI(pluginId)
    this.cache = new Map() // 本地缓存
  }

  // 获取联系人列表（带缓存）
  async getContactList() {
    try {
      const cacheKey = 'contact_list'
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey)
      }

      const contacts = await this.api.getContacts()
      this.cache.set(cacheKey, contacts)
      return contacts
    } catch (error) {
      console.error('获取联系人列表失败:', error)
      return []
    }
  }

  // 获取联系人分组
  async getContactGroups() {
    try {
      return await this.api.getContactGroups()
    } catch (error) {
      console.error('获取联系人分组失败:', error)
      return []
    }
  }

  // 添加联系人
  async addContact(contactData) {
    try {
      const result = await this.api.addContact(contactData)
      if (result.success) {
        this.clearCache() // 清除缓存
        // 通知其他插件联系人数据更新
        await this.api.setSharedData('contacts', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('添加联系人失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 更新联系人
  async updateContact(contactId, updates) {
    try {
      const result = await this.api.updateContact(contactId, updates)
      if (result.success) {
        this.clearCache()
        await this.api.setSharedData('contacts', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('更新联系人失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 置顶联系人
  async pinContact(contactId, isPinned) {
    try {
      const result = await this.api.pinContact(contactId, isPinned)
      if (result.success) {
        this.clearCache()
        await this.api.setSharedData('contacts', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('置顶联系人失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 删除联系人
  async deleteContact(contactId) {
    try {
      const result = await this.api.deleteContact(contactId)
      if (result.success) {
        this.clearCache()
        await this.api.setSharedData('contacts', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('删除联系人失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 监听联系人数据变化
  async watchContactChanges(callback) {
    let lastUpdate = await this.api.getSharedData('contacts', 'last_update')

    setInterval(async () => {
      const currentUpdate = await this.api.getSharedData('contacts', 'last_update')
      if (currentUpdate && currentUpdate !== lastUpdate) {
        lastUpdate = currentUpdate
        this.clearCache()
        callback()
      }
    }, 1000) // 每秒检查一次
  }

  // 清除缓存
  clearCache() {
    this.cache.clear()
  }
}
```

### 2. 消息插件数据层改造

```javascript
// plugins/message-plugin/MessageDataManager.js
class MessageDataManager {
  constructor(pluginId) {
    this.api = new PluginDataAPI(pluginId)
    this.cache = new Map()
  }

  // 获取会话列表
  async getConversations() {
    try {
      const cacheKey = 'conversations'
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey)
      }

      const conversations = await this.api.getConversations()
      this.cache.set(cacheKey, conversations)
      return conversations
    } catch (error) {
      console.error('获取会话列表失败:', error)
      return []
    }
  }

  // 获取消息历史
  async getMessageHistory(conversationId, page = 1, limit = 20) {
    try {
      return await this.api.getMessages(conversationId, page, limit)
    } catch (error) {
      console.error('获取消息历史失败:', error)
      return { messages: [], total: 0 }
    }
  }

  // 发送消息
  async sendMessage(messageData) {
    try {
      const result = await this.api.sendMessage(messageData)
      if (result.success) {
        // 通知其他插件消息数据更新
        await this.api.setSharedData('messages', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('发送消息失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 标记消息为已读
  async markAsRead(messageId) {
    try {
      return await this.api.markMessageAsRead(messageId)
    } catch (error) {
      console.error('标记消息已读失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 置顶会话
  async pinConversation(conversationId, isPinned) {
    try {
      const result = await this.api.pinConversation(conversationId, isPinned)
      if (result.success) {
        this.clearCache()
        await this.api.setSharedData('conversations', 'last_update', Date.now())
      }
      return result
    } catch (error) {
      console.error('置顶会话失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 保存文件传输记录
  async saveFileTransfer(transferData) {
    try {
      return await this.api.saveFileTransfer(transferData)
    } catch (error) {
      console.error('保存文件传输记录失败:', error)
      return { success: false, error: error.message }
    }
  }

  // 获取文件传输历史
  async getFileTransferHistory(conversationId) {
    try {
      return await this.api.getFileTransferHistory(conversationId)
    } catch (error) {
      console.error('获取文件传输历史失败:', error)
      return []
    }
  }

  // 获取联系人数据（从共享数据）
  async getContactData() {
    try {
      // 从通讯录插件获取联系人数据
      return await this.api.getSharedData('contacts', 'contact_list')
    } catch (error) {
      console.error('获取联系人数据失败:', error)
      return null
    }
  }

  // 监听数据变化
  async watchDataChanges(callback) {
    let lastMessageUpdate = await this.api.getSharedData('messages', 'last_update')
    let lastContactUpdate = await this.api.getSharedData('contacts', 'last_update')

    setInterval(async () => {
      const currentMessageUpdate = await this.api.getSharedData('messages', 'last_update')
      const currentContactUpdate = await this.api.getSharedData('contacts', 'last_update')

      if (currentMessageUpdate && currentMessageUpdate !== lastMessageUpdate) {
        lastMessageUpdate = currentMessageUpdate
        callback('messages')
      }

      if (currentContactUpdate && currentContactUpdate !== lastContactUpdate) {
        lastContactUpdate = currentContactUpdate
        callback('contacts')
      }
    }, 1000)
  }

  clearCache() {
    this.cache.clear()
  }
}
```

## 数据同步机制

### 1. 实时数据同步

```javascript
// plugins/shared/DataSyncManager.js
class DataSyncManager {
  constructor() {
    this.listeners = new Map()
    this.syncInterval = 1000 // 1秒同步间隔
    this.lastSyncTimes = new Map()
  }

  // 注册数据变化监听器
  registerListener(namespace, callback) {
    if (!this.listeners.has(namespace)) {
      this.listeners.set(namespace, [])
    }
    this.listeners.get(namespace).push(callback)
  }

  // 开始数据同步
  startSync() {
    setInterval(async () => {
      for (const [namespace, callbacks] of this.listeners) {
        await this.checkAndNotify(namespace, callbacks)
      }
    }, this.syncInterval)
  }

  // 检查数据变化并通知
  async checkAndNotify(namespace, callbacks) {
    try {
      const api = new PluginDataAPI('sync-manager')
      const lastUpdate = await api.getSharedData(namespace, 'last_update')
      const lastSyncTime = this.lastSyncTimes.get(namespace)

      if (lastUpdate && lastUpdate !== lastSyncTime) {
        this.lastSyncTimes.set(namespace, lastUpdate)
        callbacks.forEach((callback) => {
          try {
            callback(namespace, lastUpdate)
          } catch (error) {
            console.error('数据同步回调执行失败:', error)
          }
        })
      }
    } catch (error) {
      console.error('数据同步检查失败:', error)
    }
  }

  // 触发数据更新
  async triggerUpdate(namespace) {
    try {
      const api = new PluginDataAPI('sync-manager')
      await api.setSharedData(namespace, 'last_update', Date.now())
    } catch (error) {
      console.error('触发数据更新失败:', error)
    }
  }
}

// 全局数据同步管理器
window.dataSyncManager = new DataSyncManager()
window.dataSyncManager.startSync()
```

### 2. 缓存管理策略

```javascript
// plugins/shared/CacheManager.js
class CacheManager {
  constructor(maxSize = 100, ttl = 300000) {
    // 默认5分钟TTL
    this.cache = new Map()
    this.maxSize = maxSize
    this.ttl = ttl
  }

  // 设置缓存
  set(key, value) {
    // 如果缓存已满，删除最旧的条目
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    this.cache.set(key, {
      value,
      timestamp: Date.now()
    })
  }

  // 获取缓存
  get(key) {
    const item = this.cache.get(key)
    if (!item) return null

    // 检查是否过期
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key)
      return null
    }

    return item.value
  }

  // 删除缓存
  delete(key) {
    return this.cache.delete(key)
  }

  // 清空缓存
  clear() {
    this.cache.clear()
  }

  // 清理过期缓存
  cleanup() {
    const now = Date.now()
    for (const [key, item] of this.cache) {
      if (now - item.timestamp > this.ttl) {
        this.cache.delete(key)
      }
    }
  }
}

// 全局缓存管理器
window.cacheManager = new CacheManager()

// 定期清理过期缓存
setInterval(() => {
  window.cacheManager.cleanup()
}, 60000) // 每分钟清理一次
```

## 性能优化策略

### 1. 数据库优化

```sql
-- 创建复合索引优化查询性能
CREATE INDEX IF NOT EXISTS idx_contacts_user_group ON contacts(user_id, group_id);
CREATE INDEX IF NOT EXISTS idx_messages_conversation ON messages(talk_mode, to_from_id, created_at);
CREATE INDEX IF NOT EXISTS idx_conversations_user_updated ON conversations(user_id, updated_at);

-- 创建部分索引优化特定查询
CREATE INDEX IF NOT EXISTS idx_contacts_pinned ON contacts(user_id) WHERE is_pinned = 1;
CREATE INDEX IF NOT EXISTS idx_messages_unread ON messages(to_from_id) WHERE read_status = 0;
```

### 2. 批量操作优化

```typescript
// src/main/services/plugin/PluginDataService.ts
export class PluginDataService {
  // 批量插入联系人
  async batchInsertContacts(contacts: any[], pluginId: string): Promise<boolean> {
    const insertStmt = this.db.prepare(`
      INSERT INTO contacts (user_id, friend_id, remark, group_id, plugin_source)
      VALUES (?, ?, ?, ?, ?)
    `)

    const transaction = this.db.transaction((contacts) => {
      for (const contact of contacts) {
        insertStmt.run(
          contact.user_id,
          contact.friend_id,
          contact.remark,
          contact.group_id,
          pluginId
        )
      }
    })

    try {
      transaction(contacts)
      return true
    } catch (error) {
      console.error('批量插入联系人失败:', error)
      return false
    }
  }

  // 批量更新消息状态
  async batchUpdateMessageStatus(
    messageIds: number[],
    status: number,
    pluginId: string
  ): Promise<boolean> {
    const updateStmt = this.db.prepare(`
      UPDATE messages SET read_status = ? WHERE id = ?
    `)

    const transaction = this.db.transaction((messageIds) => {
      for (const messageId of messageIds) {
        updateStmt.run(status, messageId)
      }
    })

    try {
      transaction(messageIds)
      return true
    } catch (error) {
      console.error('批量更新消息状态失败:', error)
      return false
    }
  }
}
```

## 安全机制

### 1. 权限控制

```typescript
// src/main/services/plugin/PluginPermissionManager.ts
export class PluginPermissionManager {
  private permissions: Map<string, Set<string>> = new Map()

  // 检查插件权限
  checkPermission(pluginId: string, permission: string): boolean {
    const pluginPermissions = this.permissions.get(pluginId)
    return pluginPermissions ? pluginPermissions.has(permission) : false
  }

  // 设置插件权限
  setPermissions(pluginId: string, permissions: string[]): void {
    this.permissions.set(pluginId, new Set(permissions))
  }

  // 验证数据访问权限
  validateDataAccess(pluginId: string, operation: string, resourceType: string): boolean {
    const requiredPermission = `${operation}:${resourceType}`
    return this.checkPermission(pluginId, requiredPermission)
  }
}
```

### 2. 数据验证

```typescript
// src/main/services/plugin/DataValidator.ts
export class DataValidator {
  // 验证联系人数据
  static validateContactData(data: any): { valid: boolean; errors: string[] } {
    const errors: string[] = []

    if (!data.friend_id || typeof data.friend_id !== 'number') {
      errors.push('friend_id is required and must be a number')
    }

    if (data.remark && typeof data.remark !== 'string') {
      errors.push('remark must be a string')
    }

    if (data.group_id && typeof data.group_id !== 'number') {
      errors.push('group_id must be a number')
    }

    return { valid: errors.length === 0, errors }
  }

  // 验证消息数据
  static validateMessageData(data: any): { valid: boolean; errors: string[] } {
    const errors: string[] = []

    if (!data.content || typeof data.content !== 'string') {
      errors.push('content is required and must be a string')
    }

    if (!data.message_type || typeof data.message_type !== 'number') {
      errors.push('message_type is required and must be a number')
    }

    if (!data.to_from_id || typeof data.to_from_id !== 'number') {
      errors.push('to_from_id is required and must be a number')
    }

    return { valid: errors.length === 0, errors }
  }
}
```

## 实施步骤

### 阶段一：数据库扩展

1. 执行数据库schema扩展脚本
2. 创建插件数据相关表
3. 添加必要的索引和触发器

### 阶段二：主进程服务开发

1. 实现PluginDataService类
2. 扩展PluginAPIHandler的IPC处理器
3. 集成权限管理和数据验证

### 阶段三：前端API封装

1. 创建PluginDataAPI类
2. 实现数据同步管理器
3. 开发缓存管理策略

### 阶段四：插件改造

1. 改造通讯录插件的数据层
2. 改造消息插件的数据层
3. 实现插件间数据共享

### 阶段五：测试和优化

1. 功能测试和性能测试
2. 数据一致性验证
3. 安全性测试

## 总结

本设计方案提供了一个完整的插件数据存储和共享架构，具有以下优势：

1. **统一的数据访问层**：通过PluginDataService提供统一的数据访问接口
2. **高效的数据共享**：通过共享数据表实现插件间数据共享
3. **完善的缓存机制**：多层缓存策略提升性能
4. **实时数据同步**：确保插件间数据一致性
5. **安全的权限控制**：细粒度的权限管理机制
6. **良好的扩展性**：支持未来更多插件的接入

该方案既保留了原有功能特性，又实现了插件间的数据共享，为Why-Talk的插件生态提供了坚实的数据基础。
