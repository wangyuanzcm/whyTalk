# 插件数据服务使用示例

本文档展示如何在联系人插件和消息插件中使用数据服务进行数据管理和共享。

## 目录

1. [联系人插件使用示例](#联系人插件使用示例)
2. [消息插件使用示例](#消息插件使用示例)
3. [数据同步服务使用](#数据同步服务使用)
4. [最佳实践](#最佳实践)
5. [错误处理](#错误处理)
6. [性能优化](#性能优化)

## 联系人插件使用示例

### 1. 初始化联系人数据服务

```typescript
// plugins/contact-plugin/src/components/ContactList.vue
import { ContactDataService, ContactWithGroup } from '../services/ContactDataService'
import { createDataSyncService, subscribeToContactChanges } from '../../shared/services/DataSyncService'

export default {
  name: 'ContactList',
  data() {
    return {
      contactService: new ContactDataService('contact-plugin'),
      syncService: createDataSyncService('contact-plugin'),
      contacts: [] as ContactWithGroup[],
      groups: [] as ContactGroup[],
      loading: false,
      searchKeyword: '',
      selectedGroupId: null as number | null,
      unsubscribeSync: null as (() => void) | null
    }
  },
  
  async mounted() {
    await this.initializeData()
    this.setupDataSync()
  },
  
  beforeUnmount() {
    if (this.unsubscribeSync) {
      this.unsubscribeSync()
    }
  },
  
  methods: {
    // 初始化数据
    async initializeData() {
      this.loading = true
      try {
        // 加载联系人分组
        this.groups = await this.contactService.getContactGroups()
        
        // 加载联系人列表
        this.contacts = await this.contactService.getContacts({
          sortBy: 'updated_at',
          sortOrder: 'desc'
        })
        
        console.log(`加载了 ${this.contacts.length} 个联系人和 ${this.groups.length} 个分组`)
      } catch (error) {
        console.error('初始化联系人数据失败:', error)
        this.$message.error('加载联系人数据失败')
      } finally {
        this.loading = false
      }
    },
    
    // 设置数据同步
    setupDataSync() {
      this.unsubscribeSync = subscribeToContactChanges('contact-plugin', (event) => {
        console.log('收到联系人同步事件:', event)
        
        switch (event.type) {
          case 'contact_added':
            this.handleContactAdded(event.data)
            break
          case 'contact_updated':
            this.handleContactUpdated(event.data)
            break
          case 'contact_deleted':
            this.handleContactDeleted(event.data)
            break
          case 'contact_pinned':
            this.handleContactPinned(event.data)
            break
        }
      })
    },
    
    // 处理联系人添加事件
    handleContactAdded(contact: ContactWithGroup) {
      const existingIndex = this.contacts.findIndex(c => c.id === contact.id)
      if (existingIndex === -1) {
        this.contacts.unshift(contact)
        this.$message.success(`新增联系人: ${contact.nickname || contact.remark}`)
      }
    },
    
    // 处理联系人更新事件
    handleContactUpdated(contact: ContactWithGroup) {
      const index = this.contacts.findIndex(c => c.id === contact.id)
      if (index >= 0) {
        this.contacts.splice(index, 1, contact)
        this.$message.info(`联系人已更新: ${contact.nickname || contact.remark}`)
      }
    },
    
    // 处理联系人删除事件
    handleContactDeleted(contact: ContactWithGroup) {
      const index = this.contacts.findIndex(c => c.id === contact.id)
      if (index >= 0) {
        this.contacts.splice(index, 1)
        this.$message.warning(`联系人已删除: ${contact.nickname || contact.remark}`)
      }
    },
    
    // 处理联系人置顶事件
    handleContactPinned(contact: ContactWithGroup) {
      this.handleContactUpdated(contact)
      // 重新排序以显示置顶效果
      this.sortContacts()
    },
    
    // 搜索联系人
    async searchContacts() {
      if (!this.searchKeyword.trim()) {
        await this.loadContacts()
        return
      }
      
      this.loading = true
      try {
        this.contacts = await this.contactService.searchContacts(this.searchKeyword, {
          groupId: this.selectedGroupId,
          limit: 100
        })
      } catch (error) {
        console.error('搜索联系人失败:', error)
        this.$message.error('搜索失败')
      } finally {
        this.loading = false
      }
    },
    
    // 按分组筛选
    async filterByGroup(groupId: number | null) {
      this.selectedGroupId = groupId
      this.loading = true
      
      try {
        if (groupId) {
          this.contacts = await this.contactService.getContactsByGroup(groupId)
        } else {
          this.contacts = await this.contactService.getContacts()
        }
      } catch (error) {
        console.error('筛选联系人失败:', error)
        this.$message.error('筛选失败')
      } finally {
        this.loading = false
      }
    },
    
    // 添加联系人
    async addContact(contactData: any) {
      try {
        const newContact = await this.contactService.addContact({
          user_id: contactData.userId,
          remark: contactData.remark,
          nickname: contactData.nickname,
          avatar: contactData.avatar,
          group_id: contactData.groupId || 1,
          tags: contactData.tags || [],
          notes: contactData.notes || ''
        })
        
        if (newContact) {
          // 同步到其他插件
          await this.syncService.syncContacts([...this.contacts, newContact], 'contact-plugin')
          this.$message.success('添加联系人成功')
        } else {
          this.$message.error('添加联系人失败')
        }
      } catch (error) {
        console.error('添加联系人失败:', error)
        this.$message.error('添加联系人失败')
      }
    },
    
    // 更新联系人
    async updateContact(contactId: number, updates: any) {
      try {
        const success = await this.contactService.updateContact(contactId, updates)
        
        if (success) {
          // 重新加载联系人列表
          await this.loadContacts()
          
          // 同步到其他插件
          await this.syncService.syncContacts(this.contacts, 'contact-plugin')
          
          this.$message.success('更新联系人成功')
        } else {
          this.$message.error('更新联系人失败')
        }
      } catch (error) {
        console.error('更新联系人失败:', error)
        this.$message.error('更新联系人失败')
      }
    },
    
    // 置顶/取消置顶联系人
    async togglePinContact(contact: ContactWithGroup) {
      try {
        const newPinnedState = !contact.is_pinned
        const success = await this.contactService.pinContact(contact.id, newPinnedState)
        
        if (success) {
          contact.is_pinned = newPinnedState
          this.sortContacts()
          
          // 同步到其他插件
          await this.syncService.syncContacts(this.contacts, 'contact-plugin')
          
          this.$message.success(newPinnedState ? '已置顶' : '已取消置顶')
        } else {
          this.$message.error('操作失败')
        }
      } catch (error) {
        console.error('置顶联系人失败:', error)
        this.$message.error('操作失败')
      }
    },
    
    // 删除联系人
    async deleteContact(contact: ContactWithGroup) {
      try {
        const confirmed = await this.$confirm(
          `确定要删除联系人 "${contact.nickname || contact.remark}" 吗？`,
          '确认删除',
          { type: 'warning' }
        )
        
        if (confirmed) {
          const success = await this.contactService.deleteContact(contact.id)
          
          if (success) {
            // 从列表中移除
            const index = this.contacts.findIndex(c => c.id === contact.id)
            if (index >= 0) {
              this.contacts.splice(index, 1)
            }
            
            // 同步到其他插件
            await this.syncService.syncContacts(this.contacts, 'contact-plugin')
            
            this.$message.success('删除联系人成功')
          } else {
            this.$message.error('删除联系人失败')
          }
        }
      } catch (error) {
        console.error('删除联系人失败:', error)
        this.$message.error('删除联系人失败')
      }
    },
    
    // 排序联系人
    sortContacts() {
      this.contacts.sort((a, b) => {
        // 置顶的在前
        if (a.is_pinned && !b.is_pinned) return -1
        if (!a.is_pinned && b.is_pinned) return 1
        
        // 按更新时间倒序
        const aTime = new Date(a.updated_at || 0).getTime()
        const bTime = new Date(b.updated_at || 0).getTime()
        return bTime - aTime
      })
    },
    
    // 加载联系人
    async loadContacts() {
      this.loading = true
      try {
        this.contacts = await this.contactService.getContacts({
          groupId: this.selectedGroupId,
          sortBy: 'updated_at',
          sortOrder: 'desc'
        })
      } catch (error) {
        console.error('加载联系人失败:', error)
        this.$message.error('加载联系人失败')
      } finally {
        this.loading = false
      }
    }
  }
}
```

### 2. 联系人分组管理

```typescript
// plugins/contact-plugin/src/components/ContactGroups.vue
import { ContactDataService, ContactGroup } from '../services/ContactDataService'

export default {
  name: 'ContactGroups',
  data() {
    return {
      contactService: new ContactDataService('contact-plugin'),
      groups: [] as ContactGroup[],
      showAddDialog: false,
      editingGroup: null as ContactGroup | null,
      newGroup: {
        name: '',
        description: '',
        color: '#1890ff',
        icon: 'user'
      }
    }
  },
  
  async mounted() {
    await this.loadGroups()
  },
  
  methods: {
    // 加载分组
    async loadGroups() {
      try {
        this.groups = await this.contactService.getContactGroups()
      } catch (error) {
        console.error('加载分组失败:', error)
        this.$message.error('加载分组失败')
      }
    },
    
    // 创建分组
    async createGroup() {
      try {
        const group = await this.contactService.createContactGroup(this.newGroup)
        
        if (group) {
          this.groups.push(group)
          this.showAddDialog = false
          this.resetNewGroup()
          this.$message.success('创建分组成功')
        } else {
          this.$message.error('创建分组失败')
        }
      } catch (error) {
        console.error('创建分组失败:', error)
        this.$message.error('创建分组失败')
      }
    },
    
    // 更新分组
    async updateGroup(group: ContactGroup) {
      try {
        const success = await this.contactService.updateContactGroup(group.id, {
          name: group.name,
          description: group.description,
          color: group.color,
          icon: group.icon
        })
        
        if (success) {
          this.$message.success('更新分组成功')
        } else {
          this.$message.error('更新分组失败')
        }
      } catch (error) {
        console.error('更新分组失败:', error)
        this.$message.error('更新分组失败')
      }
    },
    
    // 删除分组
    async deleteGroup(group: ContactGroup) {
      try {
        const confirmed = await this.$confirm(
          `确定要删除分组 "${group.name}" 吗？该分组下的联系人将移动到默认分组。`,
          '确认删除',
          { type: 'warning' }
        )
        
        if (confirmed) {
          const success = await this.contactService.deleteContactGroup(group.id)
          
          if (success) {
            const index = this.groups.findIndex(g => g.id === group.id)
            if (index >= 0) {
              this.groups.splice(index, 1)
            }
            this.$message.success('删除分组成功')
          } else {
            this.$message.error('删除分组失败')
          }
        }
      } catch (error) {
        console.error('删除分组失败:', error)
        this.$message.error('删除分组失败')
      }
    },
    
    // 重置新分组表单
    resetNewGroup() {
      this.newGroup = {
        name: '',
        description: '',
        color: '#1890ff',
        icon: 'user'
      }
    }
  }
}
```

## 消息插件使用示例

### 1. 消息列表组件

```typescript
// plugins/message-plugin/src/components/MessageList.vue
import { MessageDataService, MessageWithDetails, ConversationWithDetails } from '../services/MessageDataService'
import { createDataSyncService, subscribeToContactChanges } from '../../shared/services/DataSyncService'

export default {
  name: 'MessageList',
  props: {
    conversationId: {
      type: Number,
      required: true
    }
  },
  
  data() {
    return {
      messageService: new MessageDataService('message-plugin'),
      syncService: createDataSyncService('message-plugin'),
      messages: [] as MessageWithDetails[],
      conversation: null as ConversationWithDetails | null,
      loading: false,
      hasMore: true,
      pageSize: 50,
      unsubscribeSync: null as (() => void) | null
    }
  },
  
  async mounted() {
    await this.initializeData()
    this.setupDataSync()
  },
  
  beforeUnmount() {
    if (this.unsubscribeSync) {
      this.unsubscribeSync()
    }
  },
  
  watch: {
    conversationId: {
      handler: 'loadConversationData',
      immediate: true
    }
  },
  
  methods: {
    // 初始化数据
    async initializeData() {
      await this.loadConversationData()
    },
    
    // 设置数据同步
    setupDataSync() {
      this.unsubscribeSync = subscribeToContactChanges('message-plugin', (event) => {
        console.log('收到联系人同步事件:', event)
        
        // 当联系人信息更新时，刷新消息中的联系人信息
        if (event.type === 'contact_updated') {
          this.updateContactInfoInMessages(event.data)
        }
      })
    },
    
    // 加载会话数据
    async loadConversationData() {
      if (!this.conversationId) return
      
      this.loading = true
      try {
        // 加载会话信息
        this.conversation = await this.messageService.getConversation(this.conversationId)
        
        // 加载消息列表
        this.messages = await this.messageService.getMessages(this.conversationId, {
          limit: this.pageSize,
          sortBy: 'created_at',
          sortOrder: 'desc'
        })
        
        // 标记会话为已读
        await this.messageService.markConversationAsRead(this.conversationId)
        
        console.log(`加载了 ${this.messages.length} 条消息`)
      } catch (error) {
        console.error('加载会话数据失败:', error)
        this.$message.error('加载消息失败')
      } finally {
        this.loading = false
      }
    },
    
    // 发送消息
    async sendMessage(content: string, messageType: string = 'text', attachments?: any[]) {
      if (!this.conversation) return
      
      try {
        const messageData = {
          conversation_id: this.conversationId,
          sender_id: this.$store.state.user.userId,
          receiver_id: this.conversation.conversation_type === 'private' ? 
            this.conversation.participants?.find(p => p.user_id !== this.$store.state.user.userId)?.user_id : 
            undefined,
          content,
          message_type: messageType,
          attachments: attachments || []
        }
        
        const newMessage = await this.messageService.sendMessage(messageData)
        
        if (newMessage) {
          // 添加到消息列表
          this.messages.push(newMessage)
          
          // 滚动到底部
          this.$nextTick(() => {
            this.scrollToBottom()
          })
          
          console.log('发送消息成功:', newMessage)
        } else {
          this.$message.error('发送消息失败')
        }
      } catch (error) {
        console.error('发送消息失败:', error)
        this.$message.error('发送消息失败')
      }
    },
    
    // 加载更多消息
    async loadMoreMessages() {
      if (!this.hasMore || this.loading) return
      
      this.loading = true
      try {
        const olderMessages = await this.messageService.getMessages(this.conversationId, {
          limit: this.pageSize,
          offset: this.messages.length,
          sortBy: 'created_at',
          sortOrder: 'desc'
        })
        
        if (olderMessages.length < this.pageSize) {
          this.hasMore = false
        }
        
        // 将旧消息添加到列表开头
        this.messages.unshift(...olderMessages.reverse())
        
        console.log(`加载了 ${olderMessages.length} 条历史消息`)
      } catch (error) {
        console.error('加载历史消息失败:', error)
        this.$message.error('加载历史消息失败')
      } finally {
        this.loading = false
      }
    },
    
    // 撤回消息
    async recallMessage(message: MessageWithDetails) {
      try {
        const success = await this.messageService.recallMessage(message.id)
        
        if (success) {
          // 更新消息内容
          message.content = '[消息已撤回]'
          message.message_type = 'system'
          this.$message.success('消息已撤回')
        } else {
          this.$message.error('撤回消息失败')
        }
      } catch (error) {
        console.error('撤回消息失败:', error)
        this.$message.error('撤回消息失败')
      }
    },
    
    // 删除消息
    async deleteMessage(message: MessageWithDetails) {
      try {
        const confirmed = await this.$confirm(
          '确定要删除这条消息吗？',
          '确认删除',
          { type: 'warning' }
        )
        
        if (confirmed) {
          const success = await this.messageService.deleteMessage(message.id)
          
          if (success) {
            // 从列表中移除
            const index = this.messages.findIndex(m => m.id === message.id)
            if (index >= 0) {
              this.messages.splice(index, 1)
            }
            this.$message.success('删除消息成功')
          } else {
            this.$message.error('删除消息失败')
          }
        }
      } catch (error) {
        console.error('删除消息失败:', error)
        this.$message.error('删除消息失败')
      }
    },
    
    // 添加消息反应
    async addReaction(message: MessageWithDetails, emoji: string) {
      try {
        const success = await this.messageService.addMessageReaction(
          message.id, 
          emoji, 
          this.$store.state.user.userId
        )
        
        if (success) {
          // 重新加载消息以获取最新的反应
          const updatedMessage = await this.messageService.getMessage(message.id)
          if (updatedMessage) {
            const index = this.messages.findIndex(m => m.id === message.id)
            if (index >= 0) {
              this.messages.splice(index, 1, updatedMessage)
            }
          }
        }
      } catch (error) {
        console.error('添加消息反应失败:', error)
        this.$message.error('操作失败')
      }
    },
    
    // 更新消息中的联系人信息
    updateContactInfoInMessages(contact: any) {
      this.messages.forEach(message => {
        if (message.sender?.user_id === contact.user_id) {
          message.sender.nickname = contact.nickname
          message.sender.avatar = contact.avatar
          message.sender.status = contact.status
        }
        
        if (message.receiver?.user_id === contact.user_id) {
          message.receiver.nickname = contact.nickname
          message.receiver.avatar = contact.avatar
          message.receiver.status = contact.status
        }
      })
    },
    
    // 滚动到底部
    scrollToBottom() {
      const container = this.$refs.messageContainer
      if (container) {
        container.scrollTop = container.scrollHeight
      }
    }
  }
}
```

### 2. 文件传输组件

```typescript
// plugins/message-plugin/src/components/FileTransfer.vue
import { MessageDataService, MessageAttachment } from '../services/MessageDataService'

export default {
  name: 'FileTransfer',
  props: {
    conversationId: {
      type: Number,
      default: null
    }
  },
  
  data() {
    return {
      messageService: new MessageDataService('message-plugin'),
      transfers: [] as MessageAttachment[],
      loading: false,
      filterType: 'all' // all, image, video, audio, file
    }
  },
  
  async mounted() {
    await this.loadTransfers()
  },
  
  methods: {
    // 加载文件传输列表
    async loadTransfers() {
      this.loading = true
      try {
        this.transfers = await this.messageService.getFileTransfers(this.conversationId)
        console.log(`加载了 ${this.transfers.length} 个文件传输记录`)
      } catch (error) {
        console.error('加载文件传输列表失败:', error)
        this.$message.error('加载文件列表失败')
      } finally {
        this.loading = false
      }
    },
    
    // 按类型筛选
    filterByType(type: string) {
      this.filterType = type
    },
    
    // 获取筛选后的传输列表
    get filteredTransfers() {
      if (this.filterType === 'all') {
        return this.transfers
      }
      return this.transfers.filter(transfer => transfer.type === this.filterType)
    },
    
    // 下载文件
    async downloadFile(transfer: MessageAttachment) {
      try {
        if (transfer.local_path) {
          // 文件已在本地，直接打开
          await this.openLocalFile(transfer.local_path)
        } else if (transfer.url) {
          // 从远程下载
          await this.downloadFromUrl(transfer)
        } else {
          this.$message.error('文件不可用')
        }
      } catch (error) {
        console.error('下载文件失败:', error)
        this.$message.error('下载文件失败')
      }
    },
    
    // 从URL下载文件
    async downloadFromUrl(transfer: MessageAttachment) {
      // 这里应该调用实际的下载逻辑
      // 示例代码
      const response = await fetch(transfer.url!)
      const blob = await response.blob()
      
      // 创建下载链接
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = transfer.name
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      window.URL.revokeObjectURL(url)
    },
    
    // 打开本地文件
    async openLocalFile(localPath: string) {
      // 调用 Electron API 打开文件
      if (window.electronAPI) {
        await window.electronAPI.openFile(localPath)
      }
    },
    
    // 格式化文件大小
    formatFileSize(bytes: number): string {
      if (bytes === 0) return '0 B'
      
      const k = 1024
      const sizes = ['B', 'KB', 'MB', 'GB']
      const i = Math.floor(Math.log(bytes) / Math.log(k))
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
    },
    
    // 获取文件图标
    getFileIcon(type: string): string {
      const iconMap = {
        image: 'image',
        video: 'video-camera',
        audio: 'audio',
        file: 'file'
      }
      return iconMap[type] || 'file'
    }
  }
}
```

## 数据同步服务使用

### 1. 在联系人插件中使用同步服务

```typescript
// plugins/contact-plugin/src/main.ts
import { ContactDataService } from './services/ContactDataService'
import { createDataSyncService, publishContactChange } from '../shared/services/DataSyncService'

class ContactPlugin {
  private contactService: ContactDataService
  private syncService: any
  
  constructor() {
    this.contactService = new ContactDataService('contact-plugin')
    this.syncService = createDataSyncService('contact-plugin')
  }
  
  async initialize() {
    // 初始化时同步联系人数据
    const contacts = await this.contactService.getContacts()
    await this.syncService.syncContacts(contacts, 'contact-plugin')
    
    console.log('联系人插件初始化完成')
  }
  
  // 当联系人数据发生变化时，发布同步事件
  async onContactChanged(type: string, contact: any) {
    await publishContactChange(type, contact, 'contact-plugin')
  }
}

export default ContactPlugin
```

### 2. 在消息插件中监听联系人变化

```typescript
// plugins/message-plugin/src/main.ts
import { MessageDataService } from './services/MessageDataService'
import { subscribeToContactChanges } from '../shared/services/DataSyncService'

class MessagePlugin {
  private messageService: MessageDataService
  private unsubscribeSync: (() => void) | null = null
  
  constructor() {
    this.messageService = new MessageDataService('message-plugin')
  }
  
  async initialize() {
    // 订阅联系人变化事件
    this.unsubscribeSync = subscribeToContactChanges('message-plugin', (event) => {
      this.handleContactChange(event)
    })
    
    console.log('消息插件初始化完成')
  }
  
  // 处理联系人变化
  handleContactChange(event: any) {
    console.log('消息插件收到联系人变化事件:', event)
    
    // 根据事件类型处理
    switch (event.type) {
      case 'contact_updated':
        // 更新消息中的联系人信息
        this.updateContactInfoInMessages(event.data)
        break
      case 'contact_deleted':
        // 处理联系人删除
        this.handleContactDeleted(event.data)
        break
    }
  }
  
  // 更新消息中的联系人信息
  async updateContactInfoInMessages(contact: any) {
    // 这里可以更新缓存中的联系人信息
    // 或者通知 UI 组件刷新
  }
  
  // 处理联系人删除
  async handleContactDeleted(contact: any) {
    // 可能需要处理与该联系人相关的会话
  }
  
  destroy() {
    if (this.unsubscribeSync) {
      this.unsubscribeSync()
    }
  }
}

export default MessagePlugin
```

## 最佳实践

### 1. 错误处理

```typescript
// 统一的错误处理
class ErrorHandler {
  static async handleApiError(error: any, operation: string) {
    console.error(`${operation} 失败:`, error)
    
    // 根据错误类型显示不同的提示
    if (error.code === 'PERMISSION_DENIED') {
      ElMessage.error('没有操作权限')
    } else if (error.code === 'NETWORK_ERROR') {
      ElMessage.error('网络连接失败，请检查网络')
    } else if (error.code === 'DATA_VALIDATION_ERROR') {
      ElMessage.error('数据格式错误')
    } else {
      ElMessage.error(`${operation} 失败，请稍后重试`)
    }
  }
  
  static async withErrorHandling<T>(operation: () => Promise<T>, operationName: string): Promise<T | null> {
    try {
      return await operation()
    } catch (error) {
      await this.handleApiError(error, operationName)
      return null
    }
  }
}

// 使用示例
const contact = await ErrorHandler.withErrorHandling(
  () => contactService.addContact(contactData),
  '添加联系人'
)
```

### 2. 性能优化

```typescript
// 防抖搜索
const debouncedSearch = debounce(async (keyword: string) => {
  const results = await contactService.searchContacts(keyword)
  // 更新搜索结果
}, 300)

// 虚拟滚动（大量数据时）
const useVirtualScroll = (items: any[], itemHeight: number) => {
  const containerHeight = 400
  const visibleCount = Math.ceil(containerHeight / itemHeight)
  
  return {
    visibleItems: computed(() => {
      const start = Math.max(0, scrollTop.value / itemHeight - 5)
      const end = Math.min(items.length, start + visibleCount + 10)
      return items.slice(start, end)
    }),
    totalHeight: computed(() => items.length * itemHeight)
  }
}

// 批量操作
const batchUpdateContacts = async (updates: Array<{ id: number; data: any }>) => {
  const batchSize = 10
  const batches = []
  
  for (let i = 0; i < updates.length; i += batchSize) {
    batches.push(updates.slice(i, i + batchSize))
  }
  
  for (const batch of batches) {
    await Promise.all(
      batch.map(update => contactService.updateContact(update.id, update.data))
    )
  }
}
```

### 3. 缓存策略

```typescript
// 智能缓存管理
class CacheManager {
  private static instance: CacheManager
  private cache = new Map<string, { data: any; expiry: number }>()
  
  static getInstance() {
    if (!CacheManager.instance) {
      CacheManager.instance = new CacheManager()
    }
    return CacheManager.instance
  }
  
  set(key: string, data: any, ttl: number = 300000) { // 默认5分钟
    this.cache.set(key, {
      data,
      expiry: Date.now() + ttl
    })
  }
  
  get(key: string) {
    const item = this.cache.get(key)
    if (!item) return null
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key)
      return null
    }
    
    return item.data
  }
  
  invalidate(pattern: string) {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key)
      }
    }
  }
  
  clear() {
    this.cache.clear()
  }
}
```

### 4. 数据验证

```typescript
// 数据验证工具
class DataValidator {
  static validateContact(contact: any): { valid: boolean; errors: string[] } {
    const errors: string[] = []
    
    if (!contact.user_id || typeof contact.user_id !== 'string') {
      errors.push('用户ID不能为空')
    }
    
    if (contact.nickname && contact.nickname.length > 50) {
      errors.push('昵称不能超过50个字符')
    }
    
    if (contact.remark && contact.remark.length > 100) {
      errors.push('备注不能超过100个字符')
    }
    
    return {
      valid: errors.length === 0,
      errors
    }
  }
  
  static validateMessage(message: any): { valid: boolean; errors: string[] } {
    const errors: string[] = []
    
    if (!message.content || message.content.trim().length === 0) {
      errors.push('消息内容不能为空')
    }
    
    if (message.content && message.content.length > 5000) {
      errors.push('消息内容不能超过5000个字符')
    }
    
    if (!message.conversation_id) {
      errors.push('会话ID不能为空')
    }
    
    return {
      valid: errors.length === 0,
      errors
    }
  }
}
```

## 总结

通过以上示例，我们展示了如何在联系人插件和消息插件中使用数据服务：

1. **联系人插件**：管理联系人和分组数据，支持增删改查、搜索、置顶等功能
2. **消息插件**：管理消息和会话数据，支持发送、接收、撤回、文件传输等功能
3. **数据同步**：通过共享数据和事件机制实现插件间的数据同步
4. **最佳实践**：包括错误处理、性能优化、缓存策略、数据验证等

这套数据服务架构提供了：
- 统一的数据访问接口
- 自动的数据缓存和同步
- 完善的权限控制
- 良好的错误处理
- 高性能的数据操作

开发者可以基于这些服务快速构建功能丰富的插件，同时保证数据的一致性和安全性。