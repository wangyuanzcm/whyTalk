# 插件数据存储实现指南

本文档提供了完整的插件数据存储方案实现指南，包括数据库扩展、服务开发、API封装、插件重构和测试优化等各个阶段的详细步骤。

## 目录

1. [项目概述](#项目概述)
2. [技术架构](#技术架构)
3. [实现阶段](#实现阶段)
4. [文件结构](#文件结构)
5. [核心组件说明](#核心组件说明)
6. [实现步骤](#实现步骤)
7. [测试验证](#测试验证)
8. [部署上线](#部署上线)
9. [维护和优化](#维护和优化)
10. [常见问题](#常见问题)

## 项目概述

### 目标

设计并实现一套完整的插件数据存储方案，使联系人插件和消息插件能够：

1. **共享数据**：两个插件共用同一份联系人数据缓存
2. **保留功能**：保持原有页面的所有交互功能
3. **数据同步**：实现插件间的实时数据同步
4. **性能优化**：提供高效的数据访问和缓存机制
5. **安全控制**：实现完善的权限管理和数据验证

### 核心特性

- **统一数据层**：基于 SQLite 的统一数据存储
- **插件隔离**：每个插件有独立的数据空间
- **共享机制**：支持插件间的数据共享
- **实时同步**：基于事件的数据同步机制
- **权限控制**：细粒度的数据访问权限管理
- **缓存优化**：智能缓存策略提升性能

## 技术架构

### 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    前端插件层                                 │
├─────────────────────┬───────────────────────────────────────┤
│   联系人插件          │           消息插件                     │
│                     │                                       │
│ ┌─────────────────┐ │ ┌─────────────────────────────────────┐ │
│ │ ContactList.vue │ │ │ MessageList.vue                     │ │
│ │ ContactGroups   │ │ │ ConversationList.vue                │ │
│ │ ContactDetail   │ │ │ FileTransfer.vue                    │ │
│ └─────────────────┘ │ └─────────────────────────────────────┘ │
│          │          │                    │                   │
│ ┌─────────────────┐ │ ┌─────────────────────────────────────┐ │
│ │ContactDataService│ │ │ MessageDataService                  │ │
│ └─────────────────┘ │ └─────────────────────────────────────┘ │
└─────────────────────┴───────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────────────────┐
│                  共享服务层                                   │
├─────────────────────┬───────────────────────────────────────┤
│   PluginDataAPI     │        DataSyncService                │
│                     │                                       │
│ ┌─────────────────┐ │ ┌─────────────────────────────────────┐ │
│ │ 私有数据管理      │ │ │ 事件订阅/发布                        │ │
│ │ 共享数据管理      │ │ │ 数据同步                            │ │
│ │ 联系人管理        │ │ │ 缓存管理                            │ │
│ │ 消息管理          │ │ │ 统计分析                            │ │
│ └─────────────────┘ │ └─────────────────────────────────────┘ │
└─────────────────────┴───────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────────────────┐
│                   主进程服务层                                │
├─────────────────────┬───────────────────────────────────────┤
│  PluginDataService  │       PluginPermissionManager         │
│                     │                                       │
│ ┌─────────────────┐ │ ┌─────────────────────────────────────┐ │
│ │ 数据CRUD操作     │ │ │ 权限检查                            │ │
│ │ 事务管理          │ │ │ 权限设置                            │ │
│ │ 缓存管理          │ │ │ 数据验证                            │ │
│ │ 性能优化          │ │ │ 安全控制                            │ │
│ └─────────────────┘ │ └─────────────────────────────────────┘ │
└─────────────────────┴───────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────────────────┐
│                   数据存储层                                  │
├─────────────────────┬───────────────────────────────────────┤
│    SQLite 数据库     │           文件系统                     │
│                     │                                       │
│ ┌─────────────────┐ │ ┌─────────────────────────────────────┐ │
│ │ 插件数据表        │ │ │ 附件文件                            │ │
│ │ 共享数据表        │ │ │ 缓存文件                            │ │
│ │ 联系人数据表      │ │ │ 日志文件                            │ │
│ │ 消息数据表        │ │ │ 配置文件                            │ │
│ │ 权限配置表        │ │ │                                     │ │
│ └─────────────────┘ │ └─────────────────────────────────────┘ │
└─────────────────────┴───────────────────────────────────────┘
```

### 数据流向

```
用户操作 → 插件组件 → 数据服务 → API层 → IPC通信 → 主进程服务 → 数据库
                                                    ↓
事件通知 ← 同步服务 ← API层 ← IPC通信 ← 主进程服务 ← 数据库
```

## 实现阶段

### 阶段一：数据库扩展（已完成）

**目标**：扩展现有 SQLite 数据库，支持插件数据存储

**完成的工作**：

- ✅ 创建插件数据表结构
- ✅ 设计共享数据机制
- ✅ 添加权限控制表
- ✅ 创建索引和触发器
- ✅ 设计数据视图

**文件**：

- `src/main/services/database/plugin-schema.sql`

### 阶段二：主进程服务开发（已完成）

**目标**：开发主进程中的数据服务和权限管理

**完成的工作**：

- ✅ 实现 PluginDataService
- ✅ 实现 PluginPermissionManager
- ✅ 实现 DataValidator
- ✅ 实现 PluginDataIPC

**文件**：

- `src/main/services/plugin/PluginDataService.ts`
- `src/main/services/plugin/PluginPermissionManager.ts`
- `src/main/services/plugin/DataValidator.ts`
- `src/main/services/plugin/PluginDataIPC.ts`

### 阶段三：前端API封装（已完成）

**目标**：为插件提供统一的数据访问API

**完成的工作**：

- ✅ 实现 PluginDataAPI
- ✅ 实现 DataSyncService
- ✅ 创建插件数据服务示例

**文件**：

- `src/renderer/src/services/plugin/PluginDataAPI.ts`
- `plugins/shared/services/DataSyncService.ts`
- `plugins/contact-plugin/src/services/ContactDataService.ts`
- `plugins/message-plugin/src/services/MessageDataService.ts`

### 阶段四：插件重构（待实现）

**目标**：重构联系人和消息插件，使用新的数据服务

**需要完成的工作**：

- 🔄 重构联系人插件组件
- 🔄 重构消息插件组件
- 🔄 实现数据迁移脚本
- 🔄 更新插件配置

### 阶段五：测试和优化（待实现）

**目标**：全面测试系统功能，优化性能

**需要完成的工作**：

- 🔄 单元测试
- 🔄 集成测试
- 🔄 性能测试
- 🔄 用户体验测试

## 文件结构

```
why-talk/
├── doc/
│   ├── 插件数据存储设计方案.md          # 设计文档
│   ├── 插件数据服务使用示例.md          # 使用示例
│   └── 插件数据存储实现指南.md          # 实现指南（本文档）
│
├── src/
│   ├── main/
│   │   └── services/
│   │       ├── database/
│   │       │   └── plugin-schema.sql   # 数据库扩展脚本
│   │       └── plugin/
│   │           ├── PluginDataService.ts      # 主进程数据服务
│   │           ├── PluginPermissionManager.ts # 权限管理
│   │           ├── DataValidator.ts          # 数据验证
│   │           └── PluginDataIPC.ts          # IPC通信
│   │
│   └── renderer/
│       └── src/
│           └── services/
│               └── plugin/
│                   └── PluginDataAPI.ts      # 前端API封装
│
└── plugins/
    ├── shared/
    │   └── services/
    │       └── DataSyncService.ts              # 数据同步服务
    │
    ├── contact-plugin/
    │   └── src/
    │       └── services/
    │           └── ContactDataService.ts       # 联系人数据服务
    │
    └── message-plugin/
        └── src/
            └── services/
                └── MessageDataService.ts       # 消息数据服务
```

## 核心组件说明

### 1. PluginDataService（主进程数据服务）

**职责**：

- 提供统一的数据访问接口
- 管理数据库连接和事务
- 实现数据缓存和优化
- 处理数据序列化/反序列化

**核心方法**：

```typescript
// 私有数据管理
setPluginData(pluginId: string, key: string, value: any): Promise<boolean>
getPluginData(pluginId: string, key: string): Promise<any>
deletePluginData(pluginId: string, key: string): Promise<boolean>
listPluginData(pluginId: string): Promise<Array<{key: string, value: any}>>

// 共享数据管理
setSharedData(namespace: string, key: string, value: any, pluginId: string): Promise<boolean>
getSharedData(namespace: string, key: string): Promise<any>
deleteSharedData(namespace: string, key: string, pluginId: string): Promise<boolean>
listSharedData(namespace: string): Promise<Array<{key: string, value: any}>>

// 联系人管理
getContacts(options?: ContactQueryOptions): Promise<Contact[]>
getContact(contactId: number): Promise<Contact | null>
updateContact(contactId: number, updates: Partial<Contact>): Promise<boolean>
addContact(contactData: ContactData): Promise<Contact | null>
deleteContact(contactId: number): Promise<boolean>
pinContact(contactId: number, pinned: boolean): Promise<boolean>

// 消息管理
getMessages(conversationId: number, options?: MessageQueryOptions): Promise<Message[]>
sendMessage(messageData: MessageData): Promise<Message | null>
markMessageAsRead(messageId: number): Promise<boolean>
```

### 2. PluginPermissionManager（权限管理）

**职责**：

- 管理插件权限配置
- 验证数据访问权限
- 控制API调用权限
- 记录权限使用情况

**核心方法**：

```typescript
checkPermission(pluginId: string, permission: string): Promise<boolean>
setPermission(pluginId: string, permission: string, granted: boolean): Promise<boolean>
validateDataAccess(pluginId: string, operation: string, data: any): Promise<boolean>
validateApiAccess(pluginId: string, apiName: string): Promise<boolean>
```

### 3. PluginDataAPI（前端API封装）

**职责**：

- 封装IPC通信细节
- 提供类型安全的API
- 实现客户端缓存
- 处理错误和重试

**核心方法**：

```typescript
// 私有数据
setData(key: string, value: any): Promise<boolean>
getData(key: string): Promise<any>
deleteData(key: string): Promise<boolean>
listData(): Promise<Array<{key: string, value: any}>>

// 共享数据
setSharedData(namespace: string, key: string, value: any): Promise<boolean>
getSharedData(namespace: string, key: string): Promise<any>
deleteSharedData(namespace: string, key: string): Promise<boolean>
listSharedData(namespace: string): Promise<Array<{key: string, value: any}>>

// 联系人管理
getContacts(options?: any): Promise<any[]>
getContact(contactId: number): Promise<any>
updateContact(contactId: number, updates: any): Promise<boolean>
addContact(contactData: any): Promise<any>
deleteContact(contactId: number): Promise<boolean>
pinContact(contactId: number, pinned: boolean): Promise<boolean>

// 消息管理
getMessages(conversationId: number, options?: any): Promise<any[]>
sendMessage(messageData: any): Promise<any>
markMessageAsRead(messageId: number): Promise<boolean>
```

### 4. DataSyncService（数据同步服务）

**职责**：

- 管理插件间的数据同步
- 提供事件订阅/发布机制
- 处理数据冲突和合并
- 维护同步状态

**核心方法**：

```typescript
subscribe(eventType: string, callback: (event: SyncEvent) => void): () => void
unsubscribe(eventType: string, callback: (event: SyncEvent) => void): void
publish(event: SyncEvent): Promise<void>
syncContacts(contacts: Contact[], sourcePlugin: string): Promise<void>
getSharedContacts(): Promise<Contact[]>
forceSyncAll(): Promise<void>
```

## 实现步骤

### 步骤1：集成数据库扩展

1. **修改数据库初始化代码**

```typescript
// src/main/services/database/Database.ts
import fs from 'fs'
import path from 'path'

class DatabaseManager {
  async initialize() {
    // 执行原有的 schema.sql
    const schemaPath = path.join(__dirname, 'schema.sql')
    const schema = fs.readFileSync(schemaPath, 'utf8')
    await this.db.exec(schema)

    // 执行插件扩展 schema
    const pluginSchemaPath = path.join(__dirname, 'plugin-schema.sql')
    if (fs.existsSync(pluginSchemaPath)) {
      const pluginSchema = fs.readFileSync(pluginSchemaPath, 'utf8')
      await this.db.exec(pluginSchema)
      console.log('插件数据库扩展初始化完成')
    }
  }
}
```

2. **注册IPC处理器**

```typescript
// src/main/main.ts
import { PluginDataIPC } from './services/plugin/PluginDataIPC'

class MainProcess {
  async initialize() {
    // 初始化数据库
    await DatabaseManager.getInstance().initialize()

    // 注册插件数据IPC处理器
    const pluginDataIPC = new PluginDataIPC()
    await pluginDataIPC.initialize()

    console.log('主进程初始化完成')
  }
}
```

### 步骤2：创建插件项目结构

1. **创建联系人插件目录**

```bash
mkdir -p plugins/contact-plugin/src/{components,services,types,utils}
mkdir -p plugins/contact-plugin/src/components/{contact,group,search}
```

2. **创建消息插件目录**

```bash
mkdir -p plugins/message-plugin/src/{components,services,types,utils}
mkdir -p plugins/message-plugin/src/components/{message,conversation,file}
```

3. **创建共享服务目录**

```bash
mkdir -p plugins/shared/{services,types,utils,components}
```

### 步骤3：实现联系人插件组件

1. **创建联系人列表组件**

```typescript
// plugins/contact-plugin/src/components/contact/ContactList.vue
<template>
  <div class="contact-list">
    <!-- 搜索栏 -->
    <div class="search-bar">
      <el-input
        v-model="searchKeyword"
        placeholder="搜索联系人"
        @input="debouncedSearch"
        clearable
      >
        <template #prefix>
          <el-icon><Search /></el-icon>
        </template>
      </el-input>
    </div>

    <!-- 分组筛选 -->
    <div class="group-filter">
      <el-radio-group v-model="selectedGroupId" @change="filterByGroup">
        <el-radio-button :label="null">全部</el-radio-button>
        <el-radio-button
          v-for="group in groups"
          :key="group.id"
          :label="group.id"
        >
          {{ group.name }}
        </el-radio-button>
      </el-radio-group>
    </div>

    <!-- 联系人列表 -->
    <div class="contact-items" v-loading="loading">
      <div
        v-for="contact in filteredContacts"
        :key="contact.id"
        class="contact-item"
        :class="{ pinned: contact.is_pinned }"
        @click="selectContact(contact)"
      >
        <!-- 头像 -->
        <div class="avatar">
          <el-avatar :src="contact.avatar" :size="40">
            {{ contact.nickname?.[0] || contact.remark?.[0] || '?' }}
          </el-avatar>
          <div v-if="contact.is_pinned" class="pin-icon">
            <el-icon><Star /></el-icon>
          </div>
        </div>

        <!-- 信息 -->
        <div class="info">
          <div class="name">
            {{ contact.nickname || contact.remark || contact.user_id }}
          </div>
          <div class="status">
            <span class="status-dot" :class="contact.status"></span>
            {{ getStatusText(contact.status) }}
          </div>
        </div>

        <!-- 操作按钮 -->
        <div class="actions">
          <el-dropdown @command="handleAction">
            <el-button type="text" size="small">
              <el-icon><MoreFilled /></el-icon>
            </el-button>
            <template #dropdown>
              <el-dropdown-menu>
                <el-dropdown-item :command="{ action: 'pin', contact }">
                  {{ contact.is_pinned ? '取消置顶' : '置顶' }}
                </el-dropdown-item>
                <el-dropdown-item :command="{ action: 'edit', contact }">
                  编辑
                </el-dropdown-item>
                <el-dropdown-item :command="{ action: 'delete', contact }" divided>
                  删除
                </el-dropdown-item>
              </el-dropdown-menu>
            </template>
          </el-dropdown>
        </div>
      </div>
    </div>

    <!-- 添加按钮 -->
    <div class="add-button">
      <el-button type="primary" @click="showAddDialog = true">
        <el-icon><Plus /></el-icon>
        添加联系人
      </el-button>
    </div>

    <!-- 添加联系人对话框 -->
    <ContactAddDialog
      v-model="showAddDialog"
      :groups="groups"
      @confirm="addContact"
    />
  </div>
</template>

<script setup lang="ts">
// 组件实现代码（参考使用示例文档）
</script>
```

2. **创建联系人详情组件**

```typescript
// plugins/contact-plugin/src/components/contact/ContactDetail.vue
<template>
  <div class="contact-detail" v-if="contact">
    <!-- 头部信息 -->
    <div class="header">
      <el-avatar :src="contact.avatar" :size="80">
        {{ contact.nickname?.[0] || contact.remark?.[0] || '?' }}
      </el-avatar>
      <div class="info">
        <h3>{{ contact.nickname || contact.remark || contact.user_id }}</h3>
        <p class="status">
          <span class="status-dot" :class="contact.status"></span>
          {{ getStatusText(contact.status) }}
        </p>
      </div>
      <div class="actions">
        <el-button @click="startChat">发消息</el-button>
        <el-button @click="editContact">编辑</el-button>
      </div>
    </div>

    <!-- 详细信息 -->
    <div class="details">
      <el-descriptions :column="1" border>
        <el-descriptions-item label="用户ID">
          {{ contact.user_id }}
        </el-descriptions-item>
        <el-descriptions-item label="昵称">
          {{ contact.nickname || '未设置' }}
        </el-descriptions-item>
        <el-descriptions-item label="备注">
          {{ contact.remark || '未设置' }}
        </el-descriptions-item>
        <el-descriptions-item label="分组">
          {{ contact.group?.name || '默认分组' }}
        </el-descriptions-item>
        <el-descriptions-item label="标签">
          <el-tag
            v-for="tag in contact.tags"
            :key="tag"
            size="small"
            style="margin-right: 8px;"
          >
            {{ tag }}
          </el-tag>
          <span v-if="!contact.tags?.length">无标签</span>
        </el-descriptions-item>
        <el-descriptions-item label="备注">
          {{ contact.notes || '无备注' }}
        </el-descriptions-item>
        <el-descriptions-item label="添加时间">
          {{ formatDate(contact.created_at) }}
        </el-descriptions-item>
        <el-descriptions-item label="最后更新">
          {{ formatDate(contact.updated_at) }}
        </el-descriptions-item>
      </el-descriptions>
    </div>
  </div>
</template>

<script setup lang="ts">
// 组件实现代码
</script>
```

### 步骤4：实现消息插件组件

1. **创建消息列表组件**

```typescript
// plugins/message-plugin/src/components/message/MessageList.vue
<template>
  <div class="message-list">
    <!-- 消息头部 -->
    <div class="header" v-if="conversation">
      <div class="conversation-info">
        <el-avatar :src="getConversationAvatar()" :size="40">
          {{ getConversationName()?.[0] || '?' }}
        </el-avatar>
        <div class="info">
          <h4>{{ getConversationName() }}</h4>
          <p class="status">{{ getConversationStatus() }}</p>
        </div>
      </div>
      <div class="actions">
        <el-button @click="showFileTransfer = true">
          <el-icon><Folder /></el-icon>
          文件
        </el-button>
        <el-button @click="showConversationInfo = true">
          <el-icon><InfoFilled /></el-icon>
          详情
        </el-button>
      </div>
    </div>

    <!-- 消息内容区 -->
    <div class="message-content" ref="messageContainer">
      <!-- 加载更多按钮 -->
      <div class="load-more" v-if="hasMore">
        <el-button @click="loadMoreMessages" :loading="loading">
          加载更多消息
        </el-button>
      </div>

      <!-- 消息列表 -->
      <div class="messages">
        <div
          v-for="message in messages"
          :key="message.id"
          class="message-item"
          :class="{
            'own-message': message.sender_id === currentUserId,
            'system-message': message.message_type === 'system'
          }"
        >
          <!-- 消息时间 -->
          <div class="message-time" v-if="shouldShowTime(message)">
            {{ formatMessageTime(message.created_at) }}
          </div>

          <!-- 消息内容 -->
          <div class="message-bubble">
            <!-- 发送者头像（群聊时显示） -->
            <div class="sender-avatar" v-if="!isOwnMessage(message) && isGroupChat">
              <el-avatar :src="message.sender?.avatar" :size="32">
                {{ message.sender?.nickname?.[0] || '?' }}
              </el-avatar>
            </div>

            <!-- 消息主体 -->
            <div class="message-body">
              <!-- 发送者名称（群聊时显示） -->
              <div class="sender-name" v-if="!isOwnMessage(message) && isGroupChat">
                {{ message.sender?.nickname || message.sender?.user_id }}
              </div>

              <!-- 消息内容 -->
              <div class="message-content-wrapper">
                <!-- 文本消息 -->
                <div v-if="message.message_type === 'text'" class="text-message">
                  {{ message.content }}
                </div>

                <!-- 图片消息 -->
                <div v-else-if="message.message_type === 'image'" class="image-message">
                  <el-image
                    :src="getImageUrl(message)"
                    :preview-src-list="[getImageUrl(message)]"
                    fit="cover"
                    style="max-width: 200px; max-height: 200px;"
                  />
                </div>

                <!-- 文件消息 -->
                <div v-else-if="message.message_type === 'file'" class="file-message">
                  <div class="file-info" @click="downloadFile(message)">
                    <el-icon><Document /></el-icon>
                    <div class="file-details">
                      <div class="file-name">{{ getFileName(message) }}</div>
                      <div class="file-size">{{ formatFileSize(getFileSize(message)) }}</div>
                    </div>
                  </div>
                </div>

                <!-- 系统消息 -->
                <div v-else-if="message.message_type === 'system'" class="system-message">
                  {{ message.content }}
                </div>
              </div>

              <!-- 消息状态和操作 -->
              <div class="message-meta">
                <span class="message-status">
                  {{ getMessageStatus(message) }}
                </span>
                <el-dropdown @command="handleMessageAction">
                  <el-button type="text" size="small">
                    <el-icon><MoreFilled /></el-icon>
                  </el-button>
                  <template #dropdown>
                    <el-dropdown-menu>
                      <el-dropdown-item :command="{ action: 'copy', message }">
                        复制
                      </el-dropdown-item>
                      <el-dropdown-item :command="{ action: 'reply', message }">
                        回复
                      </el-dropdown-item>
                      <el-dropdown-item
                        v-if="canRecall(message)"
                        :command="{ action: 'recall', message }"
                      >
                        撤回
                      </el-dropdown-item>
                      <el-dropdown-item
                        :command="{ action: 'delete', message }"
                        divided
                      >
                        删除
                      </el-dropdown-item>
                    </el-dropdown-menu>
                  </template>
                </el-dropdown>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 消息输入区 -->
    <div class="message-input">
      <MessageEditor
        @send="sendMessage"
        @file-upload="handleFileUpload"
        :disabled="!conversation"
      />
    </div>

    <!-- 文件传输对话框 -->
    <FileTransferDialog
      v-model="showFileTransfer"
      :conversation-id="conversationId"
    />

    <!-- 会话信息对话框 -->
    <ConversationInfoDialog
      v-model="showConversationInfo"
      :conversation="conversation"
    />
  </div>
</template>

<script setup lang="ts">
// 组件实现代码（参考使用示例文档）
</script>
```

### 步骤5：数据迁移

1. **创建数据迁移脚本**

```typescript
// scripts/migrate-plugin-data.ts
import { DatabaseManager } from '../src/main/services/database/Database'
import { PluginDataService } from '../src/main/services/plugin/PluginDataService'

class DataMigration {
  private db: DatabaseManager
  private pluginDataService: PluginDataService

  constructor() {
    this.db = DatabaseManager.getInstance()
    this.pluginDataService = new PluginDataService()
  }

  async migrateContacts() {
    console.log('开始迁移联系人数据...')

    // 从原有的联系人表读取数据
    const contacts = await this.db
      .prepare(
        `
      SELECT * FROM contacts ORDER BY created_at
    `
      )
      .all()

    console.log(`找到 ${contacts.length} 个联系人`)

    // 迁移到新的插件数据结构
    for (const contact of contacts) {
      try {
        // 添加到联系人表（如果不存在）
        await this.pluginDataService.addContact({
          user_id: contact.user_id,
          nickname: contact.nickname,
          remark: contact.remark,
          avatar: contact.avatar,
          status: contact.status || 'offline',
          group_id: contact.group_id || 1,
          is_pinned: contact.is_pinned || false,
          tags: contact.tags ? JSON.parse(contact.tags) : [],
          notes: contact.notes || '',
          created_at: contact.created_at,
          updated_at: contact.updated_at
        })

        console.log(`迁移联系人: ${contact.nickname || contact.user_id}`)
      } catch (error) {
        console.error(`迁移联系人失败: ${contact.user_id}`, error)
      }
    }

    console.log('联系人数据迁移完成')
  }

  async migrateMessages() {
    console.log('开始迁移消息数据...')

    // 从原有的消息表读取数据
    const messages = await this.db
      .prepare(
        `
      SELECT * FROM messages ORDER BY created_at
    `
      )
      .all()

    console.log(`找到 ${messages.length} 条消息`)

    // 迁移到新的插件数据结构
    for (const message of messages) {
      try {
        // 确保会话存在
        let conversation = await this.pluginDataService.getConversation(message.conversation_id)
        if (!conversation) {
          // 创建会话
          conversation = await this.pluginDataService.createConversation({
            conversation_type: message.conversation_type || 'private',
            participants: [message.sender_id, message.receiver_id].filter(Boolean),
            title: message.conversation_title || '',
            created_at: message.created_at
          })
        }

        // 添加消息
        await this.pluginDataService.sendMessage({
          conversation_id: conversation.id,
          sender_id: message.sender_id,
          receiver_id: message.receiver_id,
          content: message.content,
          message_type: message.message_type || 'text',
          attachments: message.attachments ? JSON.parse(message.attachments) : [],
          created_at: message.created_at
        })

        console.log(`迁移消息: ${message.id}`)
      } catch (error) {
        console.error(`迁移消息失败: ${message.id}`, error)
      }
    }

    console.log('消息数据迁移完成')
  }

  async run() {
    try {
      await this.db.initialize()
      await this.pluginDataService.initialize()

      await this.migrateContacts()
      await this.migrateMessages()

      console.log('数据迁移完成')
    } catch (error) {
      console.error('数据迁移失败:', error)
    }
  }
}

// 运行迁移
if (require.main === module) {
  const migration = new DataMigration()
  migration.run()
}
```

2. **运行迁移脚本**

```bash
# 在项目根目录运行
npx ts-node scripts/migrate-plugin-data.ts
```

## 测试验证

### 1. 单元测试

```typescript
// tests/unit/PluginDataService.test.ts
import { PluginDataService } from '../../src/main/services/plugin/PluginDataService'
import { DatabaseManager } from '../../src/main/services/database/Database'

describe('PluginDataService', () => {
  let service: PluginDataService
  let db: DatabaseManager

  beforeEach(async () => {
    db = DatabaseManager.getInstance()
    await db.initialize()
    service = new PluginDataService()
    await service.initialize()
  })

  afterEach(async () => {
    await db.close()
  })

  describe('插件私有数据', () => {
    test('应该能够设置和获取插件数据', async () => {
      const pluginId = 'test-plugin'
      const key = 'test-key'
      const value = { name: 'test', count: 123 }

      // 设置数据
      const setResult = await service.setPluginData(pluginId, key, value)
      expect(setResult).toBe(true)

      // 获取数据
      const getData = await service.getPluginData(pluginId, key)
      expect(getData).toEqual(value)
    })

    test('应该能够删除插件数据', async () => {
      const pluginId = 'test-plugin'
      const key = 'test-key'
      const value = 'test-value'

      // 设置数据
      await service.setPluginData(pluginId, key, value)

      // 删除数据
      const deleteResult = await service.deletePluginData(pluginId, key)
      expect(deleteResult).toBe(true)

      // 验证数据已删除
      const getData = await service.getPluginData(pluginId, key)
      expect(getData).toBeNull()
    })
  })

  describe('共享数据', () => {
    test('应该能够设置和获取共享数据', async () => {
      const namespace = 'contacts'
      const key = 'user-123'
      const value = { name: 'John', email: 'john@example.com' }
      const pluginId = 'test-plugin'

      // 设置共享数据
      const setResult = await service.setSharedData(namespace, key, value, pluginId)
      expect(setResult).toBe(true)

      // 获取共享数据
      const getData = await service.getSharedData(namespace, key)
      expect(getData).toEqual(value)
    })
  })

  describe('联系人管理', () => {
    test('应该能够添加和获取联系人', async () => {
      const contactData = {
        user_id: 'user-123',
        nickname: 'John Doe',
        remark: 'Friend',
        avatar: 'avatar.jpg',
        group_id: 1,
        tags: ['friend', 'work'],
        notes: 'Good friend'
      }

      // 添加联系人
      const newContact = await service.addContact(contactData)
      expect(newContact).toBeTruthy()
      expect(newContact.user_id).toBe(contactData.user_id)

      // 获取联系人
      const getContact = await service.getContact(newContact.id)
      expect(getContact).toBeTruthy()
      expect(getContact.nickname).toBe(contactData.nickname)
    })

    test('应该能够更新联系人', async () => {
      // 先添加联系人
      const contact = await service.addContact({
        user_id: 'user-456',
        nickname: 'Jane',
        group_id: 1
      })

      // 更新联系人
      const updates = {
        nickname: 'Jane Smith',
        remark: 'Colleague'
      }

      const updateResult = await service.updateContact(contact.id, updates)
      expect(updateResult).toBe(true)

      // 验证更新
      const updatedContact = await service.getContact(contact.id)
      expect(updatedContact.nickname).toBe(updates.nickname)
      expect(updatedContact.remark).toBe(updates.remark)
    })

    test('应该能够置顶联系人', async () => {
      // 添加联系人
      const contact = await service.addContact({
        user_id: 'user-789',
        nickname: 'Bob',
        group_id: 1
      })

      // 置顶联系人
      const pinResult = await service.pinContact(contact.id, true)
      expect(pinResult).toBe(true)

      // 验证置顶状态
      const pinnedContact = await service.getContact(contact.id)
      expect(pinnedContact.is_pinned).toBe(true)
    })
  })
})
```

### 2. 集成测试

```typescript
// tests/integration/plugin-data-flow.test.ts
import { PluginDataAPI } from '../../src/renderer/src/services/plugin/PluginDataAPI'
import { DataSyncService } from '../../plugins/shared/services/DataSyncService'

describe('插件数据流集成测试', () => {
  let contactAPI: PluginDataAPI
  let messageAPI: PluginDataAPI
  let syncService: any

  beforeEach(() => {
    contactAPI = new PluginDataAPI('contact-plugin')
    messageAPI = new PluginDataAPI('message-plugin')
    syncService = new DataSyncService('test-plugin')
  })

  test('联系人数据应该在插件间同步', async () => {
    // 在联系人插件中添加联系人
    const contactData = {
      user_id: 'sync-test-user',
      nickname: 'Sync Test',
      group_id: 1
    }

    const newContact = await contactAPI.addContact(contactData)
    expect(newContact).toBeTruthy()

    // 等待同步
    await new Promise((resolve) => setTimeout(resolve, 100))

    // 在消息插件中应该能获取到该联系人
    const contacts = await messageAPI.getContacts()
    const syncedContact = contacts.find((c) => c.user_id === contactData.user_id)
    expect(syncedContact).toBeTruthy()
    expect(syncedContact.nickname).toBe(contactData.nickname)
  })

  test('联系人更新应该触发同步事件', async () => {
    let syncEventReceived = false
    let syncEventData = null

    // 订阅同步事件
    const unsubscribe = syncService.subscribe('contact_updated', (event) => {
      syncEventReceived = true
      syncEventData = event.data
    })

    // 添加联系人
    const contact = await contactAPI.addContact({
      user_id: 'event-test-user',
      nickname: 'Event Test',
      group_id: 1
    })

    // 更新联系人
    await contactAPI.updateContact(contact.id, {
      nickname: 'Updated Name'
    })

    // 等待事件处理
    await new Promise((resolve) => setTimeout(resolve, 100))

    expect(syncEventReceived).toBe(true)
    expect(syncEventData.nickname).toBe('Updated Name')

    unsubscribe()
  })
})
```

### 3. 性能测试

```typescript
// tests/performance/data-operations.test.ts
import { PluginDataService } from '../../src/main/services/plugin/PluginDataService'

describe('数据操作性能测试', () => {
  let service: PluginDataService

  beforeEach(async () => {
    service = new PluginDataService()
    await service.initialize()
  })

  test('批量插入联系人性能', async () => {
    const startTime = Date.now()
    const contactCount = 1000

    // 批量添加联系人
    const promises = []
    for (let i = 0; i < contactCount; i++) {
      promises.push(
        service.addContact({
          user_id: `perf-user-${i}`,
          nickname: `User ${i}`,
          group_id: 1
        })
      )
    }

    await Promise.all(promises)

    const endTime = Date.now()
    const duration = endTime - startTime

    console.log(`批量插入 ${contactCount} 个联系人耗时: ${duration}ms`)
    expect(duration).toBeLessThan(5000) // 应该在5秒内完成
  })

  test('大量数据查询性能', async () => {
    // 先插入大量数据
    for (let i = 0; i < 5000; i++) {
      await service.addContact({
        user_id: `query-user-${i}`,
        nickname: `Query User ${i}`,
        group_id: Math.floor(i / 100) + 1
      })
    }

    const startTime = Date.now()

    // 执行查询
    const contacts = await service.getContacts({
      limit: 100,
      sortBy: 'created_at',
      sortOrder: 'desc'
    })

    const endTime = Date.now()
    const duration = endTime - startTime

    console.log(`查询 100 个联系人耗时: ${duration}ms`)
    expect(duration).toBeLessThan(100) // 应该在100ms内完成
    expect(contacts.length).toBe(100)
  })
})
```

## 部署上线

### 1. 构建配置

```json
// package.json
{
  "scripts": {
    "build": "npm run build:main && npm run build:renderer && npm run build:plugins",
    "build:main": "tsc -p src/main/tsconfig.json",
    "build:renderer": "vite build src/renderer",
    "build:plugins": "npm run build:contact-plugin && npm run build:message-plugin",
    "build:contact-plugin": "vite build plugins/contact-plugin",
    "build:message-plugin": "vite build plugins/message-plugin",
    "test": "jest",
    "test:unit": "jest tests/unit",
    "test:integration": "jest tests/integration",
    "test:performance": "jest tests/performance",
    "migrate": "ts-node scripts/migrate-plugin-data.ts"
  }
}
```

### 2. 发布流程

```bash
# 1. 运行测试
npm run test

# 2. 构建项目
npm run build

# 3. 数据迁移（首次部署）
npm run migrate

# 4. 打包应用
npm run dist
```

### 3. 版本升级

```typescript
// scripts/upgrade-database.ts
import { DatabaseManager } from '../src/main/services/database/Database'

class DatabaseUpgrade {
  private db: DatabaseManager

  constructor() {
    this.db = DatabaseManager.getInstance()
  }

  async checkVersion(): Promise<string> {
    try {
      const result = await this.db
        .prepare(
          `
        SELECT value FROM plugin_configs 
        WHERE plugin_id = 'system' AND key = 'db_version'
      `
        )
        .get()

      return result?.value || '1.0.0'
    } catch {
      return '1.0.0'
    }
  }

  async upgradeToVersion(version: string) {
    const currentVersion = await this.checkVersion()

    if (currentVersion === version) {
      console.log(`数据库已是最新版本: ${version}`)
      return
    }

    console.log(`升级数据库从 ${currentVersion} 到 ${version}`)

    // 根据版本执行相应的升级脚本
    switch (version) {
      case '1.1.0':
        await this.upgradeToV1_1_0()
        break
      case '1.2.0':
        await this.upgradeToV1_2_0()
        break
      default:
        throw new Error(`不支持的版本: ${version}`)
    }

    // 更新版本号
    await this.db
      .prepare(
        `
      INSERT OR REPLACE INTO plugin_configs (plugin_id, key, value, updated_at)
      VALUES ('system', 'db_version', ?, datetime('now'))
    `
      )
      .run(version)

    console.log(`数据库升级完成: ${version}`)
  }

  private async upgradeToV1_1_0() {
    // 添加新字段或表
    await this.db.exec(`
      ALTER TABLE contacts ADD COLUMN last_seen_at TEXT;
      ALTER TABLE messages ADD COLUMN edited_at TEXT;
    `)
  }

  private async upgradeToV1_2_0() {
    // 更多升级逻辑
    await this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_messages_edited_at ON messages(edited_at);
    `)
  }
}

// 运行升级
if (require.main === module) {
  const upgrade = new DatabaseUpgrade()
  const targetVersion = process.argv[2] || '1.2.0'
  upgrade.upgradeToVersion(targetVersion)
}
```

## 维护和优化

### 1. 监控和日志

```typescript
// src/main/services/monitoring/PluginMonitor.ts
export class PluginMonitor {
  private static instance: PluginMonitor
  private metrics = new Map<string, any>()

  static getInstance() {
    if (!PluginMonitor.instance) {
      PluginMonitor.instance = new PluginMonitor()
    }
    return PluginMonitor.instance
  }

  recordOperation(pluginId: string, operation: string, duration: number) {
    const key = `${pluginId}:${operation}`
    const existing = this.metrics.get(key) || { count: 0, totalTime: 0, avgTime: 0 }

    existing.count++
    existing.totalTime += duration
    existing.avgTime = existing.totalTime / existing.count

    this.metrics.set(key, existing)
  }

  getMetrics() {
    return Object.fromEntries(this.metrics)
  }

  logSlowOperations(threshold: number = 1000) {
    for (const [key, metric] of this.metrics) {
      if (metric.avgTime > threshold) {
        console.warn(`慢操作检测: ${key} 平均耗时 ${metric.avgTime}ms`)
      }
    }
  }
}
```

### 2. 性能优化

```typescript
// src/main/services/optimization/CacheOptimizer.ts
export class CacheOptimizer {
  private cache = new Map<string, { data: any; expiry: number; hits: number }>()
  private maxSize = 1000
  private defaultTTL = 300000 // 5分钟

  set(key: string, data: any, ttl: number = this.defaultTTL) {
    // 如果缓存已满，清理最少使用的项
    if (this.cache.size >= this.maxSize) {
      this.evictLeastUsed()
    }

    this.cache.set(key, {
      data,
      expiry: Date.now() + ttl,
      hits: 0
    })
  }

  get(key: string) {
    const item = this.cache.get(key)
    if (!item) return null

    if (Date.now() > item.expiry) {
      this.cache.delete(key)
      return null
    }

    item.hits++
    return item.data
  }

  private evictLeastUsed() {
    let leastUsedKey = ''
    let leastHits = Infinity

    for (const [key, item] of this.cache) {
      if (item.hits < leastHits) {
        leastHits = item.hits
        leastUsedKey = key
      }
    }

    if (leastUsedKey) {
      this.cache.delete(leastUsedKey)
    }
  }

  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hitRate: this.calculateHitRate()
    }
  }

  private calculateHitRate(): number {
    let totalHits = 0
    let totalRequests = 0

    for (const item of this.cache.values()) {
      totalHits += item.hits
      totalRequests += item.hits + 1 // +1 for the initial miss
    }

    return totalRequests > 0 ? totalHits / totalRequests : 0
  }
}
```

## 常见问题

### Q1: 插件数据同步延迟怎么办？

**A**:

1. 检查事件发布/订阅机制是否正常
2. 优化数据同步频率
3. 使用批量同步减少频繁更新
4. 检查网络和数据库性能

### Q2: 数据库性能问题如何解决？

**A**:

1. 添加适当的索引
2. 使用分页查询
3. 实现数据缓存
4. 定期清理历史数据
5. 使用数据库连接池

### Q3: 插件权限控制如何配置？

**A**:

1. 在 `plugin_permissions` 表中配置权限
2. 使用 `PluginPermissionManager` 检查权限
3. 实现细粒度的权限控制
4. 定期审计权限使用情况

### Q4: 如何处理数据冲突？

**A**:

1. 使用时间戳进行冲突检测
2. 实现数据合并策略
3. 提供用户选择界面
4. 记录冲突日志便于分析

### Q5: 插件升级时如何保证数据兼容性？

**A**:

1. 使用数据库版本控制
2. 编写数据迁移脚本
3. 保持向后兼容
4. 提供数据备份和恢复功能

## 总结

本实现指南提供了完整的插件数据存储方案，包括：

1. **完整的技术架构**：从数据库到前端的完整技术栈
2. **详细的实现步骤**：分阶段的实现指导
3. **丰富的代码示例**：可直接使用的代码模板
4. **全面的测试方案**：单元测试、集成测试、性能测试
5. **完善的部署流程**：从构建到上线的完整流程
6. **持续的维护优化**：监控、优化、问题解决

通过遵循本指南，开发团队可以高效地实现插件数据存储方案，确保系统的稳定性、性能和可维护性。

### 关键成功因素

1. **分阶段实施**：按照既定的五个阶段逐步实施，确保每个阶段的质量
2. **充分测试**：在每个阶段都进行充分的测试，及早发现和解决问题
3. **性能监控**：建立完善的监控体系，持续优化系统性能
4. **文档维护**：保持文档的及时更新，便于团队协作和知识传承
5. **用户反馈**：收集用户反馈，持续改进用户体验

### 下一步计划

1. **立即执行**：
   - 集成数据库扩展到主进程
   - 注册IPC处理器
   - 运行数据迁移脚本

2. **短期目标（1-2周）**：
   - 完成联系人插件重构
   - 完成消息插件重构
   - 实现基础的数据同步

3. **中期目标（1个月）**：
   - 完善所有功能特性
   - 完成全面测试
   - 优化性能和用户体验

4. **长期目标（持续）**：
   - 监控系统运行状况
   - 收集用户反馈并改进
   - 扩展更多插件功能

---

**文档版本**: v1.0  
**最后更新**: 2024年1月  
**维护者**: 开发团队  
**联系方式**: dev-team@why-talk.com
