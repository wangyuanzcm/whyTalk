# WhyTalk 插件开发指南

本文档详细介绍了如何为 WhyTalk 创建和开发插件，包括完整的步骤、文件结构和最佳实践。

## 目录

1. [快速开始](#快速开始)
2. [插件结构](#插件结构)
3. [开发步骤](#开发步骤)
4. [配置文件详解](#配置文件详解)
5. [API 使用](#api-使用)
6. [WebView 开发](#webview-开发)
7. [构建和打包](#构建和打包)
8. [调试和测试](#调试和测试)
9. [发布和安装](#发布和安装)
10. [最佳实践](#最佳实践)

## 快速开始

### 1. 创建插件目录

```bash
# 在 extensions 目录下创建新插件
cd extensions
mkdir my-plugin
cd my-plugin
```

### 2. 初始化基本文件结构

```
my-plugin/
├── package.json          # 插件配置文件
├── tsconfig.json         # TypeScript 配置
├── build.js              # 构建脚本
├── src/                  # 源代码目录
│   ├── extension.ts      # 插件主入口
│   └── whytalk.d.ts     # 类型定义
├── webview/              # WebView 前端文件
│   ├── index.html       # 主页面
│   ├── style.css        # 样式文件
│   └── script.js        # 脚本文件
├── out/                  # 编译输出目录
└── dist/                 # 打包输出目录
```

## 插件结构

### 核心文件说明

#### package.json
插件的配置文件，定义插件的基本信息、激活事件、贡献点等。

#### src/extension.ts
插件的主入口文件，包含激活函数、命令处理逻辑等。

#### webview/
WebView 前端文件目录，包含 HTML、CSS、JavaScript 文件。

#### build.js
构建脚本，用于编译 TypeScript、复制文件、打包等操作。

## 开发步骤

### 步骤 1: 创建 package.json

```json
{
  "name": "my-plugin",
  "displayName": "我的插件",
  "description": "这是我的第一个 WhyTalk 插件",
  "version": "1.0.0",
  "publisher": "your-name",
  "engines": {
    "whytalk": "^1.0.0"
  },
  "categories": [
    "Other"
  ],
  "keywords": [
    "whytalk",
    "extension"
  ],
  "activationEvents": [
    "onCommand:myPlugin.activate"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "myPlugin.activate",
        "title": "激活我的插件"
      },
      {
        "command": "myPlugin.openWebView",
        "title": "打开插件界面"
      }
    ],
    "webviews": [
      {
        "viewType": "myPlugin.webview",
        "title": "我的插件界面"
      }
    ]
  },
  "scripts": {
    "build": "node build.js build",
    "watch": "node build.js watch",
    "clean": "node build.js clean",
    "package": "node build.js package"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

### 步骤 2: 创建 TypeScript 配置

创建 `tsconfig.json`：

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./out",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "out",
    "dist"
  ]
}
```

### 步骤 3: 创建类型定义文件

创建 `src/whytalk.d.ts`：

```typescript
/**
 * WhyTalk 扩展 API 类型定义
 */
declare module 'whytalk' {
  /**
   * 扩展上下文接口
   */
  export interface ExtensionContext {
    /** 扩展路径 */
    extensionPath: string
    /** 全局状态 */
    globalState: any
    /** 工作区状态 */
    workspaceState: any
    /** 订阅管理 */
    subscriptions: Disposable[]
  }

  /**
   * 可释放资源接口
   */
  export interface Disposable {
    dispose(): void
  }

  /**
   * 激活函数
   */
  export function activate(context: ExtensionContext, api: any): Promise<void>

  /**
   * 停用函数
   */
  export function deactivate(): void
}
```

### 步骤 4: 创建主入口文件

创建 `src/extension.ts`：

```typescript
import * as vscode from 'whytalk'
import * as path from 'path'

/**
 * 插件主类
 */
class MyPluginExtension {
  private panel: any = null

  constructor(
    private context: vscode.ExtensionContext,
    private api: any
  ) {}

  /**
   * 创建或显示 WebView 面板
   */
  public createOrShowWebView() {
    if (this.panel) {
      this.panel.reveal()
      return
    }

    // 创建 WebView 面板
    this.panel = this.api.window.createWebviewPanel(
      'myPlugin.webview',
      '我的插件界面',
      this.api.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          this.api.Uri.file(path.join(this.context.extensionPath, 'webview'))
        ]
      }
    )

    // 设置 WebView 内容
    this.panel.webview.html = this.getWebviewContent()
    
    // 设置消息处理
    this.setupWebviewMessageHandling()

    // 监听面板关闭事件
    this.panel.onDidDispose(() => {
      this.panel = null
    })
  }

  /**
   * 获取 WebView HTML 内容
   */
  private getWebviewContent(): string {
    const webviewPath = path.join(this.context.extensionPath, 'webview')
    const htmlPath = path.join(webviewPath, 'index.html')

    try {
      const fs = require('fs')
      let html = fs.readFileSync(htmlPath, 'utf8')

      // 替换资源路径为 webview URI
      const cssUri = this.panel!.webview.asWebviewUri(
        this.api.Uri.file(path.join(webviewPath, 'style.css'))
      )
      const jsUri = this.panel!.webview.asWebviewUri(
        this.api.Uri.file(path.join(webviewPath, 'script.js'))
      )

      html = html.replace('<head>', `<head>\n    <link rel="stylesheet" href="${cssUri}">`)
      html = html.replace('</body>', `    <script src="${jsUri}"></script>\n</body>`)

      return html
    } catch (error) {
      return this.getDefaultWebviewContent()
    }
  }

  /**
   * 获取默认 WebView 内容
   */
  private getDefaultWebviewContent(): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>我的插件</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; }
          .container { max-width: 800px; margin: 0 auto; }
          .button { padding: 10px 20px; margin: 5px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; }
        </style>
      </head>
      <body>
        <div class="container">
          <h1>我的插件</h1>
          <p>欢迎使用我的第一个 WhyTalk 插件！</p>
          <button class="button" onclick="sendMessage('hello')">发送消息</button>
        </div>
        <script>
          const vscode = acquireVsCodeApi();
          function sendMessage(command) {
            vscode.postMessage({ command: command });
          }
        </script>
      </body>
      </html>
    `
  }

  /**
   * 设置 WebView 消息处理
   */
  private setupWebviewMessageHandling() {
    this.panel.webview.onDidReceiveMessage(
      (message: any) => this.handleWebviewMessage(message),
      undefined,
      this.context.subscriptions
    )
  }

  /**
   * 处理 WebView 消息
   */
  private async handleWebviewMessage(message: any) {
    switch (message.command) {
      case 'hello':
        this.api.window.showInformationMessage('Hello from WebView!')
        break
      default:
        console.log('Unknown message:', message)
    }
  }
}

// 全局扩展实例
let extension: MyPluginExtension

/**
 * 插件激活函数
 */
export async function activate(context: vscode.ExtensionContext, api: any) {
  console.log('我的插件已激活')

  // 创建扩展实例
  extension = new MyPluginExtension(context, api)

  // 注册命令
  const activateCommand = api.commands.registerCommand(
    'myPlugin.activate',
    () => {
      api.window.showInformationMessage('我的插件已激活！')
    }
  )

  const openWebViewCommand = api.commands.registerCommand(
    'myPlugin.openWebView',
    () => {
      extension.createOrShowWebView()
    }
  )

  // 添加到订阅列表
  context.subscriptions.push(activateCommand, openWebViewCommand)
}

/**
 * 插件停用函数
 */
export function deactivate() {
  console.log('我的插件已停用')
}
```

### 步骤 5: 创建 WebView 前端文件

#### index.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>我的插件</title>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>我的插件界面</h1>
      <p>这是我的第一个 WhyTalk 插件</p>
    </div>

    <div class="content">
      <div class="section">
        <h3>基础操作</h3>
        <div class="button-group">
          <button class="button" onclick="sendMessage('hello')">发送问候</button>
          <button class="button" onclick="sendMessage('info')">获取信息</button>
        </div>
      </div>

      <div class="section">
        <h3>输出区域</h3>
        <div id="output" class="output-area">
          <p>等待操作...</p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
```

#### style.css

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f5f5f5;
  color: #333;
  line-height: 1.6;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.header {
  text-align: center;
  margin-bottom: 30px;
  padding: 20px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.header h1 {
  color: #007acc;
  margin-bottom: 10px;
}

.content {
  display: grid;
  gap: 20px;
}

.section {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.section h3 {
  margin-bottom: 15px;
  color: #333;
  border-bottom: 2px solid #007acc;
  padding-bottom: 5px;
}

.button-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.button {
  padding: 10px 20px;
  background: #007acc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;
}

.button:hover {
  background: #005a9e;
}

.output-area {
  background: #f8f8f8;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 15px;
  min-height: 100px;
  font-family: 'Courier New', monospace;
  white-space: pre-wrap;
}
```

#### script.js

```javascript
// 获取 VS Code API
const vscode = acquireVsCodeApi();

/**
 * 发送消息到扩展后台
 * @param {string} command 命令名称
 * @param {any} data 数据
 */
function sendMessage(command, data = null) {
  vscode.postMessage({
    command: command,
    data: data
  });
}

/**
 * 更新输出区域
 * @param {string} message 消息内容
 */
function updateOutput(message) {
  const output = document.getElementById('output');
  const timestamp = new Date().toLocaleTimeString();
  output.innerHTML += `[${timestamp}] ${message}\n`;
  output.scrollTop = output.scrollHeight;
}

// 监听来自扩展的消息
window.addEventListener('message', event => {
  const message = event.data;
  
  switch (message.command) {
    case 'updateOutput':
      updateOutput(message.data);
      break;
    default:
      console.log('Unknown message from extension:', message);
  }
});

// 页面加载完成后的初始化
document.addEventListener('DOMContentLoaded', function() {
  updateOutput('插件界面已加载');
});
```

### 步骤 6: 创建构建脚本

创建 `build.js`：

```javascript
const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')

/**
 * 构建脚本类
 */
class Builder {
  constructor() {
    this.rootDir = __dirname
    this.srcDir = path.join(this.rootDir, 'src')
    this.outDir = path.join(this.rootDir, 'out')
    this.webviewDir = path.join(this.rootDir, 'webview')
    this.distDir = path.join(this.rootDir, 'dist')
  }

  /**
   * 确保目录存在
   */
  ensureDir(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }
  }

  /**
   * 复制文件
   */
  copyFile(src, dest) {
    this.ensureDir(path.dirname(dest))
    fs.copyFileSync(src, dest)
  }

  /**
   * 复制目录
   */
  copyDir(src, dest) {
    this.ensureDir(dest)
    const files = fs.readdirSync(src)
    
    for (const file of files) {
      const srcPath = path.join(src, file)
      const destPath = path.join(dest, file)
      
      if (fs.statSync(srcPath).isDirectory()) {
        this.copyDir(srcPath, destPath)
      } else {
        this.copyFile(srcPath, destPath)
      }
    }
  }

  /**
   * 编译 TypeScript
   */
  compileTypeScript() {
    console.log('编译 TypeScript...')
    try {
      execSync('npx tsc', { stdio: 'inherit', cwd: this.rootDir })
      console.log('TypeScript 编译完成')
    } catch (error) {
      console.error('TypeScript 编译失败:', error.message)
      process.exit(1)
    }
  }

  /**
   * 复制资源文件
   */
  copyResources() {
    console.log('复制资源文件...')
    
    // 复制 package.json
    this.copyFile(
      path.join(this.rootDir, 'package.json'),
      path.join(this.outDir, 'package.json')
    )
    
    // 复制 webview 目录
    if (fs.existsSync(this.webviewDir)) {
      this.copyDir(this.webviewDir, path.join(this.outDir, 'webview'))
    }
    
    console.log('资源文件复制完成')
  }

  /**
   * 清理输出目录
   */
  clean() {
    console.log('清理输出目录...')
    
    if (fs.existsSync(this.outDir)) {
      fs.rmSync(this.outDir, { recursive: true, force: true })
    }
    
    if (fs.existsSync(this.distDir)) {
      fs.rmSync(this.distDir, { recursive: true, force: true })
    }
    
    console.log('清理完成')
  }

  /**
   * 构建项目
   */
  build() {
    console.log('开始构建...')
    
    this.ensureDir(this.outDir)
    this.compileTypeScript()
    this.copyResources()
    
    console.log('构建完成')
  }

  /**
   * 监听模式
   */
  watch() {
    console.log('启动监听模式...')
    
    this.build()
    
    // 监听 TypeScript 文件变化
    try {
      execSync('npx tsc --watch', { stdio: 'inherit', cwd: this.rootDir })
    } catch (error) {
      console.error('监听模式启动失败:', error.message)
    }
  }

  /**
   * 打包扩展
   */
  package() {
    console.log('打包扩展...')
    
    // 先构建
    this.build()
    
    // 创建 dist 目录
    this.ensureDir(this.distDir)
    
    // 读取 package.json 获取扩展信息
    const packageJson = JSON.parse(
      fs.readFileSync(path.join(this.rootDir, 'package.json'), 'utf8')
    )
    
    const extensionName = packageJson.name
    const version = packageJson.version
    const zipFileName = `${extensionName}-${version}.zip`
    const zipPath = path.join(this.distDir, zipFileName)
    
    // 创建 ZIP 文件
    try {
      const archiver = require('archiver')
      const output = fs.createWriteStream(zipPath)
      const archive = archiver('zip', { zlib: { level: 9 } })
      
      output.on('close', () => {
        console.log(`扩展已打包: ${zipFileName} (${archive.pointer()} bytes)`)
      })
      
      archive.on('error', (err) => {
        throw err
      })
      
      archive.pipe(output)
      archive.directory(this.outDir, false)
      archive.finalize()
      
    } catch (error) {
      // 如果没有 archiver，使用系统命令
      console.log('使用系统命令创建 ZIP 文件...')
      
      try {
        const cwd = this.outDir
        execSync(`powershell Compress-Archive -Path * -DestinationPath "${zipPath}"`, { cwd })
        console.log(`扩展已打包: ${zipFileName}`)
      } catch (zipError) {
        console.error('打包失败:', zipError.message)
        process.exit(1)
      }
    }
  }
}

// 命令行处理
const builder = new Builder()
const command = process.argv[2]

switch (command) {
  case 'build':
    builder.build()
    break
  case 'watch':
    builder.watch()
    break
  case 'clean':
    builder.clean()
    break
  case 'package':
    builder.package()
    break
  default:
    console.log('可用命令:')
    console.log('  build   - 构建扩展')
    console.log('  watch   - 监听模式')
    console.log('  clean   - 清理输出')
    console.log('  package - 打包扩展')
}
```

## 配置文件详解

### package.json 字段说明

- **name**: 扩展的唯一标识符
- **displayName**: 显示名称
- **description**: 扩展描述
- **version**: 版本号（遵循语义化版本）
- **publisher**: 发布者
- **engines**: 支持的 WhyTalk 版本
- **categories**: 扩展分类
- **keywords**: 关键词
- **activationEvents**: 激活事件
- **main**: 主入口文件
- **contributes**: 贡献点配置

### 激活事件类型

- `onCommand:commandId`: 当执行特定命令时激活
- `onWebviewPanel:viewType`: 当打开特定 WebView 时激活
- `*`: 启动时立即激活（谨慎使用）

### 贡献点类型

- **commands**: 注册命令
- **webviews**: 注册 WebView 面板
- **configuration**: 注册配置项
- **menus**: 注册菜单项

## API 使用

### 常用 API

```typescript
// 显示消息
api.window.showInformationMessage('信息消息')
api.window.showWarningMessage('警告消息')
api.window.showErrorMessage('错误消息')

// 注册命令
api.commands.registerCommand('commandId', () => {
  // 命令处理逻辑
})

// 创建 WebView
api.window.createWebviewPanel(
  'viewType',
  'title',
  api.ViewColumn.One,
  options
)

// 获取配置
api.workspace.getConfiguration('sectionName')

// 设置配置
api.workspace.getConfiguration().update('key', value)
```

## WebView 开发

### 消息通信

#### 从 WebView 发送消息到扩展

```javascript
const vscode = acquireVsCodeApi()
vscode.postMessage({
  command: 'myCommand',
  data: { key: 'value' }
})
```

#### 从扩展发送消息到 WebView

```typescript
panel.webview.postMessage({
  command: 'updateData',
  data: { key: 'value' }
})
```

#### 在 WebView 中接收消息

```javascript
window.addEventListener('message', event => {
  const message = event.data
  switch (message.command) {
    case 'updateData':
      // 处理数据更新
      break
  }
})
```

### 状态管理

```javascript
// 保存状态
vscode.setState({ key: 'value' })

// 获取状态
const state = vscode.getState()
```

## 构建和打包

### 开发时构建

```bash
# 构建一次
npm run build

# 监听模式（自动重新构建）
npm run watch
```

### 清理输出

```bash
npm run clean
```

### 打包发布

```bash
npm run package
```

打包后会在 `dist/` 目录生成 ZIP 文件。

## 调试和测试

### 调试技巧

1. **使用 console.log**: 在扩展代码中添加日志
2. **WebView 调试**: 在 WebView 中使用浏览器开发者工具
3. **错误处理**: 添加适当的错误处理和用户反馈

### 测试方法

1. **功能测试**: 测试所有命令和功能
2. **界面测试**: 测试 WebView 界面的响应性
3. **兼容性测试**: 测试不同版本的 WhyTalk

## 发布和安装

### 本地安装

1. 运行 `npm run package` 生成 ZIP 文件
2. 在 WhyTalk 中选择"本地安装扩展"
3. 选择生成的 ZIP 文件进行安装

### 发布到扩展市场

（待 WhyTalk 扩展市场开放后补充）

## 最佳实践

### 代码规范

1. **使用 TypeScript**: 提供更好的类型安全
2. **添加注释**: 为函数和类添加详细注释
3. **错误处理**: 添加适当的错误处理逻辑
4. **资源清理**: 在 deactivate 中清理资源

### 性能优化

1. **懒加载**: 只在需要时加载资源
2. **缓存**: 合理使用缓存减少重复计算
3. **异步操作**: 使用异步操作避免阻塞

### 用户体验

1. **友好的错误消息**: 提供清晰的错误提示
2. **进度反馈**: 对长时间操作提供进度反馈
3. **快捷键**: 为常用功能提供快捷键
4. **配置选项**: 提供必要的配置选项

### 安全考虑

1. **输入验证**: 验证所有用户输入
2. **权限控制**: 只请求必要的权限
3. **数据保护**: 保护用户敏感数据

## 常见问题

### Q: 扩展无法激活？
A: 检查 `package.json` 中的 `activationEvents` 和 `main` 字段是否正确。

### Q: WebView 无法显示？
A: 检查 HTML 文件路径和资源引用是否正确。

### Q: 命令无法执行？
A: 确保命令已在 `package.json` 的 `contributes.commands` 中注册。

### Q: 构建失败？
A: 检查 TypeScript 配置和依赖是否正确安装。

## 示例项目

参考 `extensions/sample-extension` 和 `extensions/requirement-management` 目录中的示例项目。

## 更多资源

- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
- [Node.js 官方文档](https://nodejs.org/docs/)
- [VS Code 扩展开发指南](https://code.visualstudio.com/api)（参考架构）

---

本文档会随着 WhyTalk 扩展系统的发展持续更新。如有问题或建议，请提交 Issue 或 Pull Request。